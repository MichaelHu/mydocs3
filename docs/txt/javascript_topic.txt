Javascript相关专题

修订记录：
修订内容    修订人  修订时间
初稿    胡大民  2011/4/5前
添加JS的Global部分  胡大民  2011/4/5
添加JS数据类型以及==判断的陷阱  胡大民  2011/4/6
添加JS函数传参  胡大民  2011/5/18
        
        
?

目录
Javascript相关专题  1
1 JS基础    3
1.1 JS的Global  3
1.2 JS的数据类型    3
1.3 ==判断的陷阱    4
1.4 JS的函数传参    6
2 JS高级应用    9
2.1 prototype   10
2.2 实现基于prototype的继承 11
3 JS实践    12
3.1 部分GBK编码字符转换问题（todo） 12
3.2 JS高级应用  14
4 JS新技术  14
4.1 Server-Sent Events  14

?

1 JS基础
1.1 JS的Global
暂不说JS包含了哪些Global的属性和函数，先看Global函数中的Number和String。也即JS将Number和String两个乍一看像是数字和字符串构造函数的东东作为全局函数提供给运行上下文。所以，以下语句有点小区别：
var n = Number(1), s = String('');
var a = Array(), r = RegExp();
区别如下：
n instanceof Number    false
s instanceof String    false
a instanceof Array     true
r instanceof RegExp    true
要使前两个为true，需要使用new操作符。
var n = new Number(1), 
s = new String('');
但是，不管使用哪种方式，以下语句都是true。
n.constructor  ==  Number
s.constructor  ==  String
1.2 JS的数据类型
JS有6种数据类型和10中封装类型。分别是：
数据类型    undefined, null, number, string, boolean, object
封装类型    Number, String, Array, Object, Function,
Boolean, RegExp, Math, Date, Error
1.3 ==判断的陷阱
使用==判断，可能存在一些问题，因为==判断时，解析器会尝试进行某些类型转换。
undefined == false | NO
undefined == 0 | NO
undefined == | NO
undefined == null | OK
undefined == NaN | NO
false == 0 | OK
false == null | NO
false == | OK
false == NaN | NO
null == 0 | NO
null == | NO
null == NaN | NO
NaN == 0 | NO
NaN == | NO
== 0 | OK
true == 1 | OK
true == 2 | NO
false == 2 | NO
来自测试用例：
function w(left, right){
    document.write(left + ' == ' + right + ' | ');
    if(left == right)
        document.write('OK<br>');
    else
        document.write('NO<br>');
}

    w(undefined, false);
    w(undefined, 0);
    w(undefined, '');
    w(undefined, null);
    w(undefined, NaN);
    w(false, 0);
    w(false, null);
    w(false, '');
    w(false, NaN);
    w(null, 0);
    w(null, '');
    w(null, NaN);
    w(NaN, 0);
    w(NaN, '');
    w('', 0);

    w(true, 1);
    w(true, 2);
    w(false, 2);
结论：
1.  undefined == null
2.  0 == false == ''  【0 force empty】
3.  2 != true, 2 != false
可以规避以下问题：
function show(n){
    if(n == ''){
        alert('empty');
    }
    else{
        alert('index_' + n);
    }
}

show(''); // empty
show('0'); // expected index_0, but empty
show(1);  // index_1
1.4 JS的函数传参
JavaScript: The Definitive Guide, 5th Edition， 4.4
The types can be divided into two groups: primitive types and reference types. Numbers, boolean values, and the null and undefined types are primitive. Objects, arrays, and functions are reference types.
函数传参，基本类型按值传递，引用类型按引用传递。字符串（包含字面量和new String（））按值传递。
function printscale(scale){
    document.write(scale + '<br>');
}
function printarr(arr){
    for(var i=0; i<arr.length; i++){
        document.write(i + ': ' + arr[i] + '<br>');
    }
}
function printobj(obj){
    for(var i in obj){
        document.write(i + ': ' + obj[i] + '<br>');
    }
}
var line = '<hr>';

var i = 10, b = false, s = 'Hello, World!!', s1 = new String('Hello, World!!');
function fi(i){i=20;}
function fb(b){b=true;}
function fs(s){s='Hello, Michael!!'}
printscale(i);
printscale(b);
printscale(s);
printscale(s1);
fi(i);
fb(b);
fs(s);
fs(s1);
printscale(i);
printscale(b);
printscale(s);
printscale(s1);

var arr = [1, 2, 3, 4, 5];
function f1(arr){
    arr[1] = 18;
    arr.length = 3;
}
printscale(line);
printarr(arr);
f1(arr);
printarr(arr);

var obj = {
    name: 'Michael',
    age: 28
};
function f2(obj){
    obj.salary = 10000;
    obj.age = 29;
}
printscale(line);
printobj(obj);
f2(obj);
printobj(obj);

function Person(name){
    this.name = name;
}
var obj = new Person('Rice');
printscale(line);
printobj(obj);
f2(obj);
printobj(obj);
结果输出：
10
false
Hello, World!!
Hello, World!!
10
false
Hello, World!!
Hello, World!!
________________________________________

0: 1
1: 2
2: 3
3: 4
4: 5
0: 1
1: 18
2: 3
________________________________________

name: Michael
age: 28
name: Michael
age: 29
salary: 10000
________________________________________

name: Rice
name: Rice
salary: 10000
age: 29

2 JS高级应用

2.1 prototype
引用ECMA-262（p3）的一段话：
ECMAScript does not contain proper classes such as those in C++, Smalltalk, or Java, but rather ,supports constructors which create objects by executing code that allocates storage for the objects and initialises all or part of them by assigning initial values to their properties. All constructors are objects, but not all objects are constructors. Each constructor has a Prototype property that is used to implement prototype-based inheritance and shared properties.
可以归纳出几点：
1.  ECMAScript没有类似C++、Java等语言中描述的类的概念
2.  但它支持构造器（constructor，为了和C++等区别，就不说成是构造函数了），constructor通过执行一段代码来创建对象，这段代码执行内存分配以及初始化等工作。
3.  构造器都是对象，但对象不一定是构造器。
4.  每个构造器都有一个prototype属性，用于实现基于prototype的继承以及共享属性。

ECMAScript supports prototype-based inheritance. Every constructor has an associated prototype, and every object created by that constructor has an implicit reference to the prototype (called the object’s prototype) associated with its constructor.
每个通过构造器创建的对象，都会有一个隐式的引用，该引用指向构造器的prototype属性。

A  prototype is an object used to implement structure, state, and behaviour inheritance in ECMAScript. When a constructor creates an object, that object implicitly references the constructor’s associated prototype for the purpose of resolving property references. The constructor’s associated prototype can be referenced by the program expression constructor.prototype, and properties added to an object’s prototype are shared, through inheritance, by all objects sharing the prototype.
1.  prototype也是一个对象，用于实现结构、状态和行为的继承。
2.  构造器的prototype可以通过这种方式引用：constructor.prototype
3.  由构造器创建的所有对象共享构造器prototype对象的所有属性。

2.2 实现基于prototype的继承
// Person构造函数
function Person(name, age){
    this.name = name;
    this.age = age;
}

// 公共实例方法
Person.prototype.sayHello = function(){
    alert("hello, I'm " + this.name);
};

// Student构造函数
function Student(name, age, score){
    Person.call(this, name, age);
    this.score = score;
}

// 构造原型链，进行继承
Student.prototype = new Person();
Student.prototype.constructor = Student;

// 公共实例方法
Student.prototype.showScore = function(){
    alert('My score: ' + this.score);
};

// GoodStudent构造函数
function GoodStudent(name, age, score, scholarship){
    Student.call(this, name, age, score);
    this.scholarship = scholarship;
}

// 构造原型链，进行继承
GoodStudent.prototype = new Student();
GoodStudent.prototype.constructor = GoodStudent;

constructor属性

3 JS实践
3.1 部分GBK编码字符转换问题（todo）
Windows的ANSI编码与GBK编码是什么关系？通常我们在Editplus里面编辑文本的时候，如果想用GBK编码保存，会选择ANSI编码，这种选择在大多数情况下都是那么好使。但是，有极少一部分GBK编码文本在ANSI模式下却无法正常保存，会提示编码丢失。如下（这里列的不全）：
??????????????????????????????????????????????????????
这些文本在Linux下，不管是gb18030，gb2312还是gbk，SecureCRT都无法正常显示这些文本。但是可以正常保存成gb18030，无法保存成gb2312或者gbk。
综上，这些编码落在gb18030和gb2312的差集中，从unicode或者utf8编码向Windows的ANSI或者Linux的gb2312或gbk转码的时候会出现问题。

GBK文本在文本框提交时，可能出现的问题：
var str1 = '??????????????????????????????????????????????????????';
document.write(escape(str1).replace(/%u/g, "\\u"));



function check(s){
    var str = '\u3918\uE826\u39CF\u39DF\u3A73\u39D0\uE82B\uE82C\u3B4E\u3C6E\u3CE0\u2EA7\uE831\uE832\u2EAA\u4056\u415F\u2EAE\u4337\u2EB3\u2EB6\u2EB7\uE83B\u43B1\u43AC\u2EBB\u43DD\u44D6\u4661\u464C\uE843\u4723\u4729\u477C\u478D\u2ECA\u4947\u497A\u497D\u4982\u4983\u4985\u4986\u499F\u499B\u49B7\u49B6\uE854\uE855\u4CA3\u4C9F\u4CA0\u4CA1\u4C77\u4CA2\u4D13\u4D14\u4D15\u4D16\u4D17\u4D18\u4D19\u4DAE';

    for(var i=0; i<s.length; i++){
        if(str.indexOf(s.charAt(i)) >= 0){
            alert('非法');
        }
    }
}

3.2 JS高级应用
3.2.1 JS实战
jj

4 JS新技术
4.1 Server-Sent Events
NCZonline的这篇文章介绍了这个概念，最早应该是在Opera9上实现的。这个概念术语HTML5的一个部分，其W3C文档：http://dev.w3.org/html5/eventsource/。
引用NCZonline的话，Server-Sent Event与WebSockets有两大区别，一是单向和双向的区别，二是传输协议上的区别，这个东东使用的是简单的HTTP协议，WEB服务器不用做手术就可以使用，MIME类型是text/event-stream。
基于安全考虑，这项技术仍然受同源策略的限制。


