var enRaw = '↑→W3C HTML 5.1 W3C Recommendation, 1 November 2016← 2 Common infrastructure — Table of contents — 4 The elements of HTML →Table of Contents 3Semantics, structure, and APIs of HTML documents 3.1Documents 3.1.1The Document object 3.1.2Resource metadata management 3.1.3DOM tree accessors 3.1.4Loading XML documents 3.2Elements 3.2.1Semantics 3.2.2Elements in the DOM 3.2.3Element definitions 3.2.3.1Attributes 3.2.4Content models 3.2.4.1The "nothing" content model 3.2.4.2Kinds of content 3.2.4.2.1Metadata content 3.2.4.2.2Flow content 3.2.4.2.3Sectioning content 3.2.4.2.4Heading content 3.2.4.2.5Phrasing content 3.2.4.2.6Embedded content 3.2.4.2.7Interactive content 3.2.4.2.8Palpable content 3.2.4.2.9Script-supporting elements 3.2.4.3Transparent content models 3.2.4.4Paragraphs 3.2.5Global attributes 3.2.5.1The id attribute 3.2.5.2The title attribute 3.2.5.3 The lang and xml:lang attributes 3.2.5.4The translate attribute 3.2.5.5The xml:base attribute (XML only) 3.2.5.6The dir attribute 3.2.5.7The class attribute 3.2.5.8The style attribute 3.2.5.9Embedding custom non-visible data with the data-* attributes 3.2.6 Requirements relating to the bidirectional algorithm 3.2.6.1 Authoring conformance criteria for bidirectional-algorithm formatting characters 3.2.6.2User agent conformance criteria 3.2.7WAI-ARIA and HTML Accessibility API Mappings 3.2.7.1ARIA Authoring Requirements 3.2.7.2Conformance Checker Implementation Requirements 3.2.7.3User Agent Implementation Requirements 3.2.7.3.1ARIA Role Attribute 3.2.7.3.2State and Property Attributes 3.2.7.4Allowed ARIA roles, states and properties 3. Semantics, structure, and APIs of HTML documents 3.1. Documents Every XML and HTML document in an HTML user agent is represented by a Document object. [DOM] The document’s address is the URL associated with a Document (as defined in the DOM standard). It is initially set when the Document is created, but that can change during the lifetime of the Document; for example, it changes when the user navigates to a fragment identifier on the page and when the pushState() method is called with a new URL. [DOM] Interactive user agents typically expose the document’s address in their user interface. This is the primary mechanism by which a user can tell if a site is attempting to impersonate another.  When a Document is created by a script using the createDocument() or createHTMLDocument() APIs, the document’s address is the same as the document’s address of the responsible document specified by the script’s settings object, and the Document is both ready for post-load tasks and completely loaded immediately.  The document’s referrer is an absolute URL that can be set when the Document is created. If it is not explicitly set, then its value is the empty string.  Each Document object has a reload override flag that is originally unset. The flag is set by the document.open() and document.write() methods in certain situations. When the flag is set, the Document also has a reload override buffer which is a Unicode string that is used as the source of the document when it is reloaded.  When the user agent is to perform an overridden reload, given a source browsing context, it must act as follows: Let source be the value of the browsing context’s active document’s reload override buffer.  Let address be the browsing context’s active document’s URL.  Let HTTPS state be the HTTPS state of the browsing context’s active document.  Let CSP list be the CSP list of the browsing context’s active document.  Navigate the browsing context to a new response whose body is source, CSP list is CSP list and HTTPS state is HTTPS state, with the exceptions enabled flag and replacement enabled. The source browsing context is that given to the overridden reload algorithm. When the navigate algorithm creates a Document object for this purpose, set that Document"s reload override flag and set its reload override buffer to source. Rethrow any exceptions.  When it comes time to set the document’s address in the navigation algorithm, use address as the override URL.  3.1.1. The Document object The DOM specification defines a Document interface, which this specification extends significantly: enum DocumentReadyState { "loading", "interactive", "complete" }; [OverrideBuiltins] partial /*sealed*/ interface Document { // resource metadata management [PutForwards=href, Unforgeable] readonly attribute Location? location; attribute DOMString domain; readonly attribute DOMString referrer; attribute DOMString cookie; readonly attribute DOMString lastModified; readonly attribute DocumentReadyState readyState; // DOM tree accessors getter object (DOMString name); attribute DOMString title; attribute DOMString dir; attribute HTMLElement? body; readonly attribute HTMLHeadElement? head; [SameObject] readonly attribute HTMLCollection images; [SameObject] readonly attribute HTMLCollection embeds; [SameObject] readonly attribute HTMLCollection plugins; [SameObject] readonly attribute HTMLCollection links; [SameObject] readonly attribute HTMLCollection forms; [SameObject] readonly attribute HTMLCollection scripts; NodeList getElementsByName(DOMString elementName); readonly attribute HTMLScriptElement? currentScript; // dynamic markup insertion Document open(optional DOMString type = "text/html", optional DOMString replace = ""); WindowProxy open(DOMString url, DOMString name, DOMString features, optional boolean replace = false); void close(); void write(DOMString... text); void writeln(DOMString... text); // user interaction readonly attribute WindowProxy? defaultView; readonly attribute Element? activeElement; boolean hasFocus(); attribute DOMString designMode; boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = ""); boolean queryCommandEnabled(DOMString commandId); boolean queryCommandIndeterm(DOMString commandId); boolean queryCommandState(DOMString commandId); boolean queryCommandSupported(DOMString commandId); DOMString queryCommandValue(DOMString commandId); // special event handler IDL attributes that only apply to Document objects [LenientThis] attribute EventHandler onreadystatechange; }; Document implements GlobalEventHandlers; Document implements DocumentAndElementEventHandlers; The Document has an HTTPS state (an HTTPS state value), initially "none", which represents the security properties of the network channel used to deliver the Document"s data.  The Document has a CSP list, which is a list of Content Security Policy objects active in this context. The list is empty unless otherwise specified.  3.1.2. Resource metadata management document . referrer Returns the address of the Document from which the user navigated to this one, unless it was blocked or there was no such document, in which case it returns the empty string.  The noreferrer link type can be used to block the referrer.  The referrer attribute must return the document’s referrer.  document . cookie [ = value ] Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can’t be applied to this resource, the empty string will be returned.  Can be set, to add a new cookie to the element’s set of HTTP cookies.  If the contents are sandboxed into a unique origin (e.g., in an iframe with the sandbox attribute), a "SecurityError" DOMException will be thrown on getting and setting.  The cookie attribute represents the cookies of the resource identified by the document’s address.  A Document object that falls into one of the following conditions is a cookie-averse Document object: A Document that has no browsing context.  A Document whose address does not use a server-based naming authority.  On getting, if the document is a cookie-averse Document object, then the user agent must return the empty string. Otherwise, if the Document"s origin is an opaque origin, the user agent must throw a "SecurityError" DOMException. Otherwise, the user agent must return the cookie-string for the document’s address for a "non-HTTP" API, decoded using UTF-8 decode without BOM. [COOKIES] (This is a fingerprinting vector.) On setting, if the document is a cookie-averse Document object, then the user agent must do nothing. Otherwise, if the Document"s origin is an opaque origin, the user agent must throw a "SecurityError" DOMException. Otherwise, the user agent must act as it would when receiving a set-cookie-string for the document’s address via a "non-HTTP" API, consisting of the new value encoded as UTF-8. [COOKIES] [ENCODING] Since the cookie attribute is accessible across frames, the path restrictions on cookies are only a tool to help manage which cookies are sent to which parts of the site, and are not in any way a security feature.  The cookie attribute’s getter and setter synchronously access shared state. Since there is no locking mechanism, other browsing contexts in a multiprocess user agent can modify cookies while scripts are running. A site could, for instance, try to read a cookie, increment its value, then write it back out, using the new value of the cookie as a unique identifier for the session; if the site does this twice in two different browser windows at the same time, it might end up using the same "unique" identifier for both sessions, with potentially disastrous effects.  document . lastModified Returns the date of the last modification to the document, as reported by the server, in the form "MM/DD/YYYY hh:mm:ss", in the user’s local time zone.  If the last modification date is not known, the current time is returned instead.  The lastModified attribute, on getting, must return the date and time of the Document"s source file’s last modification, in the user’s local time zone, in the following format: The month component of the date.  A U+002F SOLIDUS character (/).  The day component of the date.  A U+002F SOLIDUS character (/).  The year component of the date.  A U+0020 SPACE character.  The hours component of the time.  A U+003A COLON character (:).  The minutes component of the time.  A U+003A COLON character (:).  The seconds component of the time.  All the numeric components above, other than the year, must be given as two ASCII digits representing the number in base ten, zero-padded if necessary. The year must be given as the shortest possible string of four or more ASCII digits representing the number in base ten, zero-padded if necessary.  The Document"s source file’s last modification date and time must be derived from relevant features of the networking protocols used, e.g., from the value of the HTTP Last-Modified header of the document, or from metadata in the file system for local files. If the last modification date and time are not known, the attribute must return the current date and time in the above format.  document . readyState Returns "loading" while the Document is loading, "interactive" once it is finished parsing but still loading sub-resources, and "complete" once it has loaded.  The readystatechange event fires on the Document object when this value changes.  Each document has a current document readiness. When a Document object is created, it must have its current document readiness set to the string "loading" if the document is associated with an HTML parser, an XML parser, or an XSLT processor, and to the string "complete" otherwise. Various algorithms during page loading affect this value. When the value is set, the user agent must fire a simple event named readystatechange at the Document object.  A Document is said to have an active parser if it is associated with an HTML parser or an XML parser that has not yet been stopped or aborted.  The readyState IDL attribute must, on getting, return the current document readiness.  3.1.3. DOM tree accessors The html element of a document is the document’s root element, if there is one and it’s an html element, or null otherwise.  document . head Returns the head element.  The head element of a document is the first head element that is a child of the html element, if there is one, or null otherwise.  The head attribute, on getting, must return the head element of the document (a head element or null).  document . title [ = value ] Returns the document’s title, as given by the title element for HTML and as given by the SVG title element for SVG.  Can be set, to update the document’s title. If there is no appropriate element to update, the new value is ignored.  The title element of a document is the first title element in the document (in tree order), if there is one, or null otherwise.  The title attribute must, on getting, run the following algorithm: If the root element is an svg element in the SVG namespace, then let value be a concatenation of the data of all the child Text nodes of the first title element in the SVG namespace that is a child of the root element. [SVG11] Otherwise, let value be a concatenation of the data of all the child Text nodes of the title element, in tree order, or the empty string if the title element is null.  Strip and collapse whitespace in value.  Return value.  On setting, the steps corresponding to the first matching condition in the following list must be run: If the root element is an svg element in the SVG namespace [SVG11] Let element be the first title element in the SVG namespace that is a child of the root element, if any. If there isn’t one, create a title element in the SVG namespace, insert it as the first child of the root element, and let element be that element. [SVG11] Act as if the textContent IDL attribute of element was set to the new value being assigned.  If the root element is in the HTML namespace If the title element is null and the head element is null, then abort these steps.  If the title element is null, then create a new title element and append it to the head element, and let element be the newly created element; otherwise, let element be the title element.  Act as if the textContent IDL attribute of element was set to the new value being assigned.  Otherwise Do nothing.  document . body [ = value ] Returns the body element.  Can be set, to replace the body element.  If the new value is not a body or frameset element, this will throw a HierarchyRequestError exception.  The body element of a document is the first child of the html element that is either a body element or a frameset element. If there is no such element, it is null.  The body attribute, on getting, must return the body element of the document (either a body element, a frameset element, or null). On setting, the following algorithm must be run: If the new value is not a body or frameset element, then throw a HierarchyRequestError exception and abort these steps.  Otherwise, if the new value is the same as the body element, do nothing. Abort these steps.  Otherwise, if the body element is not null, then replace that element with the new value in the DOM, as if the root element’s replaceChild() method had been called with the new value and the incumbent body element as its two arguments respectively, then abort these steps.  Otherwise, if there is no root element, throw a HierarchyRequestError exception and abort these steps.  Otherwise, the body element is null, but there’s a root element. Append the new value to the root element.  document . images Returns an HTMLCollection of the img elements in the Document.  document . embeds document . plugins Return an HTMLCollection of the embed elements in the Document.  document . links Returns an HTMLCollection of the a and area elements in the Document that have href attributes.  document . forms Return an HTMLCollection of the form elements in the Document.  document . scripts Return an HTMLCollection of the script elements in the Document.  The images attribute must return an HTMLCollection rooted at the Document node, whose filter matches only img elements.  The embeds attribute must return an HTMLCollection rooted at the Document node, whose filter matches only embed elements.  The plugins attribute must return the same object as that returned by the embeds attribute.  The links attribute must return an HTMLCollection rooted at the Document node, whose filter matches only a elements with href attributes and area elements with href attributes.  The forms attribute must return an HTMLCollection rooted at the Document node, whose filter matches only form elements.  The scripts attribute must return an HTMLCollection rooted at the Document node, whose filter matches only script elements.  collection = document . getElementsByName(name) Returns a NodeList of elements in the Document that have a name attribute with the value name.  The getElementsByName(name) method takes a string name, and must return a live NodeList containing all the html elements in that document that have a name attribute whose value is equal to the name argument (in a case-sensitive manner), in tree order. When the method is invoked on a Document object again with the same argument, the user agent may return the same as the object returned by the earlier call. In other cases, a new NodeList object must be returned.  document . currentScript Returns the script element that is currently executing. In the case of reentrant script execution, returns the one that most recently started executing amongst those that have not yet finished executing.  Returns null if the Document is not currently executing a script element (e.g., because the running script is an event handler, or a timeout).  The currentScript attribute, on getting, must return the value to which it was most recently initialized. When the Document is created, the currentScript must be initialized to null.  The Document interface supports named properties. The supported property names at any moment consist of the values of the name content attributes of all the applet, exposed embed, form, iframe, img, and exposed object elements in the Document that have non-empty name content attributes, and the values of the id content attributes of all the applet and exposed object elements in the Document that have non-empty id content attributes, and the values of the id content attributes of all the img elements in the Document that have both non-empty name content attributes and non-empty id content attributes. The supported property names must be in tree order, ignoring later duplicates, with values from id attributes coming before values from name attributes when the same element contributes both.  To determine the value of a named property name when the Document object is indexed for property retrieval, the user agent must return the value obtained using the following steps: Let elements be the list of named elements with the name name in the Document.  There will be at least one such element, by definition.  If elements has only one element, and that element is an iframe element, then return the WindowProxy object of the nested browsing context represented by that iframe element, and abort these steps.  Otherwise, if elements has only one element, return that element and abort these steps.  Otherwise return an HTMLCollection rooted at the Document node, whose filter matches only named elements with the name name.  Named elements with the name name, for the purposes of the above algorithm, are those that are either: applet, exposed embed, form, iframe, img, or exposed object elements that have a name content attribute whose value is name, or applet or exposed object elements that have an id content attribute whose value is name, or img elements that have an id content attribute whose value is name, and that have a non-empty name content attribute present also.  An embed or object element is said to be exposed if it has no exposed object ancestor, and, for object elements, is additionally either not showing its fallback content or has no object or embed descendants.  The dir attribute on the Document interface is defined along with the dir content attribute.  3.1.4. Loading XML documents partial interface XMLDocument { boolean load(DOMString url); }; The load(url) method must run the following steps: Let document be the XMLDocument object on which the method was invoked.  Parse url, relative to the entry settings object. If this is not successful, throw a "SyntaxError" DOMException and abort these steps. Otherwise, let urlRecord be the resulting URL record.  If urlRecord’s origin is not the same as the origin of document, throw a "SecurityError" DOMException and abort these steps.  Remove all child nodes of document, without firing any mutation events.  Set the current document readiness of document to "loading".  Run the remainder of these steps in parallel, and return true from the method.  Let result be a Document object.  Let success be false.  Let request be a new request whose URL is urlRecord, client is entry settings object, destination is "subresource", synchronous flag is set, mode is "same-origin", credentials mode is "same-origin", and whose use-URL-credentials flag is set.  Let response be the result of fetching request.  If response’s Content-Type metadata is an XML MIME type, then run these substeps: Create a new XML parser associated with the result document.  Pass this parser response’s body.  If there is an XML well-formedness or XML namespace well-formedness error, then remove all child nodes from result. Otherwise let success be true.  Queue a task to run the following steps.  Set the current document readiness of document to "complete".  Replace all the children of document by the children of result (even if it has no children), firing mutation events as if a DocumentFragment containing the new children had been inserted.  Fire a simple event named load at document.  3.2. Elements 3.2.1. Semantics Elements, attributes, and attribute values in HTML are defined (by this specification) to have certain meanings (semantics). For example, the ol element represents an ordered list, and the lang attribute represents the language of the content.  These definitions allow HTML processors, like web browsers and search engines, to present documents and applications consistently in different contexts.  In this example the HTML headings may be presented as large text in a desktop browser, or standard size text in bold in a mobile browser. In both cases the semantic information remains the same - that the h1 and h2 elements represent headings.  <!doctype html> <html lang="en"> <head> <title>Favorite books</title> </head> <body> <header> <img src="logo.png" alt="Favorite books logo"> </header> <main> <h1>Favorite books</h1> <p>These are a few of my favorite books.</p> <h2>The Belgariad</h2> <p>Five books by David and Leigh Eddings.</p> <h2>The Hitchhiker’s Guide to the Galaxy</h2> <p>A trilogy of five books by Douglas Adams.</p> </main> </body> </html> This semantic information is critical to assistive technologies. For example, a screen reader will query the browser for semantic information and use that information to present the document or application in synthetic speech.  In some cases assistive technologies use semantic information to provide additional functionality. A speech recognition tool might provide a voice command for moving focus to the start of the main element for example.  When the appropriate HTML element or attribute is not used, it deprives HTML processors of valuable semantic information.  In this example styling may be used to create a visual representation of headings and other components, but because the appropriate HTML elements have not been used there is little semantic information available to web browsers, search engines and assistive technologies.  <!doctype html> <html lang="en"> <head> <title>Favorite books</title> </head> <body> <div class="header"> <img src="logo.png" alt="Favorite books logo"> </div> <div class="main"> <span class="largeHeading">Favorite books</span> <p>These are a few of my favorite books.</p> <span class="smallHeading">The Belgariad</span> <p>Five books by David and Leigh Eddings.</p> <span class="smallHeading">The Hitchhiker’s Guide to the Galaxy</span> <p>A trilogy of five books by Douglas Adams.</p> </div> </body> </html> A document can change dynamically while it is being processed. Scripting and other mechanisms can be used to change attribute values, text, or the entire document structure. The semantics of a document are therefore based on the document’s state at a particular instance in time, but may also change in response to external events. User agents must update their presentation of the document to reflect these changes.  In this example the audio element is used to play a music track. The controls attribute is used to show the user agent player, and as the music plays the controls are updated to indicate progress. The available semantic information is updated in response to these changes.  <audio src="comfortablynumb.mp3" controls> 3.2.2. Elements in the DOM The nodes representing html elements in the DOM must implement, and expose to scripts, the interfaces listed for them in the relevant sections of this specification. This includes html elements in XML documents, even when those documents are in another context (e.g., inside an XSLT transform).  Elements in the DOM represent things; that is, they have intrinsic meaning, also known as semantics.  For example, an ol element represents an ordered list.  The basic interface, from which all the html elements" interfaces inherit, and which must be used by elements that have no additional requirements, is the HTMLElement interface.  interface HTMLElement : Element { // metadata attributes attribute DOMString title; attribute DOMString lang; attribute boolean translate; attribute DOMString dir; [SameObject] readonly attribute DOMStringMap dataset; // user interaction attribute boolean hidden; void click(); attribute long tabIndex; void focus(); void blur(); attribute DOMString accessKey; attribute boolean draggable; [PutForwards=value] readonly attribute DOMTokenList dropzone; attribute HTMLMenuElement? contextMenu; attribute boolean spellcheck; void forceSpellCheck(); }; HTMLElement implements GlobalEventHandlers; HTMLElement implements DocumentAndElementEventHandlers; HTMLElement implements ElementContentEditable; interface HTMLUnknownElement : HTMLElement { }; The HTMLElement interface holds methods and attributes related to a number of disparate features, and the members of this interface are therefore described in various different sections of this specification.  The HTMLUnknownElement interface must be used for html elements that are not defined by this specification (or other applicable specifications).  3.2.3. Element definitions Each element in this specification has a definition that includes the following information: Categories A list of categories to which the element belongs. These are used when defining the content models for each element.  Contexts in which this element can be used A non-normative description of where the element can be used. This information is redundant with the content models of elements that allow this one as a child, and is provided only as a convenience.  For simplicity, only the most specific expectations are listed. For example, an element that is both flow content and phrasing content can be used anywhere that either flow content or phrasing content is expected, but since anywhere that flow content is expected, phrasing content is also expected (since all phrasing content is flow content), only "where phrasing content is expected" will be listed.  Content model A normative description of what content must be included as children and descendants of the element.  Tag omission in text/html A non-normative description of whether, in the text/html syntax, the start and end tags can be omitted. This information is redundant with the normative requirements given in the optional tags section, and is provided in the element definitions only as a convenience.  Content attributes A normative list of attributes that may be specified on the element (except where otherwise disallowed), along with non-normative descriptions of those attributes. (The content to the left of the dash is normative, the content to the right of the dash is not.) Allowed ARIA role attribute values A normative list of ARIA role attribute values that may be specified on the element (except where otherwise disallowed). Each value is linked to a non normative description.  Allowed ARIA state and property attributes Links to the Global aria-* attributes list and the allowed roles, states and properties table.  DOM interface A normative definition of a DOM interface that such elements must implement.  This is then followed by a description of what the element represents, along with any additional normative conformance criteria that may apply to authors and implementations. Examples are sometimes also included.  3.2.3.1. Attributes Except where otherwise specified, attributes on html elements may have any string value, including the empty string. Except where explicitly stated, there is no restriction on what text can be specified in such attributes.  3.2.4. Content models Each element defined in this specification has a content model: a description of the element’s expected contents. An HTML element must have contents that match the requirements described in the element’s content model. The contents of an element are its children in the DOM, except for template elements, where the children are those in the template contents (a separate DocumentFragment assigned to the element when the element is created).  The space characters are always allowed between elements. User agents represent these characters between elements in the source markup as Text nodes in the DOM. Empty Text nodes and Text nodes consisting of just sequences of those characters are considered inter-element whitespace.  Inter-element whitespace, comment nodes, and processing instruction nodes must be ignored when establishing whether an element’s contents match the element’s content model or not, and must be ignored when following algorithms that define document and element semantics.  Thus, an element A is said to be preceded or followed by a second element B if A and B have the same parent node and there are no other element nodes or Text nodes (other than inter-element whitespace) between them. Similarly, a node is the only child of an element if that element contains no other nodes other than inter-element whitespace, comment nodes, and processing instruction nodes.  Authors must not use html elements anywhere except where they are explicitly allowed, as defined for each element, or as explicitly required by other specifications. For XML compound documents, these contexts could be inside elements from other namespaces, if those elements are defined as providing the relevant contexts.  For example, the Atom specification defines a content element. When its type attribute has the value xhtml, the Atom specification requires that it contain a single HTML div element. Thus, a div element is allowed in that context, even though this is not explicitly normatively stated by this specification. [RFC4287] In addition, html elements may be orphan nodes (i.e., without a parent node).  For example, creating a td element and storing it in a global variable in a script is conforming, even though td elements are otherwise only supposed to be used inside tr elements.  var data = { name: "Banana", cell: document.createElement("td"), }; 3.2.4.1. The "nothing" content model When an element’s content model is nothing, the element must contain no Text nodes (other than inter-element whitespace) and no element nodes.  Most HTML elements whose content model is "nothing" are also, for convenience, void elements (elements that have no end tag in the HTML syntax). However, these are entirely separate concepts.  3.2.4.2. Kinds of content Each element in HTML falls into zero or more categories that group elements with similar characteristics together. The following broad categories are used in this specification: §3.2.4.2.1 metadata content §3.2.4.2.2 flow content §3.2.4.2.3 sectioning content §3.2.4.2.4 heading content §3.2.4.2.5 phrasing content §3.2.4.2.6 embedded content §3.2.4.2.7 interactive content Some elements also fall into other categories, which are defined in other parts of this specification.  These categories are related as follows: Sectioning content, heading content, phrasing content, embedded content, and interactive content are all types of flow content. Metadata is sometimes flow content. Metadata and interactive content are sometimes phrasing content. Embedded content is also a type of phrasing content, and sometimes is interactive content.  Other categories are also used for specific purposes, e.g., form controls are specified using a number of categories to define common requirements. Some elements have unique requirements and do not fit into any particular category.  3.2.4.2.1. Metadata content Metadata content is content that sets up the presentation or behavior of the rest of the content, or that sets up the relationship of the document with other documents, or that conveys other "out of band" information.  base link meta noscript script style template title 3.2.4.2.2. Flow content Most elements that are used in the body of documents and applications are categorized as flow content.  a abbr address area (if it is a descendant of a map element) article aside audio b bdi bdo blockquote br button canvas cite code data datalist del details dfn div dl em embed fieldset figure footer form h1 h2 h3 h4 h5 h6 header hr i iframe img input ins kbd keygen label main map mark math menu meter nav noscript object ol output p picture pre progress q ruby s samp script section select small span strong sub sup svg table template textarea time u ul var video wbr text 3.2.4.2.3. Sectioning content Sectioning content is content that defines the scope of headings and footers.  article aside nav section Each sectioning content element potentially has a heading and an outline. See the section on §4.3.10 Headings and sections for further details.  There are also certain elements that are sectioning roots. These are distinct from sectioning content, but they can also have an outline.  3.2.4.2.4. Heading content Heading content defines the header of a section (whether explicitly marked up using sectioning content elements, or implied by the heading content itself).  h1 h2 h3 h4 h5 h6 3.2.4.2.5. Phrasing content Phrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs.  a abbr area (if it is a descendant of a map element) audio b bdi bdo br button canvas cite code data datalist del dfn em embed i iframe img input ins kbd keygen label map mark math meter noscript object output picture progress q ruby s samp script select small span strong sub sup svg template textarea time u var video wbr text Most elements that are categorized as phrasing content can only contain elements that are themselves categorized as phrasing content, not any flow content.  Text, in the context of content models, means either nothing, or Text nodes. Text is sometimes used as a content model on its own, but is also phrasing content, and can be inter-element whitespace (if the Text nodes are empty or contain just space characters).  Text nodes and attribute values must consist of Unicode characters, must not contain U+0000 characters, must not contain permanently undefined Unicode characters (noncharacters), and must not contain control characters other than space characters.  This specification includes extra constraints on the exact value of Text nodes and attribute values depending on their precise context.  For elements in HTML, the constraints of the Text content model also depends on the kind of element. For instance, an "<" inside a textarea element does not need to be escaped in HTML because textarea is an escapable raw text element. (This does not apply to XHTML. In XHTML, the kind of element doesn’t affect the constraints of content model: Text.) 3.2.4.2.6. Embedded content Embedded content is content that imports another resource into the document, or content from another vocabulary that is inserted into the document.  audio canvas embed iframe img math object picture svg video Elements that are from namespaces other than the HTML namespace and that convey content but not metadata, are embedded content for the purposes of the content models defined in this specification. (For example, MathML, or SVG.) Some embedded content elements can have fallback content: content that is to be used when the external resource cannot be used (e.g., because it is of an unsupported format). The element definitions state what the fallback is, if any.  3.2.4.2.7. Interactive content Interactive content is content that is specifically intended for user interaction.  a (if the href attribute is present) audio (if the controls attribute is present) button details embed iframe img (if the usemap attribute is present) input (if the type attribute is not in the hidden state) keygen label select textarea video (if the controls attribute is present) The tabindex attribute can also make any element into interactive content.  3.2.4.2.8. Palpable content As a general rule, elements whose content model allows any flow content or phrasing content should have at least one node in its contents that is palpable content and that does not have the hidden attribute specified.  Palpable content makes an element non-empty by providing either some descendant non-empty text, or else something users can hear (audio elements) or view (video or img or canvas elements) or otherwise interact with (for example, interactive form controls).  This requirement is not a hard requirement, however, as there are many cases where an element can be empty legitimately, for example when it is used as a placeholder which will later be filled in by a script, or when the element is part of a template and would on most pages be filled in but on some pages is not relevant.  Conformance checkers are encouraged to provide a mechanism for authors to find elements that fail to fulfill this requirement, as an authoring aid.  The following elements are palpable content: a abbr address article aside audio (if the controls attribute is present) b bdi bdo blockquote button canvas cite code data details dfn div dl (if the element’s children include at least one name-value group) em embed fieldset figure footer form h1 h2 h3 h4 h5 h6 header i iframe img input (if the type attribute is not in the hidden state) ins kbd keygen label main map mark math meter nav object ol (if the element’s children include at least one li element) output p pre progress q ruby s samp section select small span strong sub sup svg table textarea time u ul (if the element’s children include at least one li element) var video text that is not inter-element whitespace 3.2.4.2.9. Script-supporting elements Script-supporting elements are those that do not represent anything themselves (i.e., they are not rendered), but are used to support scripts, e.g., to provide functionality for the user.  The following elements are script-supporting elements: script template 3.2.4.3. Transparent content models Some elements are described as transparent; they have "transparent" in the description of their content model. The content model of a transparent element is derived from the content model of its parent element: the elements required in the part of the content model that is "transparent" are the same elements as required in the part of the content model of the parent of the transparent element in which the transparent element finds itself.  For instance, an ins element inside a ruby element cannot contain an rt element, because the part of the ruby element’s content model that allows ins elements is the part that allows phrasing content, and the rt element is not phrasing content.  In some cases, where transparent elements are nested in each other, the process has to be applied iteratively.  Consider the following markup fragment: <p><object><param><ins><map><a href="/">Apples</a></map></ins></object></p> To check whether "Apples" is allowed inside the a element, the content models are examined. The a element’s content model is transparent, as is the map element’s, as is the ins element’s, as is the part of the object element’s in which the ins element is found. The object element is found in the p element, whose content model is phrasing content. Thus, "Apples" is allowed, as text is phrasing content.  When a transparent element has no parent, then the part of its content model that is "transparent" must instead be treated as accepting any flow content.  3.2.4.4. Paragraphs The term paragraph as defined in this section is used for more than just the definition of the p element. The paragraph concept defined here is used to describe how to interpret documents. The p element is merely one of several ways of marking up a paragraph.  A paragraph is typically a run of phrasing content that forms a block of text with one or more sentences that discuss a particular topic, as in typography, but can also be used for more general thematic grouping. For instance, an address is also a paragraph, as is a part of a form, a byline, or a stanza in a poem.  In the following example, there are two paragraphs in a section. There is also a heading, which contains phrasing content that is not a paragraph. Note how the comments and inter-element whitespace do not form paragraphs.  <section> <h2>Example of paragraphs</h2> This is the <em>first</em> paragraph in this example.  <p>This is the second.</p> <!-- This is not a paragraph. --> </section> Paragraphs in flow content are defined relative to what the document looks like without the a, ins, del, and map elements complicating matters, since those elements, with their hybrid content models, can straddle paragraph boundaries, as shown in the first two examples below.  Generally, having elements straddle paragraph boundaries is best avoided. Maintaining such markup can be difficult.  The following example takes the markup from the earlier example and puts ins and del elements around some of the markup to show that the text was changed (though in this case, the changes admittedly don’t make much sense). Notice how this example has exactly the same paragraphs as the previous one, despite the ins and del elements — the ins element straddles the heading and the first paragraph, and the del element straddles the boundary between the two paragraphs.  <section> <ins><h1>Example of paragraphs</h1> This is the <em>first</em> paragraph in</ins> this example<del>.  <p>This is the second.</p></del> <!-- This is not a paragraph. --> </section> Let view be a view of the DOM that replaces all a, ins, del, and map elements in the document with their contents. Then, in view, for each run of sibling phrasing content nodes uninterrupted by other types of content, in an element that accepts content other than phrasing content as well as phrasing content, let first be the first node of the run, and let last be the last node of the run. For each such run that consists of at least one node that is neither embedded content nor inter-element whitespace, a paragraph exists in the original DOM from immediately before first to immediately after last. (Paragraphs can thus span across a, ins, del, and map elements.) Conformance checkers may warn authors of cases where they have paragraphs that overlap each other (this can happen with object, video, audio, and canvas elements, and indirectly through elements in other namespaces that allow HTML to be further embedded therein, like svg or math).  A paragraph is also formed explicitly by p elements.  The p element can be used to wrap individual paragraphs when there would otherwise not be any content other than phrasing content to separate the paragraphs from each other.  In the following example, the link spans half of the first paragraph, all of the heading separating the two paragraphs, and half of the second paragraph. It straddles the paragraphs and the heading.  <header> Welcome!  <a href="about.html"> This is home of...  <h1>The Falcons!</h1> The Lockheed Martin multirole jet fighter aircraft!  </a> This page discusses the F-16 Fighting Falcon’s innermost secrets.  </header> Here is another way of marking this up, this time showing the paragraphs explicitly, and splitting the one link element into three: <header> <p>Welcome! <a href="about.html">This is home of...</a></p> <h1><a href="about.html">The Falcons!</a></h1> <p><a href="about.html">The Lockheed Martin multirole jet fighter aircraft!</a> This page discusses the F-16 Fighting Falcon’s innermost secrets.</p> </header> It is possible for paragraphs to overlap when using certain elements that define fallback content. For example, in the following section: <section> <h2>My Cats</h2> You can play with my cat simulator.  <object data="cats.sim"> To see the cat simulator, use one of the following links: <ul> <li><a href="cats.sim">Download simulator file</a> <li><a href="https://sims.example.com/watch?v=LYds5xY4INU">Use online simulator</a> </ul> Alternatively, upgrade to the Mellblom Browser.  </object> I’m quite proud of it.  </section> There are five paragraphs: The paragraph that says "You can play with my cat simulator. object I’m quite proud of it.", where object is the object element.  The paragraph that says "To see the cat simulator, use one of the following links:".  The paragraph that says "Download simulator file".  The paragraph that says "Use online simulator".  The paragraph that says "Alternatively, upgrade to the Mellblom Browser.".  The first paragraph is overlapped by the other four. A user agent that supports the "cats.sim" resource will only show the first one, but a user agent that shows the fallback will confusingly show the first sentence of the first paragraph as if it was in the same paragraph as the second one, and will show the last paragraph as if it was at the start of the second sentence of the first paragraph.  To avoid this confusion, explicit p elements can be used. For example: <section> <h2>My Cats</h2> <p>You can play with my cat simulator.</p> <object data="cats.sim"> <p>To see the cat simulator, use one of the following links:</p> <ul> <li><a href="cats.sim">Download simulator file</a> <li><a href="https://sims.example.com/watch?v=LYds5xY4INU">Use online simulator</a> </ul> <p>Alternatively, upgrade to the Mellblom Browser.</p> </object> <p>I’m quite proud of it.</p> </section> 3.2.5. Global attributes The following attributes are common to and may be specified on all html elements (even those not defined in this specification): accesskey class contenteditable contextmenu dir draggable dropzone hidden id lang spellcheck style tabindex title translate These attributes are only defined by this specification as attributes for HTML elements. When this specification refers to elements having these attributes, elements from namespaces that are not defined as having these attributes must not be considered as being elements with these attributes.  For example, in the following XML fragment, the "bogus" element does not have a dir attribute as defined in this specification, despite having an attribute with the literal name "dir". Thus, the directionality of the inner-most span element is "rtl", inherited from the div element indirectly through the "bogus" element.  <div xmlns="https://www.w3.org/1999/xhtml" dir="rtl"> <bogus xmlns="https://example.net/ns" dir="ltr"> <span xmlns="https://www.w3.org/1999/xhtml"> </span> </bogus> </div> To enable assistive technology products to expose a more fine-grained interface than is otherwise possible with HTML elements and attributes, a set of annotations for assistive technology products can be specified (the ARIA role and aria-* attributes). [WAI-ARIA] The following event handler content attributes may be specified on any HTML element: onabort onblur* oncancel oncanplay oncanplaythrough onchange onclick onclose oncontextmenu oncopy oncuechange oncut ondblclick ondrag ondragend ondragenter ondragexit ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended onerror* onfocus* oninput oninvalid onkeydown onkeypress onkeyup onload* onloadeddata onloadedmetadata onloadstart onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup onwheel onpaste onpause onplay onplaying onprogress onratechange onreset onresize* onscroll* onseeked onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate ontoggle onvolumechange onwaiting The attributes marked with an asterisk have a different meaning when specified on body elements as those elements expose event handlers of the Window object with the same names.  While these attributes apply to all elements, they are not useful on all elements. For example, only media elements will ever receive a volumechange event fired by the user agent.  Custom data attributes (e.g., data-foldername or data-msgid) can be specified on any HTML element, to store custom data specific to the page.  In HTML documents, elements in the HTML namespace may have an xmlns attribute specified, if, and only if, it has the exact value "https://www.w3.org/1999/xhtml". This does not apply to XML documents.  In HTML, the xmlns attribute has absolutely no effect. It is basically a talisman. It is allowed merely to make migration to and from XHTML mildly easier. When parsed by an HTML parser, the attribute ends up in no namespace, not the "https://www.w3.org/2000/xmlns/" namespace like namespace declaration attributes in XML do.  In XML, an xmlns attribute is part of the namespace declaration mechanism, and an element cannot actually have an xmlns attribute in no namespace specified.  The XML specification also allows the use of the xml:space attribute in the XML namespace on any element in an XML document. This attribute has no effect on html elements, as the default behavior in HTML is to preserve whitespace. [XML] There is no way to serialize the xml:space attribute on html elements in the text/html syntax.  3.2.5.1. The id attribute The id attribute specifies its element’s unique identifier (ID). [DOM] The value must be unique amongst all the IDs in the element’s home subtree and must contain at least one character. The value must not contain any space characters.  There are no other restrictions on what form an ID can take; in particular, IDs can consist of just digits, start with a digit, start with an underscore, consist of just punctuation, etc.  An element’s unique identifier can be used for a variety of purposes, most notably as a way to link to specific parts of a document using fragment identifiers, as a way to target an element when scripting, and as a way to style a specific element from CSS.  Identifiers are opaque strings. Particular meanings should not be derived from the value of the id attribute.  3.2.5.2. The title attribute The title attribute represents advisory information for the element, such as would be appropriate for a tooltip. On a link, this could be the title or a description of the target resource; on an image, it could be the image credit or a description of the image; on a paragraph, it could be a footnote or commentary on the text; on a citation, it could be further information about the source; on interactive content, it could be a label for, or instructions for, use of the element; and so forth. The value is text.  Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by this specification (e.g., requiring a pointing device such as a mouse to cause a tooltip to appear, which excludes keyboard-only users and touch-only users, such as anyone with a modern phone or tablet).  If this attribute is omitted from an element, then it implies that the title attribute of the nearest ancestor HTML element with a title attribute set is also relevant to this element. Setting the attribute overrides this, explicitly stating that the advisory information of any ancestors is not relevant to this element. Setting the attribute to the empty string indicates that the element has no advisory information.  If the title attribute’s value contains U+000A LINE FEED (LF) characters, the content is split into multiple lines. Each U+000A LINE FEED (LF) character represents a line break.  Caution is advised with respect to the use of newlines in title attributes.  For instance, the following snippet actually defines an abbreviation’s expansion with a line break in it: <p>My logs show that there was some interest in <abbr title="Hypertext Transport Protocol">HTTP</abbr> today.</p> Some elements, such as link, abbr, and input, define additional semantics for the title attribute beyond the semantics described above.  The advisory information of an element is the value that the following algorithm returns, with the algorithm being aborted once a value is returned. When the algorithm returns the empty string, then there is no advisory information.  If the element is a link, style, dfn, abbr, or menuitem element, then: if the element has a title attribute, return the value of that attribute, otherwise, return the empty string.  Otherwise, if the element has a title attribute, then return its value.  Otherwise, if the element has a parent element, then return the parent element’s advisory information.  Otherwise, return the empty string.  User agents should inform the user when elements have advisory information, otherwise the information would not be discoverable.  The title IDL attribute must reflect the title content attribute.  3.2.5.3. The lang and xml:lang attributes The lang attribute (in no namespace) specifies the primary language for the element’s contents and for any of the element’s attributes that contain text. Its value must be a valid BCP 47 language tag, or the empty string. Setting the attribute to the empty string indicates that the primary language is unknown. [BCP47] The lang attribute in the XML namespace is defined in XML. [XML] If these attributes are omitted from an element, then the language of this element is the same as the language of its parent element, if any.  The lang attribute in no namespace may be used on any HTML element.  The lang attribute in the XML namespace may be used on html elements in XML documents, as well as elements in other namespaces if the relevant specifications allow it (in particular, MathML and SVG allow lang attributes in the XML namespace to be specified on their elements). If both the lang attribute in no namespace and the lang attribute in the XML namespace are specified on the same element, they must have exactly the same value when compared in an ASCII case-insensitive manner.  Authors must not use the lang attribute in the XML namespace on html elements in HTML documents. To ease migration to and from XHTML, authors may specify an attribute in no namespace with no prefix and with the literal localname "xml:lang" on html elements in HTML documents, but such attributes must only be specified if a lang attribute in no namespace is also specified, and both attributes must have the same value when compared in an ASCII case-insensitive manner.  The attribute in no namespace with no prefix and with the literal localname "xml:lang" has no effect on language processing.  The language of HTML documents is indicated using a lang attribute (on the HTML element itself, to indicate the primary language of the document, and on individual elements, to indicate a change in language). It provides an explicit indication to user agents about the language of content, so an appropriate language dictionary can be used and, in the case of screen readers and similar assistive technologies with voice output, the content is pronounced using the correct voice / language library (where available). Setting of a language using the lang attribute which does not match the language of the document or document parts will result in some users being unable to understand the content.  To determine the language of a node, user agents must look at the nearest ancestor element (including the element itself if the node is an element) that has a lang attribute in the XML namespace set or is an HTML element and has a lang in no namespace attribute set. That attribute specifies the language of the node (regardless of its value).  If both the lang attribute in no namespace and the lang attribute in the XML namespace are set on an element, user agents must use the lang attribute in the XML namespace, and the lang attribute in no namespace must be ignored for the purposes of determining the element’s language.  If neither the node nor any of the node’s ancestors, including the root element, have either attribute set, but there is a pragma-set default language set, then that is the language of the node. If there is no pragma-set default language set, then language information from a higher-level protocol (such as HTTP), if any, must be used as the final fallback language instead. In the absence of any such language information, and in cases where the higher-level protocol reports multiple languages, the language of the node is unknown, and the corresponding language tag is the empty string.  For example, if a document is delivered over HTTP and the Content-Language HTTP header is specified with a value "en" (and there is no pragma-set default language), then for any element in the document that does not itself have a lang attribute nor any ancestor of that element, the fallback language for the element will be English. If the value of the Content-Language header was "de, fr, it" then the language of the node is unknown. This article provides some additional guidance on the use of HTTP headers, and meta elements for providing language information.  If the resulting value is not a recognized language tag, then it must be treated as an unknown language having the given language tag, distinct from all other languages. For the purposes of round-tripping or communicating with other services that expect language tags, user agents should pass unknown language tags through unmodified, and tagged as being BCP 47 language tags, so that subsequent services do not interpret the data as another type of language description. [BCP47] Thus, for instance, an element with lang="xyzzy" would be matched by the selector :lang(xyzzy) (e.g., in CSS), but it would not be matched by :lang(abcde), even though both are equally invalid. Similarly, if a Web browser and screen reader working in unison communicated about the language of the element, the browser would tell the screen reader that the language was "xyzzy", even if it knew it was invalid, just in case the screen reader actually supported a language with that tag after all. Even if the screen reader supported both BCP 47 and another syntax for encoding language names, and in that other syntax the string "xyzzy" was a way to denote the Belarusian language, it would be incorrect for the screen reader to then start treating text as Belarusian, because "xyzzy" is not how Belarusian is described in BCP 47 codes (BCP 47 uses the code "be" for Belarusian).  If the resulting value is the empty string, then it must be interpreted as meaning that the language of the node is explicitly unknown.  User agents may use the element’s language to determine proper processing or rendering (e.g., in the selection of appropriate fonts or pronunciations, for dictionary selection, or for the user interfaces of form controls such as date pickers).  The lang IDL attribute must reflect the lang content attribute in no namespace.  3.2.5.4. The translate attribute The translate attribute is an enumerated attribute that is used to specify whether an element’s attribute values and the values of its Text node children are to be translated when the page is localized, or whether to leave them unchanged.  The attribute’s keywords are the empty string, yes, and no. The empty string and the yes keyword map to the yes state. The no keyword maps to the no state. In addition, there is a third state, the inherit state, which is the missing value default (and the invalid value default).  Each element (even non-HTML elements) has a translation mode, which is in either the translate-enabled state or the no-translate state. If an HTML element’s translate attribute is in the yes state, then the element’s translation mode is in the translate-enabled state; otherwise, if the element’s translate attribute is in the no state, then the element’s translation mode is in the no-translate state. Otherwise, either the element’s translate attribute is in the inherit state, or the element is not an HTML element and thus does not have a translate attribute; in either case, the element’s translation mode is in the same state as its parent element’s, if any, or in the translate-enabled state, if the element is a root element.  When an element is in the translate-enabled state, the element’s translatable attributes and the values of its Text node children are to be translated when the page is localized.  When an element is in the no-translate state, the element’s attribute values and the values of its Text node children are to be left as-is when the page is localized, e.g., because the element contains a person’s name or a name of a computer program.  The following attributes are translatable attributes: abbr on th elements alt on area, img, and input elements content on meta elements, if the name attribute specifies a metadata name whose value is known to be translatable download on a and area elements label on menuitem, menu, optgroup, option, and track elements lang on html elements; must be "translated" to match the language used in the translation placeholder on input and textarea elements srcdoc on iframe elements; must be parsed and recursively processed style on html elements; must be parsed and recursively processed (e.g., for the values of "content" properties) title on all html elements value on input elements with a type attribute in the Button, submit button, or reset button state The translate IDL attribute must, on getting, return true if the element’s translation mode is translate-enabled, and false otherwise. On setting, it must set the content attribute’s value to "yes" if the new value is true, and set the content attribute’s value to "no" otherwise.  In this example, everything in the document is to be translated when the page is localized, except the sample keyboard input and sample program output: <!DOCTYPE HTML> <html> <!-- default on the root element is translate=yes --> <head> <title>The Bee Game</title> <!-- implied translate=yes inherited from ancestors --> </head> <body> <p>The Bee Game is a text adventure game in English.</p> <p>When the game launches, the first thing you should do is type <kbd translate=no>eat honey</kbd>. The game will respond with:</p> <pre><samp translate=no>Yum yum! That was some good honey!</samp></pre> </body> </html> 3.2.5.5. The xml:base attribute (XML only) The xml:base attribute is defined in XML Base. [XMLBASE] The xml:base attribute may be used on html elements of XML documents. Authors must not use the xml:base attribute on html elements in HTML documents.  3.2.5.6. The dir attribute The dir attribute specifies the element’s text directionality. The attribute is an enumerated attribute with the following keywords and states: The ltr keyword, which maps to the ltr state Indicates that the contents of the element are explicitly directionally isolated left-to-right text.  The rtl keyword, which maps to the rtl state Indicates that the contents of the element are explicitly directionally isolated right-to-left text.  The auto keyword, which maps to the auto state Indicates that the contents of the element are explicitly directionally isolated text, but that the direction is to be determined programmatically using the contents of the element (as described below).  The heuristic used by this state is very crude (it just looks at the first character with a strong directionality, in a manner analogous to the Paragraph Level determination in the bidirectional algorithm). Authors are urged to only use this value as a last resort when the direction of the text is truly unknown and no better server-side heuristic can be applied. [BIDI] For textarea and pre elements, the heuristic is applied on a per-paragraph level.  The attribute has no invalid value default and no missing value default.  The directionality of an element (any element, not just an HTML element) is either "ltr" or "rtl", and is determined as per the first appropriate set of steps from the following list: If the element’s dir attribute is in the ltr state If the element is a root element and the dir attribute is not in a defined state (i.e., it is not present or has an invalid value) If the element is an input element whose type attribute is in the Telephone state, and the dir attribute is not in a defined state (i.e., it is not present or has an invalid value) The directionality of the element is "ltr".  If the element’s dir attribute is in the rtl state The directionality of the element is "rtl".  If the element is an input element whose type attribute is in the Text, Search, Telephone, URL, or E-mail state, and the dir attribute is in the auto state If the element is a textarea element and the dir attribute is in the auto state If the element’s value contains a character of bidirectional character type AL or R, and there is no character of bidirectional character type L anywhere before it in the element’s value, then the directionality of the element is "rtl". [BIDI] Otherwise, if the element’s value is not the empty string, or if the element is a root element, the directionality of the element is "ltr".  Otherwise, the directionality of the element is the same as the element’s parent element’s directionality.  If the element’s dir attribute is in the auto state If the element is a bdi element and the dir attribute is not in a defined state (i.e., it is not present or has an invalid value) Find the first character in tree order that matches the following criteria: The character is from a Text node that is a descendant of the element whose directionality is being determined.  The character is of bidirectional character type L, AL, or R. [BIDI] The character is not in a Text node that has an ancestor element that is a descendant of the element whose directionality is being determined and that is either: A bdi element.  A script element.  A style element.  A textarea element.  An element with a dir attribute in a defined state.  If such a character is found and it is of bidirectional character type AL or R, the directionality of the element is "rtl".  If such a character is found and it is of bidirectional character type L, the directionality of the element is "ltr".  Otherwise, if the element is a root element, the directionality of the element is "ltr".  Otherwise, the directionality of the element the same as the element’s parent element’s directionality.  If the element has a parent element and the dir attribute is not in a defined state (i.e., it is not present or has an invalid value) The directionality of the element is the same as the element’s parent element’s directionality.  Since the dir attribute is only defined for html elements, it cannot be present on elements from other namespaces. Thus, elements from other namespaces always just inherit their directionality from their parent element, or, if they don’t have one, default to "ltr".  This attribute has rendering requirements involving the bidirectional algorithm.  The directionality of an attribute of an HTML element, which is used when the text of that attribute is to be included in the rendering in some manner, is determined as per the first appropriate set of steps from the following list: If the attribute is a directionality-capable attribute and the element’s dir attribute is in the auto state Find the first character (in logical order) of the attribute’s value that is of bidirectional character type L, AL, or R. [BIDI] If such a character is found and it is of bidirectional character type AL or R, the directionality of the attribute is "rtl".  Otherwise, the directionality of the attribute is "ltr".  Otherwise The directionality of the attribute is the same as the element’s directionality.  The following attributes are directionality-capable attributes: abbr on th elements alt on area, img, and input elements content on meta elements, if the name attribute specifies a metadata name whose value is primarily intended to be human-readable rather than machine-readable label on menuitem, menu, optgroup, option, and track elements placeholder on input and textarea elements title on all html elements document . dir [ = value ] Returns the html element’s dir attribute’s value, if any.  Can be set, to either "ltr", "rtl", or "auto" to replace the html element’s dir attribute’s value.  If there is no html element, returns the empty string and ignores new values.  The dir IDL attribute on an element must reflect the dir content attribute of that element, limited to only known values.  The dir IDL attribute on Document objects must reflect the dir content attribute of the html element, if any, limited to only known values. If there is no such element, then the attribute must return the empty string and do nothing on setting.  Authors are strongly encouraged to use the dir attribute to indicate text direction rather than using CSS, since that way their documents will continue to render correctly even in the absence of CSS (e.g., as interpreted by search engines).  This markup fragment is of an IM conversation.  <p dir=auto class="u1"><b><bdi>Student</bdi>:</b> How do you write "What’s your name?" in Arabic?</p> <p dir=auto class="u2"><b><bdi>Teacher</bdi>:</b> ما اسمك؟</p> <p dir=auto class="u1"><b><bdi>Student</bdi>:</b> Thanks.</p> <p dir=auto class="u2"><b><bdi>Teacher</bdi>:</b> That’s written "شكرًا".</p> <p dir=auto class="u2"><b><bdi>Teacher</bdi>:</b> Do you know how to write "Please"?</p> <p dir=auto class="u1"><b><bdi>Student</bdi>:</b> "من فضلك", right?</p> Given a suitable style sheet and the default alignment styles for the p element, namely to align the text to the start edge of the paragraph, the resulting rendering could be as follows: Each paragraph rendered as a separate block, with the paragraphs left-aligned except the second paragraph and the last one, which would  be right aligned, with the usernames ("Student" and "Teacher" in this example) flush right, with a colon to their left, and the text first to the left of that.  As noted earlier, the auto value is not a panacea. The final paragraph in this example is misinterpreted as being right-to-left text, since it begins with an Arabic character, which causes the "right?" to be to the left of the Arabic text.  3.2.5.7. The class attribute Every HTML element may have a class attribute specified.  The attribute, if specified, must have a value that is a set of space-separated tokens representing the various classes that the element belongs to.  The classes that an HTML element has assigned to it consists of all the classes returned when the value of the class attribute is split on spaces. (Duplicates are ignored.) Assigning classes to an element affects class matching in selectors in CSS, the getElementsByClassName() method in the DOM, and other such features.  There are no additional restrictions on the tokens authors can use in the class attribute, but authors are encouraged to use values that describe the nature of the content, rather than values that describe the desired presentation of the content.  The className and classList IDL attributes, defined in the DOM specification, reflect the class content attribute. [DOM] 3.2.5.8. The style attribute There are no known native implementations of blocking the style content attribute based on CSP3 directives. Therefore this feature should not be relied upon.  All html elements may have the style content attribute set. This is a CSS styling attribute as defined by the CSS Styling Attribute Syntax specification. [CSS-STYLE-ATTR] In user agents that support CSS, the attribute’s value must be parsed when the attribute is added or has its value changed, according to the rules given for CSS styling attributes. [CSS-STYLE-ATTR] However, if the Should element’s inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the attribute’s element and "style attribute", then the style rules defined in the attribute’s value must not be applied to the element. [CSP3] Documents that use style attributes on any of their elements must still be comprehensible and usable if those attributes were removed.  In particular, using the style attribute to hide and show content, or to convey meaning that is otherwise not included in the document, is non-conforming. (To hide and show content, use the hidden attribute.) element . style Returns a CSSStyleDeclaration object for the element’s style attribute.  The style IDL attribute is defined in the CSS Object Model (CSSOM) specification. [CSSOM] In the following example, the words that refer to colors are marked up using the span element and the style attribute to make those words show up in the relevant colors in visual media.  <p>My sweat suit is <span style="color: green; background: transparent">green</span> and my eyes are <span style="color: blue; background: transparent">blue</span>.</p> 3.2.5.9. Embedding custom non-visible data with the data-* attributes A custom data attribute is an attribute in no namespace whose name starts with the string "data-", has at least one character after the hyphen, is XML-compatible, and contains no uppercase ASCII letters.  All attribute names on html elements in HTML documents get ASCII-lowercased automatically, so the restriction on ASCII uppercase letters doesn’t affect such documents.  Custom data attributes are intended to store custom data private to the page or application, for which there are no more appropriate attributes or elements.  These attributes are not intended for use by software that is not known to the administrators of the site that uses the attributes. For generic extensions that are to be used by multiple independent tools, either this specification should be extended to provide the feature explicitly, or a technology like microdata should be used (with a standardized vocabulary).  For instance, a site about music could annotate list items representing tracks in an album with custom data attributes containing the length of each track. This information could then be used by the site itself to allow the user to sort the list by track length, or to filter the list for tracks of certain lengths.  <ol> <li data-length="2m11s">Beyond The Sea</li> ...  </ol> It would be inappropriate, however, for the user to use generic software not associated with that music site to search for tracks of a certain length by looking at this data.  This is because these attributes are intended for use by the site’s own scripts, and are not a generic extension mechanism for publicly-usable metadata.  Similarly, a page author could write markup that provides information for a translation tool that they are intending to use: <p>The third <span data-mytrans-de="Anspruch">claim</span> covers the case of <span translate="no">HTML</span> markup.</p> In this example, the "data-mytrans-de" attribute gives specific text for the MyTrans product to use when translating the phrase "claim" to German. However, the standard translate attribute is used to tell it that in all languages, "HTML" is to remain unchanged. When a standard attribute is available, there is no need for a custom data attribute to be used.  Every HTML element may have any number of custom data attributes specified, with any value.  element . dataset Returns a DOMStringMap object for the element’s data-* attributes.  Hyphenated names become camel-cased. For example, data-foo-bar="" becomes element.dataset.fooBar.  The dataset IDL attribute provides convenient accessors for all the data-* attributes on an element. On getting, the dataset IDL attribute must return a DOMStringMap object, associated with the following algorithms, which expose these attributes on their element: The algorithm for getting the list of name-value pairs Let list be an empty list of name-value pairs.  For each content attribute on the element whose first five characters are the string "data-" and whose remaining characters (if any) do not include any uppercase ASCII letters, in the order that those attributes are listed in the element’s attribute list, add a name-value pair to list whose name is the attribute’s name with the first five characters removed and whose value is the attribute’s value.  For each name in list, for each U+002D HYPHEN-MINUS character (-) in the name that is followed by a lowercase ASCII letter, remove the U+002D HYPHEN-MINUS character (-) and replace the character that followed it by the same character converted to ASCII uppercase.  Return list.  The algorithm for setting names to certain values Let name be the name passed to the algorithm.  Let value be the value passed to the algorithm.  If name contains a U+002D HYPHEN-MINUS character (-) followed by a lowercase ASCII letter, throw a "SyntaxError" DOMException and abort these steps.  For each uppercase ASCII letter in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the character with the same character converted to ASCII lowercase.  Insert the string data- at the front of name.  Set the value of the attribute with the name name, to the value value, replacing any previous value if the attribute already existed. If setAttribute() would have thrown an exception when setting an attribute with the name name, then this must throw the same exception.  The algorithm for deleting names Let name be the name passed to the algorithm.  For each uppercase ASCII letter in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the character with the same character converted to ASCII lowercase.  Insert the string data- at the front of name.  Remove the attribute with the name name, if such an attribute exists. Do nothing otherwise.  This algorithm will only get invoked by the Web IDL specification for names that are given by the earlier algorithm for getting the list of name-value pairs. [WEBIDL] If a Web page wanted an element to represent a space ship, e.g., as part of a game, it would have to use the class attribute along with data-* attributes: <div class="spaceship" data-ship-id="30"> <button class="fire" onclick="spaceships[this.parentNode.dataset.shipId].fire()"> Fire </button> </div> Notice how the hyphenated attribute name becomes camel-cased in the API.  Authors should carefully design such extensions so that when the attributes are ignored and any associated CSS dropped, the page is still usable.  User agents must not derive any implementation behavior from these attributes or values. Specifications intended for user agents must not define these attributes to have any meaningful values.  JavaScript libraries may use the custom data attributes, as they are considered to be part of the page on which they are used. Authors of libraries that are reused by many authors are encouraged to include their name in the attribute names, to reduce the risk of clashes. Where it makes sense, library authors are also encouraged to make the exact name used in the attribute names customizable, so that libraries whose authors unknowingly picked the same name can be used on the same page, and so that multiple versions of a particular library can be used on the same page even when those versions are not mutually compatible.  For example, a library called "DoQuery" could use attribute names like data-doquery-range, and a library called "jJo" could use attributes names like data-jjo-range. The jJo library could also provide an API to set which prefix to use (e.g., J.setDataPrefix("j2"), making the attributes have names like data-j2-range).  3.2.6. Requirements relating to the bidirectional algorithm 3.2.6.1. Authoring conformance criteria for bidirectional-algorithm formatting characters Text content in html elements with Text nodes in their contents, and text in attributes of html elements that allow free-form text, may contain characters in the ranges U+202A to U+202E and U+2066 to U+2069 (the bidirectional-algorithm formatting characters). However, the use of these characters is restricted so that any embedding or overrides generated by these characters do not start and end with different parent elements, and so that all such embeddings and overrides are explicitly terminated by a U+202C POP DIRECTIONAL FORMATTING character. This helps reduce incidences of text being reused in a manner that has unforeseen effects on the bidirectional algorithm. [BIDI] The aforementioned restrictions are defined by specifying that certain parts of documents form bidirectional-algorithm formatting character ranges, and then imposing a requirement on such ranges.  The strings resulting from applying the following algorithm to an HTML element element are bidirectional-algorithm formatting character ranges: Let output be an empty list of strings.  Let string be an empty string.  Let node be the first child node of element, if any, or null otherwise.  Loop: If node is null, jump to the step labeled end.  Process node according to the first matching step from the following list: If node is a Text node Append the text data of node to string.  If node is a br element If node is an HTML element that is flow content but that is not also phrasing content If string is not the empty string, push string onto output, and let string be empty string.  Otherwise Do nothing.  Let node be node’s next sibling, if any, or null otherwise.  Jump to the step labeled loop.  End: If string is not the empty string, push string onto output.  Return output as the bidirectional-algorithm formatting character ranges.  The value of a namespace-less attribute of an HTML element is a bidirectional-algorithm formatting character range.  Any strings that, as described above, are bidirectional-algorithm formatting character ranges must match the string production in the following ABNF, the character set for which is Unicode. [ABNF] string        = *( plaintext ( embedding / override / isolation ) ) plaintext embedding     = ( lre / rle ) string pdf override      = ( lro / rlo ) string pdf isolation     = ( lri / rli / fsi ) string pdi lre           = %x202A ; U+202A LEFT-TO-RIGHT EMBEDDING rle           = %x202B ; U+202B RIGHT-TO-LEFT EMBEDDING lro           = %x202D ; U+202D LEFT-TO-RIGHT OVERRIDE rlo           = %x202E ; U+202E RIGHT-TO-LEFT OVERRIDE pdf           = %x202C ; U+202C POP DIRECTIONAL FORMATTING lri           = %x2066 ; U+2066 LEFT-TO-RIGHT ISOLATE rli           = %x2067 ; U+2067 RIGHT-TO-LEFT ISOLATE fsi           = %x2068 ; U+2068 FIRST STRONG ISOLATE pdi           = %x2069 ; U+2069 POP DIRECTIONAL ISOLATE plaintext     = *( %x0000-2029 / %x202F-2065 / %x206A-10FFFF ) ; any string with no bidirectional-algorithm formatting characters While the U+2069 POP DIRECTIONAL ISOLATE character implicitly also ends open embeddings and overrides, text that relies on this implicit scope closure is not conforming to this specification. All strings of embeddings, overrides, and isolations need to be explicitly terminated to conform to this section’s requirements.  Authors are encouraged to use the dir attribute, the bdo element, and the bdi element, rather than maintaining the bidirectional-algorithm formatting characters manually. The bidirectional-algorithm formatting characters interact poorly with CSS.  3.2.6.2. User agent conformance criteria User agents must implement the Unicode bidirectional algorithm to determine the proper ordering of characters when rendering documents and parts of documents. [BIDI] The mapping of HTML to the Unicode bidirectional algorithm must be done in one of three ways. Either the user agent must implement CSS, including in particular the CSS unicode-bidi, direction, and content properties, and must have, in its user agent style sheet, the rules using those properties given in this specification’s §10 Rendering section, or, alternatively, the user agent must act as if it implemented just the aforementioned properties and had a user agent style sheet that included all the aforementioned rules, but without letting style sheets specified in documents override them, or, alternatively, the user agent must implement another styling language with equivalent semantics. [CSS-WRITING-MODES-3] [CSS3-CONTENT] The following elements and attributes have requirements defined by the §10 Rendering section that, due to the requirements in this section, are requirements on all user agents (not just those that support the suggested default rendering): dir attribute bdi element bdo element br element pre element textarea element wbr element 3.2.7. WAI-ARIA and HTML Accessibility API Mappings 3.2.7.1. ARIA Authoring Requirements Authors may use the ARIA role and aria-* attributes on HTML elements, in accordance with the requirements described in the ARIA specifications, except where these conflict with the requirements specified in ARIA in HTML [html-aria]. These exceptions are intended to prevent authors from making assistive technology products report nonsensical states that do not represent the actual state of the document. [WAI-ARIA] In the majority of cases setting an ARIA role and/or aria-* attribute that matches the default implicit ARIA semantics is unnecessary and not recommended as these properties are already set by the browser.  Authors are encouraged to make use of the following documents for guidance on using ARIA in HTML beyond that which is provided in this section: Notes on Using ARIA in HTML - A practical guide for developers on how to to add accessibility information to HTML elements using the Accessible Rich Internet Applications specification [WAI-ARIA].  WAI-ARIA 1.1 Authoring Practices - An author’s guide to understanding and implementing Accessible Rich Internet Applications.  3.2.7.2. Conformance Checker Implementation Requirements Conformance checkers are required to implement document conformance requirements for use of the ARIA role and aria-* attributes on HTML elements , as defined in ARIA in HTML. [html-aria] 3.2.7.3. User Agent Implementation Requirements User agents are required to implement ARIA semantics on all HTML elements , as defined in the ARIA specifications [WAI-ARIA] and [core-aam-1.1].  User agents are required to implement Accessibility API semantics on all HTML elements, as defined in the HTML Accessibility API Mappings specification [html-aam-1.0].  The ARIA attributes defined in the ARIA specifications do not have any effect on CSS pseudo-class matching, user interface modalities that don’t use assistive technologies, or the default actions of user interaction events as described in this specification.  3.2.7.3.1. ARIA Role Attribute Every HTML element may have an ARIA role attribute specified. This is an ARIA Role attribute as defined by [WAI-ARIA].  The attribute, if specified, must have a value that is a set of space-separated tokens; each token must be a non-abstract role defined in the WAI-ARIA specification [WAI-ARIA].  The WAI-ARIA role that an HTML element has assigned to it is the first non-abstract role found in the list of values generated when the role attribute is split on spaces.  3.2.7.3.2. State and Property Attributes Every HTML element may have ARIA state and property attributes specified. These attributes are defined by [WAI-ARIA].  A subset of the ARIA State and Property attributes are defined as "Global States and Properties" in the [WAI-ARIA] Specification.  These attributes, if specified, must have a value that is the ARIA value type in the "Value" field of the definition for the state or property, mapped to the appropriate HTML value type according to [WAI-ARIA].  ARIA State and Property attributes can be used on any element. They are not always meaningful, however, and in such cases user agents might not perform any processing aside from including them in the DOM. State and property attributes are processed according to the requirements of the HTML Accessibility API Mappings specification [html-aam-1.0], as well as [WAI-ARIA] and , as defined in the ARIA specifications [WAI-ARIA] and [core-aam-1.1].  3.2.7.4. Allowed ARIA roles, states and properties This section is non-normative.  The following table provides an informative reference to the ARIA roles, states and properties permitted for use in HTML. All ARIA roles, states and properties are normatively defined in the [WAI-ARIA] specification. Links to ARIA roles, states and properties in the table reference the normative [WAI-ARIA] definitions.  ARIA Roles, States and Properties Role	Description	Required Properties	Supported Properties any	ARIA global states and properties can be used on any HTML element.	none	aria-atomic aria-busy (state) aria-controls aria-describedby aria-disabled (state) aria-dropeffect aria-flowto aria-grabbed (state) aria-haspopup aria-hidden (state) aria-invalid (state) aria-label aria-labelledby aria-live aria-owns aria-relevant alert	A message with important, and usually time-sensitive, information. See related alertdialog and status.	none	aria-expanded (state) alertdialog	A type of dialog that contains an alert message, where initial focus goes to an element within the dialog. See related alert and dialog.	none	aria-expanded (state) application	A region declared as a web application, as opposed to a web document.	none	aria-expanded (state) article	A section of a page that consists of a composition that forms an independent part of a document, page, or site.	none	aria-expanded (state) banner	A region that contains mostly site-oriented content, rather than page-specific content.	none	aria-expanded (state) button	An input that allows for user-triggered actions when clicked or pressed. See related link.	none	aria-expanded (state) aria-pressed (state) checkbox	A checkable input that has three possible values: true, false, or mixed.	aria-checked (state) columnheader	A cell containing header information for a column.	none	aria-sort aria-readonly aria-required aria-selected (state) aria-expanded (state) combobox	A presentation of a select; usually similar to a textbox where users can type ahead to select an option, or type to enter arbitrary text as a new item in the list. See related listbox.	aria-expanded (state) aria-autocomplete aria-required aria-activedescendant complementary	A supporting section of the document, designed to be complementary to the main content at a similar level in the DOM hierarchy, but remains meaningful when separated from the main content.	none	aria-expanded (state) contentinfo	A large perceivable region that contains information about the parent document.	none	aria-expanded (state) definition	A definition of a term or concept.	none	aria-expanded (state) dialog	A dialog is an application window that is designed to interrupt the current processing of an application in order to prompt the user to enter information or require a response. See related alertdialog.	none	aria-expanded (state) directory	A list of references to members of a group, such as a static table of contents.	none	aria-expanded (state) document	A region containing related information that is declared as document content, as opposed to a web application.	none	aria-expanded (state) form	A landmark region that contains a collection of items and objects that, as a whole, combine to create a form. See related search.	none	aria-expanded (state) grid	A grid is an interactive control which contains cells of tabular data arranged in rows and columns, like a table.	none	aria-level aria-multiselectable aria-readonly aria-activedescendant aria-expanded (state) gridcell	A cell in a grid or treegrid.	none	aria-readonly aria-required aria-selected (state) aria-expanded (state) group	A set of user interface objects which are not intended to be included in a page summary or table of contents by assistive technologies.	none	aria-activedescendant aria-expanded (state) heading	A heading for a section of the page.	none	aria-level aria-expanded (state) img	A container for a collection of elements that form an image.	none	aria-expanded (state) link	An interactive reference to an internal or external resource that, when activated, causes the user agent to navigate to that resource. See related button.	none	aria-expanded (state) list	A group of non-interactive list items. See related listbox.	none	aria-expanded (state) listbox	A widget that allows the user to select one or more items from a list of choices. See related combobox and list.	none	aria-multiselectable aria-required aria-expanded (state) aria-activedescendant aria-expanded (state) listitem	A single item in a list or directory.	none	aria-level aria-posinset aria-setsize aria-expanded (state) log	A type of live region where new information is added in meaningful order and old information may disappear. See related marquee.	none	aria-expanded (state) main	The main content of a document.	none	aria-expanded (state) marquee	A type of live region where non-essential information changes frequently. See related log.	none	aria-expanded (state) math	Content that represents a mathematical expression.	none	aria-expanded (state) menu	A type of widget that offers a list of choices to the user.	none	aria-expanded (state) aria-activedescendant aria-expanded (state) menubar	A presentation of menu that usually remains visible and is usually presented horizontally.	none	aria-expanded (state) aria-activedescendant aria-expanded (state) menuitem	An option in a group of choices contained by a menu or menubar.	none	menuitemcheckbox	A checkable menuitem that has three possible values: true, false, or mixed.	aria-checked (state) menuitemradio	A checkable menuitem in a group of menuitemradio roles, only one of which can be checked at a time.	aria-checked (state) aria-posinset aria-selected (state) aria-setsize navigation	A collection of navigational elements (usually links) for navigating the document or related documents.	none	aria-expanded (state) note	A section whose content is parenthetic or ancillary to the main content of the resource.	none	aria-expanded (state) option	A selectable item in a select list.	none	aria-checked (state) aria-posinset aria-selected (state) aria-setsize presentation	An element whose implicit native role semantics will not be mapped to the accessibility API.	none	progressbar	An element that displays the progress status for tasks that take a long time.	none	aria-valuemax aria-valuemin aria-valuenow aria-valuetext radio	A checkable input in a group of radio roles, only one of which can be checked at a time.	aria-checked (state) aria-posinset aria-selected (state) aria-setsize radiogroup	A group of radio buttons.	none	aria-required aria-activedescendant aria-expanded (state) region	A large perceivable section of a web page or document, that the author feels is important enough to be included in a page summary or table of contents, for example, an area of the page containing live sporting event statistics.	none	aria-expanded (state) row	A row of cells in a grid.	none	aria-level aria-selected (state) aria-activedescendant aria-expanded (state) rowgroup	A group containing one or more row elements in a grid.	none	aria-activedescendant aria-expanded (state) rowheader	A cell containing header information for a row in a grid.	none	aria-sort aria-readonly aria-required aria-selected (state) aria-expanded (state) scrollbar	A graphical object that controls the scrolling of content within a viewing area, regardless of whether the content is fully displayed within the viewing area.	aria-controls aria-orientation aria-valuemax aria-valuemin aria-valuenow aria-expanded (state) search	A landmark region that contains a collection of items and objects that, as a whole, combine to create a search facility. See related form.	none	aria-expanded (state) aria-orientation separator	A divider that separates and distinguishes sections of content or groups of menuitems.	none	aria-valuetext slider	A user input where the user selects a value from within a given range.	aria-valuemax aria-valuemin aria-valuenow aria-orientation aria-valuetext spinbutton	A form of range that expects the user to select from among discrete choices.	aria-valuemax aria-valuemin aria-valuenow aria-required aria-valuetext status	A container whose content is advisory information for the user but is not important enough to justify an alert, often but not necessarily presented as a status bar. See related alert.	none	aria-expanded (state) tab	A grouping label providing a mechanism for selecting the tab content that is to be rendered to the user.	none	aria-selected (state) aria-expanded (state) tablist	A list of tab elements, which are references to tabpanel elements.	none	aria-level aria-activedescendant aria-expanded (state) tabpanel	A container for the resources associated with a tab, where each tab is contained in a tablist.	none	aria-expanded (state) textbox	Input that allows free-form text as its value.	none	aria-activedescendant aria-autocomplete aria-multiline aria-readonly aria-required timer	A type of live region containing a numerical counter which indicates an amount of elapsed time from a start point, or the time remaining until an end point.	none	aria-expanded (state) toolbar	A collection of commonly used function buttons represented in compact visual form.	none	aria-activedescendant aria-expanded (state) tooltip	A contextual popup that displays a description for an element.	none	aria-expanded (state) tree	A type of list that may contain sub-level nested groups that can be collapsed and expanded.	none	aria-multiselectable aria-required aria-activedescendant aria-expanded (state) treegrid	A grid whose rows can be expanded and collapsed in the same manner as for a tree.	none	aria-level aria-multiselectable aria-readonly aria-activedescendant aria-expanded (state) aria-required treeitem	An option item of a tree. This is an element within a tree that may be expanded or collapsed if it contains a sub-level group of treeitems.	none	aria-level aria-posinset aria-setsize aria-expanded (state) aria-checked (state) aria-selected (state)← 2 Common infrastructure — Table of contents — 4 The elements of HTML →↑→W3C HTML 5.1 W3C Recommendation, 1 November 2016← 4 The elements of HTML — Table of contents — 4.3 Sections →Table of Contents 4.2Document metadata 4.2.1The head element 4.2.2The title element 4.2.3The base element 4.2.4The link element 4.2.5The meta element 4.2.5.1Standard metadata names 4.2.5.2Other metadata names 4.2.5.3Pragma directives 4.2.5.4Other pragma directives 4.2.5.5Specifying the document’s character encoding 4.2.6The style element 4.2.7Interactions of styling and scripting 4.2. Document metadata 4.2.1. The head element Categories: None.  Contexts in which this element can be used: As the first element in an html element.  Content model: If the document is an iframe srcdoc document or if title information is available from a higher-level protocol: Zero or more elements of metadata content, of which no more than one is a title element and no more than one is a base element.  Otherwise: One or more elements of metadata content, of which exactly one is a title element and no more than one is a base element.  Tag omission in text/html: A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.  A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.  Content attributes: Global attributes Allowed ARIA role attribute values: None Allowed ARIA state and property attributes: Global aria-* attributes DOM interface: interface HTMLHeadElement : HTMLElement {}; The head element represents a collection of metadata for the Document.  The collection of metadata in a head element can be large or small. Here is an example of a very short one: <!doctype html> <html> <head> <title>A document with a short head</title> </head> <body> ...  Here is an example of a longer one: <!DOCTYPE HTML> <HTML> <HEAD> <META CHARSET="UTF-8"> <BASE HREF="https://www.example.com/"> <TITLE>An application with a long head</TITLE> <LINK REL="STYLESHEET" HREF="default.css"> <LINK REL="STYLESHEET ALTERNATE" HREF="big.css" TITLE="Big Text"> <SCRIPT SRC="support.js"></SCRIPT> <META NAME="APPLICATION-NAME" CONTENT="Long headed application"> </HEAD> <BODY> ...  The title element is a required child in most situations, but when a higher-level protocol provides title information, e.g., in the Subject line of an e-mail when HTML is used as an e-mail authoring format, the title element can be omitted.  It is recommended to keep the usage of attributes and their values defined on the head element to a minimum to allow for proper detection of the character encoding declaration within the first 1024 bytes.  4.2.2. The title element Categories: Metadata content.  Contexts in which this element can be used: In a head element containing no other title elements.  Content model: Text that is not inter-element whitespace.  Tag omission in text/html: Neither tag is omissible.  Content attributes: Global attributes Allowed ARIA role attribute values: None Allowed ARIA state and property attributes: Global aria-* attributes DOM interface: interface HTMLTitleElement : HTMLElement { attribute DOMString text; }; The title element represents the document’s title or name. Authors should use titles that identify their documents even when they are used out of context, for example in a user’s history or bookmarks, or in search results. The document’s title is often different from its first heading, since the first heading does not have to stand alone when taken out of context.  There must be no more than one title element per document.  If it’s reasonable for the Document to have no title, then the title element is probably not required. See the head element’s content model for a description of when the element is required.  title . text [ = value ] Returns the contents of the element, ignoring child nodes that aren’t Text nodes.  Can be set, to replace the element’s children with the given value.  The IDL attribute text must return a concatenation of the contents of all the Text nodes that are children of the title element (ignoring any other nodes such as comments or elements), in tree order. On setting, it must act the same way as the textContent IDL attribute.  Here are some examples of appropriate titles, contrasted with the top-level headings that might be used on those same pages.  <title>Introduction to The Mating Rituals of Bees</title> ...  <h1>Introduction</h1> <p>This companion guide to the highly successful <cite>Introduction to Medieval Bee-Keeping</cite> book is...  The next page might be a part of the same site. Note how the title describes the subject matter unambiguously, while the first heading assumes the reader knows what the context is and therefore won’t wonder if the dances are Salsa or Waltz: <title>Dances used during bee mating rituals</title> ...  <h2>The Dances</h2> The string to use as the document’s title is given by the document.title IDL attribute.  User agents should use the document’s title when referring to the document in their user interface. When the contents of a title element are used in this way, the directionality of that title element should be used to set the directionality of the document’s title in the user interface.  4.2.3. The base element Categories: Metadata content.  Contexts in which this element can be used: In a head element containing no other base elements.  Content model: Nothing.  Tag omission in text/html: No end tag.  Content attributes: Global attributes href — Document base URL target — Default browsing context for hyperlink navigation and §4.10.22 Form submission Allowed ARIA role attribute values: None Allowed ARIA state and property attributes: Global aria-* attributes.  DOM interface: interface HTMLBaseElement : HTMLElement { attribute DOMString href; attribute DOMString target; }; The base element allows authors to specify the document base URL for the purposes of parsing relative URLs, and the name of the default browsing context for the purposes of following hyperlinks. The element does not represent any content beyond this information.  There must be no more than one base element per document.  A base element must have either an href attribute, a target attribute, or both.  The href content attribute, if specified, must contain a valid URL potentially surrounded by spaces.  A base element, if it has an href attribute, must come before any other elements in the tree that have attributes defined as taking URLs except the html element.  If there are multiple base elements with href attributes, all but the first are ignored.  The target attribute, if specified, must contain a valid browsing context name or keyword, which specifies which browsing context is to be used as the default when hyperlinks and forms in the Document cause navigation.  A base element, if it has a target attribute, must come before any elements in the tree that represent hyperlinks.  If there are multiple base elements with target attributes, all but the first are ignored.  A base element that is the first base element with an href content attribute in a particular Document has a frozen base URL. The frozen base URL must be immediately set for an element whenever any of the following situations occur: The base element becomes the first base element in tree order with an href content attribute in its Document.  The base element is the first base element in tree order with an href content attribute in its Document, and its href content attribute is changed.  To set the frozen base URL, for an element element: Let document be element’s node document.  Let urlRecord be the result of parsing the value of element’s href content attribute with document’s fallback base URL, and document’s character encoding. (Thus the base element isn’t affected by itself.) Set elements’s frozen base URL to document’s fallback base URL, if urlRecord is failure or running Is base allowed for Document? on the resulting URL record and document returns "Blocked", and to urlRecord otherwise.  The href IDL attribute, on getting, must return the result of running the following algorithm: Let document be element’s node document.  Let url be the value of the href attribute of the base element, if it has one, and the empty string otherwise.  Let urlRecord be the result of parsing url with document’s fallback base url, and document’s character encoding. (Thus, the base element isn’t affected by other base elements or itself).  If urlRecord is failure, return url.  Return the serialization of urlRecord.  The href IDL attribute, on setting, must set the href content attribute to the given new value.  The target IDL attribute must reflect the content attribute of the same name.  In this example, a base element is used to set the document base URL: <!DOCTYPE html> <html> <head> <title>This is an example for the &lt;base&gt; element</title> <base href="https://www.example.com/news/index.html"> </head> <body> <p>Visit the <a href="archives.html">archives</a>.</p> </body> </html> The link in the above example would be a link to "https://www.example.com/news/archives.html".  4.2.4. The link element Categories: Metadata content.  Contexts in which this element can be used: Where metadata content is expected.  In a noscript element that is a child of a head element.  Content model: Nothing.  Tag omission in text/html: No end tag.  Content attributes: Global attributes href — Address of the hyperlink crossorigin — How the element handles crossorigin requests rel — Relationship of this document (or subsection/topic) to the destination resource rev — Reverse link relationship of the destination resource to this document (or subsection/topic) media — Applicable media hreflang — Language of the linked resource type — Hint for the type of the referenced resource sizes — Sizes of the icons (for rel="icon") Also, the title attribute has special semantics on this element: Title of the link; alternative style sheet set name.  Allowed ARIA role attribute values: link (default - do not set).  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  For role value DOM interface: interface HTMLLinkElement : HTMLElement { attribute DOMString href; attribute DOMString? crossOrigin; attribute DOMString rel; attribute DOMString rev; [SameObject, PutForwards=value]readonly attribute DOMTokenList relList; attribute DOMString media; attribute DOMString hreflang; attribute DOMString type; [SameObject, PutForwards=value] readonly attribute DOMTokenList sizes; }; HTMLLinkElement implements LinkStyle; The link element allows authors to link their document to other resources.  The destination of the link(s) is given by the href attribute, which must be present and must contain a valid non-empty URL potentially surrounded by spaces. If the href attribute is absent, then the element does not define a link.  A link element must have a rel attribute.  If the rel attribute is used, the element is restricted to the head element.  The types of link indicated (the relationships) are given by the value of the rel attribute, which, if present, must have a value that is a set of space-separated tokens. The allowed keywords and their meanings are defined in a later section. If the rel attribute is absent, has no keywords, or if none of the keywords used are allowed according to the definitions in this specification, then the element does not create any links.  Two categories of links can be created using the link element: Links to external resources and hyperlinks. The §4.8.6 Link types section defines whether a particular link type is an external resource or a hyperlink. One link element can create multiple links (of which some might be external resource links and some might be hyperlinks); exactly which and how many links are created depends on the keywords given in the rel attribute. User agents must process the links on a per-link basis, not a per-element basis.  Each link created for a link element is handled separately. For instance, if there are two link elements with rel="stylesheet", they each count as a separate external resource, and each is affected by its own attributes independently. Similarly, if a single link element has a rel attribute with the value next stylesheet, it creates both a hyperlink (for the next keyword) and an external resource link (for the stylesheet keyword), and they are affected by other attributes (such as media or title) differently.  For example, the following link element creates two hyperlinks (to the same page): <link rel="author license" href="/about"> The two links created by this element are one whose semantic is that the target page has information about the current page’s author, and one whose semantic is that the target page has information regarding the license under which the current page is provided.  link and a elements may also have a rev attribute, which is used to describe a reverse link relationship from the resource specified by the href to the current document. If present, the value of this attribute must be a set of space-separated tokens. Like the rel attribute, §4.8.6 Link types describes the allowed keywords and their meanings for the rev attribute. Both the rel and rev attributes may be present on the same element.  Reverse links are a way to express the reverse directional relationship of a link. In contrast to the rel attribute, whose value conveys a forward directional relationship ("how is the link related to me"), the rev attribute allows for similiar relationships to be expressed in the reverse direction ("how am I related to this link"). These values can enable user agents to build a more comprehensive map of linked documents.  Given two documents, each containing a chapter of a book, the links between them could be described with the rel and rev attributes as follows: Document with URL "chapter1.html" <link href="chapter2.html" rel="next" rev="prev"> Document with URL "chapter2.html" <link href="chapter1.html" rel="prev" rev="next"> <link href="chapter3.html" rel="next" rev="prev"> From chapter1.html, the link to chapter2.html is the "next" chapter in the series in the forward direction, and the "previous" chapter in the reverse diretion (from chapter2.html to chapter1.html).  The links in a table of contents document might be described using rel and rev as follows: <ol> <li><a href="chapter1.html" rev="toc" rel="next">chapter 1</a></li> <li><a href="chapter2.html" rev="toc"></a>chapter 2</li> <li><a href="chapter3.html" rev="toc"></a>chapter 3</li> </ol> From the table of contents, the "next" logical path is to the first chapter, expressed using rel. Each chapter link has a "toc" rev value which indicates that the current document is the table of contents document for every chapter.  The crossorigin attribute is a CORS settings attribute. It is intended for use with external resource links.  The exact behavior for links to external resources depends on the exact relationship, as defined for the relevant link type. Some of the attributes control whether or not the external resource is to be applied (as defined below).  For external resources that are represented in the DOM (for example, style sheets), the DOM representation must be made available (modulo cross-origin restrictions) even if the resource is not applied. To obtain the resource, the user agent must run the following steps: If the href attribute’s value is the empty string, then abort these steps.  Parse the URL given by the href attribute, relative to the element’s node document. If that fails, then abort these steps. Otherwise, let url be the resulting URL record.  Let corsAttributeState be the current state of the element’s crossorigin content attribute.  Let request be the result of creating a potential-CORS request given url and corsAttributeState.  Set request’s client to the link element’s node document’s Window object’s environment settings object.  Fetch request.  User agents may opt to only try to obtain such resources when they are needed, instead of pro-actively fetching all the external resources that are not applied.  The semantics of the protocol used (e.g., HTTP) must be followed when fetching external resources. (For example, redirects will be followed and 404 responses will cause the external resource to not be applied.) Once the attempts to obtain the resource and its critical subresources are complete, the user agent must, if the loads were successful, queue a task to fire a simple event named load at the link element, or, if the resource or one of its critical subresources failed to completely load for any reason (e.g., DNS error, HTTP 404 response, a connection being prematurely closed, unsupported Content-Type), queue a task to fire a simple event named error at the link element. Non-network errors in processing the resource or its subresources (e.g., CSS parse errors, PNG decoding errors) are not failures for the purposes of this paragraph.  The task source for these tasks is the DOM manipulation task source.  The element must delay the load event of the element’s node document until all the attempts to obtain the resource and its critical subresources are complete. (Resources that the user agent has not yet attempted to obtain, e.g., because it is waiting for the resource to be needed, do not delay the load event.) Interactive user agents may provide users with a means to follow the hyperlinks created using the link element, somewhere within their user interface. The exact interface is not defined by this specification, but it could include the following information (obtained from the element’s attributes, again as defined below), in some form or another (possibly simplified), for each hyperlink created with each link element in the document: The relationship between this document and the resource (given by the rel attribute) The title of the resource (given by the title attribute).  The address of the resource (given by the href attribute).  The language of the resource (given by the hreflang attribute).  The optimum media for the resource (given by the media attribute).  User agents could also include other information, such as the type of the resource (as given by the type attribute).  Hyperlinks created with the link element and its rel attribute apply to the whole page. This contrasts with the rel attribute of a and area elements, which indicates the type of a link whose context is given by the link’s location within the document.  The media attribute says which media the resource applies to. The value must be a valid media query list.  If the link is a hyperlink then the media attribute is purely advisory, and describes for which media the document in question was designed.  However, if the link is an external resource link, then the media attribute is prescriptive. The user agent must apply the external resource when the media attribute’s value matches the environment and the other relevant conditions apply, and must not apply it otherwise.  The external resource might have further restrictions defined within that limit its applicability. For example, a CSS style sheet might have some @media blocks. This specification does not override such further restrictions or requirements.  The default, if the media attribute is omitted, is "all", meaning that by default links apply to all media.  The hreflang attribute on the link element has the same semantics as the hreflang attribute on the a element.  The type attribute gives the MIME type of the linked resource. It is purely advisory. The value must be a valid mime type.  For external resource links, the type attribute is used as a hint to user agents so that they can avoid fetching resources they do not support. If the attribute is present, then the user agent must assume that the resource is of the given type (even if that is not a valid mime type, e.g., the empty string). If the attribute is omitted, but the external resource link type has a default type defined, then the user agent must assume that the resource is of that type. If the user agent does not support the given MIME type for the given link relationship, then the user agent should not obtain the resource; if the user agent does support the given MIME type for the given link relationship, then the user agent should obtain the resource at the appropriate time as specified for the external resource link’s particular type. If the attribute is omitted, and the external resource link type does not have a default type defined, but the user agent would obtain the resource if the type was known and supported, then the user agent should obtain the resource under the assumption that it will be supported.  User agents must not consider the type attribute authoritative — upon fetching the resource, user agents must not use the type attribute to determine its actual type. Only the actual type (as defined in the next paragraph) is used to determine whether to apply the resource, not the aforementioned assumed type.  If the external resource link type defines rules for processing the resource’s Content-Type metadata, then those rules apply. Otherwise, if the resource is expected to be an image, user agents may apply the image sniffing rules, with the official type being the type determined from the resource’s Content-Type metadata, and use the resulting computed type of the resource as if it was the actual type. Otherwise, if neither of these conditions apply or if the user agent opts not to apply the image sniffing rules, then the user agent must use the resource’s Content-Type metadata to determine the type of the resource. If there is no type metadata, but the external resource link type has a default type defined, then the user agent must assume that the resource is of that type.  The stylesheet link type defines rules for processing the resource’s Content-Type metadata.  Once the user agent has established the type of the resource, the user agent must apply the resource if it is of a supported type and the other relevant conditions apply, and must ignore the resource otherwise.  If a document contains style sheet links labeled as follows: <link rel="stylesheet" href="A" type="text/plain"> <link rel="stylesheet" href="B" type="text/css"> <link rel="stylesheet" href="C"> ...then a compliant user agent that supported only CSS style sheets would fetch the B and C files, and skip the A file (since text/plain is not the MIME type for CSS style sheets).  For files B and C, it would then check the actual types returned by the server. For those that are sent as text/css, it would apply the styles, but for those labeled as text/plain, or any other type, it would not.  If one of the two files was returned without a Content-Type metadata, or with a syntactically incorrect type like Content-Type: "null", then the default type for stylesheet links would kick in. Since that default type is text/css, the style sheet would nonetheless be applied.  The title attribute gives the title of the link. With one exception, it is purely advisory. The value is text. The exception is for style sheet links, where the title attribute defines alternative style sheet sets.  The title attribute on link elements differs from the global title attribute of most other elements in that a link without a title does not inherit the title of the parent element: it merely has no title.  The sizes attribute is used with the icon link type. The attribute must not be specified on link elements that do not have a rel attribute that specifies the icon keyword.  The activation behavior of link elements that create hyperlinks is to run the following steps: If the link element’s node document is not fully active, then abort these steps.  Follow the hyperlink created by thelink element.  HTTP Link: headers, if supported, must be assumed to come before any links in the document, in the order that they were given in the HTTP message. These headers are to be processed according to the rules given in the relevant specifications. [HTTP] [RFC5988] Registration of relation types in HTTP Link: headers is distinct from HTML link types, and thus their semantics can be different from same-named HTML types.  The IDL attributes href, rel, rev, media, hreflang, type, and sizes each must reflect the respective content attributes of the same name.  The crossOrigin IDL attribute must reflect the crossorigin content attribute.  The IDL attribute relList must reflect the rel content attribute.  relList’s DOMTokenList’s supported tokens are the keywords defined in HTML link types which are allowed on link elements and supported by the user agent.  rel"s supported tokens are the keywords defined in HTML link types which are allowed on link elements, impact the processing model, and are supported by the user agent. The possible supported tokens are alternate, dns-prefetch, icon, preconnect, prefetch, prerender, and stylesheet. rel"s supported tokens must only include the tokens from this list that the user agent implements the processing model for.  Other specifications may add HTML link types as defined in Other link types, such as [RESOURCE-HINTS]. These specifications may require that their link types be included in rel"s supported tokens.  The LinkStyle interface is also implemented by this element. [CSSOM] Here, a set of link elements provide some style sheets: <!-- a persistent style sheet --> <link rel="stylesheet" href="default.css"> <!-- the preferred alternate style sheet --> <link rel="stylesheet" href="green.css" title="Green styles"> <!-- some alternate style sheets --> <link rel="alternate stylesheet" href="contrast.css" title="High contrast"> <link rel="alternate stylesheet" href="big.css" title="Big fonts"> <link rel="alternate stylesheet" href="wide.css" title="Wide screen"> The following example shows how you can specify versions of the page that use alternative formats, are aimed at other languages, and that are intended for other media: <link rel=alternate href="/en/html" hreflang=en type=text/html title="English HTML"> <link rel=alternate href="/fr/html" hreflang=fr type=text/html title="French HTML"> <link rel=alternate href="/en/html/print" hreflang=en type=text/html media=print title="English HTML (for printing)"> <link rel=alternate href="/fr/html/print" hreflang=fr type=text/html media=print title="French HTML (for printing)"> <link rel=alternate href="/en/pdf" hreflang=en type=application/pdf title="English PDF"> <link rel=alternate href="/fr/pdf" hreflang=fr type=application/pdf title="French PDF"> 4.2.5. The meta element Categories: Metadata content.  Contexts in which this element can be used: If the charset attribute is present, or if the element’s http-equiv attribute is in the encoding declaration state: in a head element.  If the http-equiv attribute is present but not in the encoding declaration state: in a head element.  If the http-equiv attribute is present but not in the encoding declaration state: in a noscript element that is a child of a head element.  If the name attribute is present: where metadata content is expected.  Content model: Nothing.  Tag omission in text/html: No end tag.  Content attributes: Global attributes name — Metadata name http-equiv — Pragma directive content — Value of the element charset — Character encoding declaration Allowed ARIA role attribute values: None Allowed ARIA state and property attributes: Global aria-* attributes DOM interface: interface HTMLMetaElement : HTMLElement { attribute DOMString name; attribute DOMString httpEquiv; attribute DOMString content; }; The meta element represents various kinds of metadata that cannot be expressed using the title, base, link, style, and script elements.  The meta element can represent document-level metadata with the name attribute, pragma directives with the http-equiv attribute, and the file’s character encoding declaration when an HTML document is serialized to string form (e.g., for transmission over the network or for disk storage) with the charset attribute.  Exactly one of the name, http-equiv, and charset attributes must be specified.  If either name or http-equiv is specified, then the content attribute must also be specified. Otherwise, it must be omitted.  The charset attribute specifies the character encoding used by the document. This is a character encoding declaration. If the attribute is present in an XML document, its value must be an ASCII case-insensitive match for the string "utf-8" (and the document is therefore forced to use UTF-8 as its encoding).  The charset attribute on the meta element has no effect in XML documents, and is only allowed in order to facilitate migration to and from XHTML.  There must not be more than one meta element with a charset attribute per document.  The content attribute gives the value of the document metadata or pragma directive when the element is used for those purposes. The allowed values depend on the exact context, as described in subsequent sections of this specification.  If a meta element has a name attribute, it sets document metadata. Document metadata is expressed in terms of name-value pairs, the name attribute on the meta element giving the name, and the content attribute on the same element giving the value. The name specifies what aspect of metadata is being set; valid names and the meaning of their values are described in the following sections. If a meta element has no content attribute, then the value part of the metadata name-value pair is the empty string.  The name and content IDL attributes must reflect the respective content attributes of the same name. The IDL attribute httpEquiv must reflect the content attribute http-equiv.  4.2.5.1. Standard metadata names This specification defines a few names for the name attribute of the meta element.  Names are case-insensitive, and must be compared in an ASCII case-insensitive manner.  application-name The value must be a short free-form string giving the name of the Web application that the page represents. If the page is not a Web application, the application-name metadata name must not be used. Translations of the Web application’s name may be given, using the lang attribute to specify the language of each name.  There must not be more than one meta element with a given language and with its name attribute set to the value application-name per document.  User agents may use the application name in UI in preference to the page’s title, since the title might include status messages and the like relevant to the status of the page at a particular moment in time instead of just being the name of the application.  To find the application name to use given an ordered list of languages (e.g., British English, American English, and English), user agents must run the following steps: Let languages be the list of languages.  Let default language be the language of the Document"s root element, if any, and if that language is not unknown.  If there is a default language, and if it is not the same language as any of the languages in languages, append it to languages.  Let winning language be the first language in languages for which there is a meta element in the Document that has its name attribute set to the value application-name and whose language is the language in question.  If none of the languages have such a meta element, then abort these steps; there’s no given application name.  Return the value of the content attribute of the first meta element in the Document in tree order that has its name attribute set to the value application-name and whose language is winning language.  This algorithm would be used by a browser when it needs a name for the page, for instance, to label a bookmark. The languages it would provide to the algorithm would be the user’s preferred languages.  author The value must be a free-form string giving the name of one of the page’s authors.  description The value must be a free-form string that describes the page. The value must be appropriate for use in a directory of pages, e.g., in a search engine. There must not be more than one meta element with its name attribute set to the value description per document.  generator The value must be a free-form string that identifies one of the software packages used to generate the document. This value must not be used on pages whose markup is not generated by software, e.g., pages whose markup was written by a user in a text editor.  Here is what a tool called "Frontweaver" could include in its output, in the page’s head element, to identify itself as the tool used to generate the page: <meta name=generator content="Frontweaver 8.2"> keywords The value must be a set of comma-separated tokens, each of which is a keyword relevant to the page.  This page about typefaces on British motorways uses a meta element to specify some keywords that users might use to look for the page: <!DOCTYPE HTML> <html lang="en-GB"> <head> <title>Typefaces on UK motorways</title> <meta name="keywords" content="british,type face,font,fonts,highway,highways"> </head> <body> ...  Many search engines do not consider such keywords, because this feature has historically been used unreliably and even misleadingly as a way to spam search engine results in a way that is not helpful for users.  To obtain the list of keywords that the author has specified as applicable to the page, the user agent must run the following steps: Let keywords be an empty list.  For each meta element with a name attribute and a content attribute and whose name attribute’s value is keywords, run the following substeps: Split the value of the element’s content attribute on commas.  Add the resulting tokens, if any, to keywords.  Remove any duplicates from keywords.  Return keywords. This is the list of keywords that the author has specified as applicable to the page.  User agents should not use this information when there is insufficient confidence in the reliability of the value.  For instance, it would be reasonable for a content management system to use the keyword information of pages within the system to populate the index of a site-specific search engine, but a large-scale content aggregator that used this information would likely find that certain users would try to game its ranking mechanism through the use of inappropriate keywords.  4.2.5.2. Other metadata names Extensions to the predefined set of metadata names may be registered in the WHATWG Wiki MetaExtensions page. [WHATWGWIKI] Anyone is free to edit the WHATWG Wiki MetaExtensions page at any time to add a type. These new names must be specified with the following information: Keyword The actual name being defined. The name should not be confusingly similar to any other defined name (e.g., differing only in case).  Brief description A short non-normative description of what the metadata name’s meaning is, including the format the value is required to be in.  Specification A link to a more detailed description of the metadata name’s semantics and requirements. It could be another page on the Wiki, or a link to an external page.  Synonyms A list of other names that have exactly the same processing requirements. Authors should not use the names defined to be synonyms, they are only intended to allow user agents to support legacy content. Anyone may remove synonyms that are not used in practice; only names that need to be processed as synonyms for compatibility with legacy content are to be registered in this way.  Status One of the following: Proposed The name has not received wide peer review and approval. Someone has proposed it and is, or soon will be, using it.  Ratified The name has received wide peer review and approval. It has a specification that unambiguously defines how to handle pages that use the name, including when they use it in incorrect ways.  Discontinued The metadata name has received wide peer review and it has been found wanting. Existing pages are using this metadata name, but new pages should avoid it. The "brief description" and "specification" entries will give details of what authors should use instead, if anything.  If a metadata name is found to be redundant with existing values, it should be removed and listed as a synonym for the existing value.  If a metadata name is registered in the "proposed" state for a period of a month or more without being used or specified, then it may be removed from the registry.  If a metadata name is added with the "proposed" status and found to be redundant with existing values, it should be removed and listed as a synonym for the existing value. If a metadata name is added with the "proposed" status and found to be harmful, then it should be changed to "discontinued" status.  Anyone can change the status at any time, but should only do so in accordance with the definitions above.  Conformance checkers may use the information given on the WHATWG Wiki MetaExtensions page to establish if a value is allowed or not: values defined in this specification or marked as "proposed" or "ratified" must be accepted, whereas values marked as "discontinued" or not listed in either this specification or on the aforementioned page must be reported as invalid. Conformance checkers may cache this information (e.g., for performance reasons or to avoid the use of unreliable network connectivity).  When an author uses a new metadata name not defined by either this specification or the Wiki page, conformance checkers should offer to add the value to the Wiki, with the details described above, with the "proposed" status.  Metadata names whose values are to be URLs must not be proposed or accepted. Links must be represented using the link element, not the meta element.  4.2.5.3. Pragma directives When the http-equiv attribute is specified on a meta element, the element is a pragma directive.  The http-equiv attribute is an enumerated attribute. The following table lists the keywords defined for this attribute. The states given in the first cell of the rows with keywords give the states to which those keywords map. Some of the keywords are non-conforming, as noted in the last column.  State	Keyword	Notes Content Language	content-language	Non-conforming Encoding declaration	content-type	Default style	default-style	Refresh	refresh	Cookie setter	set-cookie	Non-conforming When a meta element is inserted into the document, if its http-equiv attribute is present and represents one of the above states, then the user agent must run the algorithm appropriate for that state, as described in the following list: Content language state (http-equiv="content-language") This feature is non-conforming. Authors are encouraged to use the lang attribute instead.  This pragma sets the pragma-set default language. Until such a pragma is successfully processed, there is no pragma-set default language.  If the meta element has no content attribute, then abort these steps.  If the element’s content attribute contains a U+002C COMMA character (,) then abort these steps.  Let input be the value of the element’s content attribute.  Let position point at the first character of input.  Skip whitespace.  Collect a sequence of characters that are not space characters.  Let candidate be the string that resulted from the previous step.  If candidate is the empty string, abort these steps.  Set the pragma-set default language to candidate.  If the value consists of multiple space-separated tokens, tokens after the first are ignored.  This pragma is not the same as the HTTP Content-Language header of the same name. HTTP Content-Language values with more than one language tag will be rejected as invalid by this pragma. [HTTP] Encoding declaration state (http-equiv="content-type") The encoding declaration state is just an alternative form of setting the charset attribute: it is a character encoding declaration. This state’s user agent requirements are all handled by the parsing section of the specification.  For meta elements with an http-equiv attribute in the encoding declaration state, the content attribute must have a value that is an ASCII case-insensitive match for a string that consists of: the literal string "text/html;", optionally followed by any number of space characters, followed by the literal string "charset=", followed by one of the labels of the character encoding of the character encoding declaration.  A document must not contain both a meta element with an http-equiv attribute in the encoding declaration state and a meta element with the charset attribute present.  The encoding declaration state may be used in HTML documents and in XML Documents. If the encoding declaration state is used in XML Documents, the name of the character encoding must be an ASCII case-insensitive match for the string "UTF-8" (and the document is therefore forced to use UTF-8 as its encoding).  The encoding declaration state has no effect in XML documents, and is only allowed in order to facilitate migration to and from XHTML.  Default style state (http-equiv="default-style") This pragma sets the name of the default alternative style sheet set.  If the meta element has no content attribute, or if that attribute’s value is the empty string, then abort these steps.  Set the preferred style sheet set to the value of the element’s content attribute. [CSSOM] Refresh state (http-equiv="refresh") This pragma acts as timed redirect.  If another meta element with an http-equiv attribute in the Refresh state has already been successfully processed (i.e., when it was inserted the user agent processed it and reached the step labeled end), then abort these steps.  If the meta element has no content attribute, or if that attribute’s value is the empty string, then abort these steps.  Let input be the value of the element’s content attribute.  Let position point at the first character of input.  Skip whitespace.  Collect a sequence of characters that are ASCII digits, and parse the resulting string using the rules for parsing non-negative integers. If the sequence of characters collected is the empty string, then no number will have been parsed; abort these steps. Otherwise, let time be the parsed number.  Collect a sequence of characters that are ASCII digits and U+002E FULL STOP characters (.). Ignore any collected characters.  Let url be the meta element’s node document’s URL.  If position is past the end of input, jump to the step labeled end.  If the character in input pointed to by position is not a U+003B SEMICOLON character (;), a U+002C COMMA character (,), or a space character, then abort these steps.  Skip whitespace.  If the character in input pointed to by position is a U+003B SEMICOLON character (;), a U+002C COMMA character (,), then advance position to the next character.  Skip whitespace.  If position is past the end of input, jump to the step labeled end.  Let url be equal to the substring of input from the character at position to the end of the string.  If the character in input pointed to by position is a U+0055 LATIN CAPITAL LETTER U character (U) or a U+0075 LATIN SMALL LETTER U character (u), then advance position to the next character. Otherwise, jump to the step labeled skip quotes.  If the character in input pointed to by position is a U+0052 LATIN CAPITAL LETTER R character (R) or a U+0072 LATIN SMALL LETTER R character (r), then advance position to the next character. Otherwise, jump to the step labeled Parse.  If the character in input pointed to by position is s U+004C LATIN CAPITAL LETTER L character (L) or a U+006C LATIN SMALL LETTER L character (l), then advance position to the next character. Otherwise, jump to the step labeled Parse.  Skip whitespace.  If the character in input pointed to by position is a U+003D EQUALS SIGN (=), then advance position to the next character. Otherwise, jump to the step step labeled Parse.  Skip whitespace.  Skip quotes: If the character in input pointed to by position is either a U+0027 APOSTROPHE character (") or U+0022 QUOTATION MARK character ("), then let quote be that character, and advance position to the next character. Otherwise, let quote be the empty string.  Let url be equal to the substring of input from the character at position to the end of the string.  If quote is not the empty string, and there is a character in url equal to quote, then truncate url at that character, so that it and all subsequent characters are removed.  Parse: Parse url relative to the meta element’s node document. If that fails, abort these steps. Otherwise, let urlRecord be the resulting URL record.  End: Perform one or more of the following steps: After the refresh has come due (as defined below), if the user has not canceled the redirect and if the meta element’s node document’s active sandboxing flag set does not have the sandboxed automatic features browsing context flag set, navigate the Document"s browsing context to urlRecord, with replacement enabled, and with the Document"s browsing context as the source browsing context.  For the purposes of the previous paragraph, a refresh is said to have come due as soon as the later of the following two conditions occurs: At least time seconds have elapsed since the document has completely loaded, adjusted to take into account user or user agent preferences.  At least time seconds have elapsed since the meta element was inserted into the document, adjusted to take into account user or user agent preferences.  Provide the user with an interface that, when selected, navigates a browsing context to urlRecord, with the Document"s browsing context as the source browsing context.  Do nothing.  In addition, the user agent may, as with anything, inform the user of any and all aspects of its operation, including the state of any timers, the destinations of any timed redirects, and so forth.  For meta elements with an http-equiv attribute in the Refresh state, the content attribute must have a value consisting either of: just a valid non-negative integer, or a valid non-negative integer, followed by a U+003B SEMICOLON character (;), followed by one or more space characters, followed by a substring that is an ASCII case-insensitive match for the string "URL", followed by a U+003D EQUALS SIGN character (=), followed by a valid URL that does not start with a literal U+0027 APOSTROPHE (") or U+0022 QUOTATION MARK (") character.  In the former case, the integer represents a number of seconds before the page is to be reloaded; in the latter case the integer represents a number of seconds before the page is to be replaced by the page at the given URL.  A news organization’s front page could include the following markup in the page’s head element, to ensure that the page automatically reloads from the server every five minutes: <meta http-equiv="Refresh" content="300"> A sequence of pages could be used as an automated slide show by making each page refresh to the next page in the sequence, using markup such as the following: <meta http-equiv="Refresh" content="20; URL=page4.html"> Cookie setter (http-equiv="set-cookie") This pragma sets an HTTP cookie. [COOKIES] It is non-conforming. Real HTTP headers should be used instead.  If the meta element has no content attribute, or if that attribute’s value is the empty string, then abort these steps.  Act as if receiving a set-cookie-string for the document’s address via a "non-HTTP" API, consisting of the value of the element’s content attribute encoded as UTF-8. [COOKIES] [ENCODING] Content security policy state (http-equiv="content-security-policy") This pragma enforces a Content Security Policy on a Document. [CSP3] If the meta element is not a child of a head element, abort these steps.  If the meta element has no content attribute, or if that attribute’s value is the empty string, then abort these steps.  Let policy be the result of executing Content Security Policy’s parse a serialized Content Security Policy algorithm on the meta element’s content attribute’s value.  Remove all occurrences of the report-uri, frame-ancestors, and sandbox directives from policy.  Enforce the policy policy.  For meta elements with an http-equiv attribute in the Content security policy state, the content attribute must have a value consisting of a valid Content Security Policy, but must not contain any report-uri, frame-ancestors, or sandbox directives. The Content Security Policy given in the content attribute will be enforced upon the current document. [CSP3] A page might choose to mitigate the risk of cross-site scripting attacks by preventing the execution of inline JavaScript, as well as blocking all plugin content, using a policy such as the following: <meta http-equiv="Content-Security-Policy" content="script-src "self"; object-src "none""> There must not be more than one meta element with any particular state in the document at a time.  4.2.5.4. Other pragma directives Extensions to the predefined set of pragma directives may, under certain conditions, be registered in the WHATWG Wiki PragmaExtensions page. [WHATWGWIKI] Such extensions must use a name that is identical to an HTTP header registered in the Permanent Message Header Field Registry, and must have behavior identical to that described for the HTTP header. [IANAPERMHEADERS] Pragma directives corresponding to headers describing metadata, or not requiring specific user agent processing, must not be registered; instead, use metadata names. Pragma directives corresponding to headers that affect the HTTP processing model (e.g., caching) must not be registered, as they would result in HTTP-level behavior being different for user agents that implement HTML than for user agents that do not.  Anyone is free to edit the WHATWG Wiki PragmaExtensions page at any time to add a pragma directive satisfying these conditions. Such registrations must specify the following information: Keyword The actual name being defined. The name must match a previously-registered HTTP name with the same requirements.  Brief description A short non-normative description of the purpose of the pragma directive.  Specification A link to the specification defining the corresponding HTTP header.  Conformance checkers must use the information given on the WHATWG Wiki PragmaExtensions page to establish if a value is allowed or not: values defined in this specification or listed on the aforementioned page must be accepted, whereas values not listed in either this specification or on the aforementioned page must be rejected as invalid. Conformance checkers may cache this information (e.g., for performance reasons or to avoid the use of unreliable network connectivity).  4.2.5.5. Specifying the document’s character encoding A character encoding declaration is a mechanism by which the character encoding used to store or transmit a document is specified.  The following restrictions apply to character encoding declarations: The character encoding name given must be an ASCII case-insensitive match for one of the labels of the character encoding used to serialize the file. [ENCODING] The character encoding declaration must be serialized without the use of character references or character escapes of any kind.  The element containing the character encoding declaration must be serialized completely within the first 1024 bytes of the document.  In addition, due to a number of restrictions on meta elements, there can only be one meta-based character encoding declaration per document.  If an HTML document does not start with a BOM, and its encoding is not explicitly given by Content-Type metadata, and the document is not an iframe srcdoc document, then the character encoding used must be an ASCII-compatible encoding, and the encoding must be specified using a meta element with a charset attribute or a meta element with an http-equiv attribute in the encoding declaration state.  A character encoding declaration is required (either in the Content-Type metadata or explicitly in the file) even if the encoding is US-ASCII, because a character encoding is needed to process non-ASCII characters entered by the user in forms, in URLs generated by scripts, and so forth.  If the document is an iframe srcdoc document, the document must not have a character encoding declaration. (In this case, the source is already decoded, since it is part of the document that contained the iframe.) If an HTML document contains a meta element with a charset attribute or a meta element with an http-equiv attribute in the encoding declaration state, then the character encoding used must be an ASCII-compatible encoding.  Authors should use UTF-8. Conformance checkers may advise authors against using legacy encodings. [ENCODING] Authoring tools should default to using UTF-8 for newly-created documents. [ENCODING] Authors must not use encodings that are not defined in the WHATWG Encoding standard. Additionally, authors should not use ISO-2022-JP. [ENCODING] Some encodings that are not defined in the WHATWG Encoding standard use bytes in the range 0x20 to 0x7E, inclusive, to encode characters other than the corresponding characters in the range U+0020 to U+007E, inclusive, and represent a potential security vulnerability: A user agent might end up interpreting supposedly benign plain text content as HTML tags and JavaScript.  Using non-UTF-8 encodings can have unexpected results on form submission and URL encodings, which use the document’s character encoding by default.  In XHTML, the XML declaration should be used for inline character encoding information, if necessary.  In HTML, to declare that the character encoding is UTF-8, the author could include the following markup near the top of the document (in the head element): <meta charset="utf-8"> In XML, the XML declaration would be used instead, at the very top of the markup: <?xml version="1.0" encoding="utf-8"?> 4.2.6. The style element Categories: Metadata content.  Contexts in which this element can be used: Where metadata content is expected.  In a noscript element that is a child of a head element.  Content model: Depends on the value of the type attribute, but must match requirements described in prose below.  Tag omission in text/html: Neither tag is omissible.  Content attributes: Global attributes media — Applicable media nonce - Cryptographic nonce used in Content Security Policy checks [CSP3] type — Type of embedded resource Also, the title attribute has special semantics on this element: Alternative style sheet set name.  Allowed ARIA role attribute values: None Allowed ARIA state and property attributes: Global aria-* attributes DOM interface: interface HTMLStyleElement : HTMLElement { attribute DOMString media; attribute DOMString nonce; attribute DOMString type; }; HTMLStyleElement implements LinkStyle; There are no known native implementations of blocking the style element based on CSP3 directives. Therefore this feature should not be relied upon.  The style element allows authors to embed style information in their documents. The style element is one of several inputs to the styling processing model. The element does not represent content for the user.  The type attribute gives the styling language. If the attribute is present, its value must be a valid mime type that designates a styling language. The charset parameter must not be specified. The default value for the type attribute, which is used if the attribute is absent, is "text/css". [RFC2318] When examining types to determine if they support the language, user agents must not ignore unknown MIME parameters — types with unknown parameters must be assumed to be unsupported. The charset parameter must be treated as an unknown parameter for the purpose of comparing MIME types here.  The media attribute says which media the styles apply to. The value must be a valid media query list. The user agent must apply the styles when the media attribute’s value matches the environment and the other relevant conditions apply, and must not apply them otherwise.  The styles might be further limited in scope, e.g., in CSS with the use of @media blocks. This specification does not override such further restrictions or requirements.  The default, if the media attribute is omitted, is "all", meaning that by default styles apply to all media.  A style element is restricted to appearing in the head of the document.  The nonce attribute represents a cryptographic nonce ("number used once") which can be used by Content Security Policy to determine whether or not the style specified by an element will be applied to the document. The value is text. [CSP3] The title attribute on style elements defines alternative style sheet sets. If the style element has no title attribute, then it has no title; the title attribute of ancestors does not apply to the style element. [CSSOM] The title attribute on style elements, like the title attribute on link elements, differs from the global title attribute in that a style block without a title does not inherit the title of the parent element: it merely has no title.  The textContent of a style element must match the style production in the following ABNF, the character set for which is Unicode. [ABNF] style         = no-c-start *( c-start no-c-end c-end no-c-start ) no-c-start    = < any string that doesn’t contain a substring that matches c-start > c-start       = "<!--" no-c-end      = < any string that doesn’t contain a substring that matches c-end > c-end         = "-->" The user agent must run the update a style block algorithm that applies for the style sheet language specified by the style element’s type attribute, passing it the element’s style data, whenever one of the following conditions occur: the element is popped off the stack of open elements of an HTML parser or XML parser, the element is not on the stack of open elements of an HTML parser or XML parser, and it is inserted into a document or removed from a document, the element is not on the stack of open elements of an HTML parser or XML parser, and one of its child nodes is modified by a script, For styling languages that consist of pure text (as opposed to XML), a style element’s style data is the concatenation of the contents of all the Text nodes that are children of the style element (not any other nodes such as comments or elements), in tree order. For XML-based styling languages, the style data consists of all the child nodes of the style element.  The update a style block algorithm for CSS (text/css) is as follows: Let element be the style element.  If element has an associated CSS style sheet, remove the CSS style sheet in question.  If element is not in a Document, then abort these steps.  If the Should element’s inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the style element, "style", and the style element’s style data, then abort these steps. [CSP3] create a CSS style sheet with the following properties: type text/css owner node element media The media attribute of element.  This is a reference to the (possibly absent at this time) attribute, rather than a copy of the attribute’s current value. The CSSOM specification defines what happens when the attribute is dynamically set, changed, or removed.  title The title attribute of element.  Again, this is a reference to the attribute.  alternate flag Unset.  origin-clean flag Set.  parent CSS style sheet owner CSS rule null disabled flag Left at its default value.  CSS rules Left uninitialized.  This specification does not define any other styling language’s update a style block algorithm.  Once the attempts to obtain the style sheet’s critical subresources, if any, are complete, or, if the style sheet has no critical subresources, once the style sheet has been parsed and processed, the user agent must, if the loads were successful or there were none, queue a task to fire a simple event named load at the style element, or, if one of the style sheet’s critical subresources failed to completely load for any reason (e.g., DNS error, HTTP 404 response, a connection being prematurely closed, unsupported Content-Type), queue a task to fire a simple event named error at the style element. Non-network errors in processing the style sheet or its subresources (e.g., CSS parse errors, PNG decoding errors) are not failures for the purposes of this paragraph.  The task source for these tasks is the DOM manipulation task source.  The element must delay the load event of the element’s node document until all the attempts to obtain the style sheet’s critical subresources, if any, are complete.  This specification does not specify a style system, but CSS is expected to be supported by most Web browsers. [CSS-2015] The media, nonce, and type IDL attributes must reflect the respective content attributes of the same name.  The LinkStyle interface is also implemented by this element. [CSSOM] The following document has its stress emphasis styled as bright red text rather than italics text, while leaving titles of works and Latin words in their default italics. It shows how using appropriate elements enables easier restyling of documents.  <!DOCTYPE html><html> <head> <title>My favorite book</title> <style> body { color: black; background: white; } em { font-style: normal; color: red; } </style> </head> <body> <p>My <em>favorite</em> book of all time has <em>got</em> to be <cite>A Cat’s Life</cite>. It is a book by P. Rahmel that talks about the <i lang="la">Felis Catus</i> in modern human society.</p> </body> </html> 4.2.7. Interactions of styling and scripting Style sheets, whether added by a link element, a style element, an <?xml-stylesheet?> PI, an HTTP Link header, or some other mechanism, have a style sheet ready flag, which is initially unset.  When a style sheet is ready to be applied, its style sheet ready flag must be set. If the style sheet referenced no other resources (e.g., it was an internal style sheet given by a style element with no @import rules), then the style rules must be immediately made available to script; otherwise, the style rules must only be made available to script once the event loop reaches its update the rendering step.  A style sheet in the context of the Document of an HTML parser or XML parser is said to be a style sheet that is blocking scripts if the element was created by that Document"s parser, and the element is either a style element or a link element that was an external resource link when the element was created by the parser, and the element’s style sheet was enabled when the element was created by the parser, and the element’s style sheet ready flag is not yet set, and, the last time the event loop reached step 1, the element was in that Document, and the user agent hasn’t given up on that particular style sheet yet. A user agent may give up on a style sheet at any time.  Giving up on a style sheet before the style sheet loads, if the style sheet eventually does still load, means that the script might end up operating with incorrect information. For example, if a style sheet sets the color of an element to green, but a script that inspects the resulting style is executed before the sheet is loaded, the script will find that the element is black (or whatever the default color is), and might thus make poor choices (e.g., deciding to use black as the color elsewhere on the page, instead of green). Implementors have to balance the likelihood of a script using incorrect information with the performance impact of doing nothing while waiting for a slow network request to finish.  A Document has a style sheet that is blocking scripts if there is either a style sheet that is blocking scripts in the context of that Document, or if that Document is in a browsing context that has a parent browsing context, and the active document of that parent browsing context itself has a style sheet that is blocking scripts.  A Document has no style sheet that is blocking scripts if it does not have a style sheet that is blocking scripts as defined in the previous paragraph.← 4 The elements of HTML — Table of contents — 4.3 Sections →↑→W3C HTML 5.1 W3C Recommendation, 1 November 2016← 4.2 Document metadata — Table of contents — 4.4 Grouping content →Table of Contents 4.3Sections 4.3.1The body element 4.3.2The article element 4.3.3The section element 4.3.4The nav element 4.3.5The aside element 4.3.6 The h1, h2, h3, h4, h5, and h6 elements 4.3.7The header element 4.3.8The footer element 4.3.9The address element 4.3.10Headings and sections 4.3.10.1Creating an outline 4.3.11Usage summary 4.3.11.1Article or section?  4.3. Sections 4.3.1. The body element Categories: Sectioning root.  Contexts in which this element can be used: As the second element in an html element.  Content model: Flow content.  Tag omission in text/html: A body element’s start tag may be omitted if the element is empty, or if the first thing inside the body element is not a space character or a comment, except if the first thing inside the body element is a meta, link, script, style, or template element.  A body element’s end tag may be omitted if the body element is not immediately followed by a comment.  Content attributes: Global attributes onafterprint onbeforeprint onbeforeunload onhashchange onlanguagechange onmessage onoffline ononline onpagehide onpageshow onpopstate onrejectionhandled onstorage onunhandledrejection onunload Allowed ARIA role attribute values: document role (default - do not set), application.  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  DOM interface: interface HTMLBodyElement : HTMLElement { }; HTMLBodyElement implements WindowEventHandlers; The body element represents the content of the document.  In conforming documents, there is only one body element. The document.body IDL attribute provides scripts with easy access to a document’s body element.  Some DOM operations (for example, parts of the drag and drop model) are defined in terms of "the body element". This refers to a particular element in the DOM, as per the definition of the term, and not any arbitrary body element.  The body element exposes as event handler content attributes a number of the event handlers of the Window object. It also mirrors their event handler IDL attributes.  The onblur, onerror, onfocus, onload, onresize, and onscroll event handlers of the Window object, exposed on the body element, replace the generic event handlers with the same names normally supported by html elements.  Thus, for example, a bubbling error event dispatched on a child of the body element of a Document would first trigger the onerror event handler content attributes of that element, then that of the root html element, and only then would it trigger the onerror event handler content attribute on the body element. This is because the event would bubble from the target, to the body, to the html, to the Document, to the Window, and the event handler on the body is watching the Window not the body. A regular event listener attached to the body using addEventListener(), however, would be run when the event bubbled through the body and not when it reaches the Window object.  This page updates an indicator to show whether or not the user is online: <!DOCTYPE HTML> <html> <head> <title>Online or offline?</title> <script> function update(online) { document.getElementById("status").textContent = online ? "Online" : "Offline"; } </script> </head> <body ononline="update(true)" onoffline="update(false)" onload="update(navigator.onLine)"> <p>You are: <span id="status">(Unknown)</span></p> </body> </html> 4.3.2. The article element Categories: Flow content, but with no main element descendants.  Sectioning content.  Palpable content.  Contexts in which this element can be used: Where flow content is expected.  Content model: Flow content.  Tag omission in text/html: Neither tag is omissible Content attributes: Global attributes Allowed ARIA role attribute values: article (default - do not set), application, document or main.  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  DOM interface: Uses HTMLElement.  The article element represents a complete, or self-contained, composition in a document, page, application, or site. This could be a magazine, newspaper, technical or scholarly article, an essay or report, a blog or other social media post.  A general rule is that the article element is appropriate only if the element’s contents would be listed explicitly in the document’s outline. Each article should be identified, typically by including a heading(h1-h6 element) as a child of the article element.  Assistive Technology may convey the semantics of the article to users. This information can provide a hint to users as to the type of content. For example the role of the element, which in this case matches the element name "article", can be announced by screen reader software when a user navigates to an article element. User Agents may also provide methods to navigate to article elements.  When article elements are nested, the inner article elements represent articles that are in principle related to the contents of the outer article. For instance, a blog entry on a site could consist of summaries of other blog entries in article elements nested within the article element for the blog entry.  Author information associated with an article element (q.v. the address element) does not apply to nested article elements.  The following is an example of a blog post extract, marked up using the article element: <article> <header> <h2><a href="https://herbert.io">Short note on wearing shorts</a></h2> <p>Posted on Wednesday, 10 February 2016 by Patrick Lauke.  <a href="https://herbert.io/short-note/#comments">6 comments</a></p> </header> <p>A fellow traveller posed an interesting question: Why do you wear shorts rather than longs? The person was wearing culottes as the time, so I considered the question equivocal in nature, but I attempted to provide an honest answer despite the dubiousness of the questioner’s dress.</p> <p>The short answer is that I enjoy wearing shorts, the long answer is...</p> <p><a href="https://herbert.io/short-note/">Continue reading: Short note on wearing shorts</a></p> </article> The schema.org vocabulary can be used to provide more granular information about the type of article, using the CreativeWork - Article subtypes, other information such as the publication date for the article can also be provided.  This example shows a blog post using the article element, with some schema.org annotations: <article itemscope itemtype="https://schema.org/BlogPosting"> <header> <h2 itemprop="headline">The Very First Rule of Life</h2> <p><time itemprop="datePublished" datetime="2016-02-28">3 days ago</time></p> </header> <p>If there’s a microphone anywhere near you, assume it’s hot and sending whatever you’re saying to the world. Seriously.</p> <p>...</p> <footer> <a itemprop="discussionUrl" href="?comments=1">Show comments...</a> </footer> </article> Here is that same blog post, but showing some of the comments: <article itemscope itemtype="https://schema.org/BlogPosting">  <header> <h2 itemprop="headline">The Very First Rule of Life</h2> <p><time itemprop="datePublished" datetime="2009-10-09">3 days ago</time></p> </header> <p>If there’s a microphone anywhere near you, assume it’s hot and sending whatever you’re saying to the world. Seriously.</p> <p>...</p> <section> <h3>Comments</h3> <ol> <li itemprop="comment" itemscope itemtype="https://schema.org/UserComments" id="c1"> <p>Posted by: <span itemprop="creator" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">George Washington</span> </span></p> <p><time itemprop="commentTime" datetime="2009-10-10">15 minutes ago</time></p> <p>Yeah! Especially when talking about your lobbyist friends!</p> <li itemprop="comment" itemscope itemtype="https://schema.org/UserComments" id="c2"> <p>Posted by: <span itemprop="creator" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">George Hammond</span> </span></p> <p><time itemprop="commentTime" datetime="2009-10-10">5 minutes ago</time></p> <p>Hey, you have the same first name as me.</p> </li> </ol> </section> </article> Notice the use of an ordered list ol to organize the comments. Also note the comments are a subsection of the article, identified using a section element.  4.3.3. The section element Categories: Flow content.  Sectioning content.  Palpable content.  Contexts in which this element can be used: Where flow content is expected.  Content model: Flow content.  Tag omission in text/html: Neither tag is omissible Content attributes: Global attributes Allowed ARIA role attribute values: region role (default - do not set), alert, alertdialog, application, contentinfo, dialog, document, log, main, marquee, presentation, search or status.  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  DOM interface: Uses HTMLElement.  The section element represents a generic section of a document or application. A section, in this context, is a thematic grouping of content. Each section should be identified, typically by including a heading (h1-h6 element) as a child of the section element.  Examples of sections would be chapters, the various tabbed pages in a tabbed dialog box, or the numbered sections of a thesis. A Web site’s home page could be split into sections for an introduction, news items, and contact information.  Authors are encouraged to use the article element instead of the section element when the content is complete, or self-contained, composition.  The section element is not a generic container element. When an element is needed only for styling purposes or as a convenience for scripting, authors are encouraged to use the div element instead. A general rule is that the section element is appropriate only if the element’s contents would be listed explicitly in the document’s outline.  Assistive Technology may convey the semantics of the section to users when the element has an explicit label. This information can provide a hint to users as to the type of content. For example the role of the element, which in this case is "region", can be announced by screen reader software when a user navigates to an section element. User Agents may also provide methods to navigate to section elements.  In the following example, we see an article (part of a larger Web page) about apples, containing two short sections.  The section has an aria-label attribute providing a brief description of the contents. Assistive technology may convey the region role along with the aria-label value as a hint to users.  <article> <header> <h2>Apples</h2> <p>Tasty, delicious fruit!</p> </header> <p>The apple is the pomaceous fruit of the apple tree.</p> <section aria-label="Red apples."> <h3>Red Delicious</h3> <p>These bright red apples are the most common found in many supermarkets.</p> </section> <section aria-label="Green apples."> <h3>Granny Smith</h3> <p>These juicy, green apples make a great filling for apple pies.</p> </section> </article> Here is a graduation program with two sections, one for the list of people graduating, and one for the description of the ceremony. (The markup in this example features an uncommon style sometimes used to minimize the amount of inter-element whitespace.) <!DOCTYPE Html> <html ><head ><title >Graduation Ceremony Summer 2022</title ></head ><body ><h1 >Graduation</h1 ><section ><h2 >Ceremony</h2 ><p >Opening Procession</p ><p >Speech by Validactorian</p ><p >Speech by Class President</p ><p >Presentation of Diplomas</p ><p >Closing Speech by Headmaster</p ></section ><section ><h2 >Graduates</h2 ><ul ><li >Molly Carpenter</li ><li >Anastasia Luccio</li ><li >Ebenezar McCoy</li ><li >Karrin Murphy</li ><li >Thomas Raith</li ><li >Susan Rodriguez</li ></ul ></section ></body ></html> In this example, a book author has marked up some sections as chapters and some as appendices, and uses CSS to style the headers in these two classes of section differently. The whole book is wrapped in an article element as part of an even larger document containing other books.  <style> section { border: double medium; margin: 2em; } section.chapter h3 { font: 2em Roboto, Helvetica Neue, sans-serif; } section.appendix h3 { font: small-caps 2em Roboto, Helvetica Neue, sans-serif; } </style> ...  <article class="book"> <header> <h2>My Book</h2> <p>A sample with not much content</p> <p><small>Published by Dummy Publicorp Ltd.</small></p> </header> <section class="chapter"> <h3>My First Chapter</h3> <p>This is the first of my chapters. It doesn’t say much.</p> <p>But it has two paragraphs!</p> </section> <section class="chapter"> <h3>It Continues: The Second Chapter</h3> <p>Bla dee bla, dee bla dee bla. Boom.</p> </section> <section class="chapter"> <h3>Chapter Three: A Further Example</h3> <p>It’s not like a battle between brightness and earthtones would go unnoticed.</p> <p>But it might ruin my story.</p> </section> <section class="appendix"> <h3>Appendix A: Overview of Examples</h3> <p>These are demonstrations.</p> </section> <section class="appendix"> <h3>Appendix B: Some Closing Remarks</h3> <p>Hopefully this long example shows that you <em>can</em> style sections, so long as they are used to indicate actual sections.</p> </section> </article> 4.3.4. The nav element Categories: Flow content.  Sectioning content.  Palpable content.  Contexts in which this element can be used: Where flow content is expected.  Content model: Flow content, but with no main element descendants.  Tag omission in text/html: Neither tag is omissible Content attributes: Global attributes Allowed ARIA role attribute values: navigation role (default - do not set) or presentation.  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  DOM interface: Uses HTMLElement.  The nav element represents a section of a page that links to other pages or to parts within the page: a section with navigation links.  Assistive Technology may convey the semantics of the nav to users. This information can provide a hint to users as to the type of content. For example the role of the element, which in this case is "navigation", can be announced by screen reader software when a user navigates to an nav element. User Agents may also provide methods to navigate to nav elements.  In cases where the content of a nav element represents a list of items, use list markup to aid understanding and navigation.  Not all groups of links on a page need to be in a nav element — the element is primarily intended for sections that consist of major navigation blocks. In particular, it is common for footers to have a short list of links to various pages of a site, such as the terms of service, the home page, and a copyright page. The footer element alone is sufficient for such cases; while a nav element can be used in such cases, it is usually unnecessary.  User agents (such as screen readers) that are targeted at users who can benefit from navigation information being omitted in the initial rendering, or who can benefit from navigation information being immediately available, can use this element as a way to determine what content on the page to initially skip or provide on request (or both).  In the following example, there are two nav elements, one for primary navigation around the site, and one for secondary navigation around the page itself.  <body> <h1>The Wiki Center Of Exampland</h1> <nav> <ul> <li><a href="/">Home</a></li> <li><a href="/events">Current Events</a></li> ...more...  </ul> </nav> <article> <header> <h2>Demos in Exampland</h2> <p>Written by A. N. Other.</p> </header> <nav> <ul> <li><a href="#public">Public demonstrations</a></li> <li><a href="#destroy">Demolitions</a></li> ...more...  </ul> </nav> <div> <section id="public"> <h2>Public demonstrations</h2> <p>...more...</p> </section> <section id="destroy"> <h2>Demolitions</h2> <p>...more...</p> </section> ...more...  </div> <footer> <p><a href="?edit">Edit</a> | <a href="?delete">Delete</a> | <a href="?Rename">Rename</a></p> </footer> </article> <footer> <p><small>© copyright 1998 Exampland Emperor</small></p> </footer> </body> In the following example, the page has several places where links are present, but only one of those places is considered a navigation section.  <body typeof="schema:Blog"> <header> <h1>Wake up sheeple!</h1> <p><a href="news.html">News</a> - <a href="blog.html">Blog</a> - <a href="forums.html">Forums</a></p> <p>Last Modified: <span property="schema:dateModified">2009-04-01</span></p> <nav> <h2>Navigation</h2> <ul> <li><a href="articles.html">Index of all articles</a></li> <li><a href="today.html">Things sheeple need to wake up for today</a></li> <li><a href="successes.html">Sheeple we have managed to wake</a></li> </ul> </nav> </header> <main> <article property="schema:blogPosts" typeof="schema:BlogPosting"> <header> <h2 property="schema:headline">My Day at the Beach</h2> </header> <main property="schema:articleBody"> <p>Today I went to the beach and had a lot of fun.</p> ...more content...  </main> <footer> <p>Posted <time property="schema:datePublished" datetime="2009-10-10">Thursday</time>.</p> </footer> </article> ...more blog posts...  </main> <footer> <p>Copyright © <span property="schema:copyrightYear">2010</span> <span property="schema:copyrightHolder">The Example Company</span> </p> <p><a href="about.html">About</a> - <a href="policy.html">Privacy Policy</a> - <a href="contact.html">Contact Us</a></p> </footer> </body> Notice the main element being used to wrap the main content of the page. In this case, all content other than the page header and footer.  You can also see microdata annotations in the above example that use the schema.org vocabulary to provide the publication date and other metadata about the blog post.  A nav element doesn’t have to contain a list, it can contain other kinds of content as well. In this navigation block, links are provided in prose: <nav> <h2>Navigation</h2> <p>You are on my home page. To the north lies <a href="/blog">my blog</a>, from whence the sounds of battle can be heard. To the east you can see a large mountain, upon which many <a href="/school">school papers</a> are littered. Far up thus mountain you can spy a little figure who appears to be me, desperately scribbling a <a href="/school/thesis">thesis</a>.</p> <p>To the west are several exits. One fun-looking exit is labeled <a href="https://games.example.com/">"games"</a>. Another more boring-looking exit is labeled <a href="https://isp.example.net/">ISP™</a>.</p> <p>To the south lies a dark and dank <a href="/about">contacts page</a>. Cobwebs cover its disused entrance, and at one point you see a rat run quickly out of the page.</p> </nav> In this example, nav is used in an e-mail application, to let the user switch folders: <p><input type=button value="Compose" onclick="compose()"></p> <nav> <h2>Folders</h2> <ul> <li> <a href="/inbox" onclick="return openFolder(this.href)">Inbox</a> <span class=count></span> <li> <a href="/sent" onclick="return openFolder(this.href)">Sent</a> <li> <a href="/drafts" onclick="return openFolder(this.href)">Drafts</a> <li> <a href="/trash" onclick="return openFolder(this.href)">Trash</a> <li> <a href="/customers" onclick="return openFolder(this.href)">Customers</a> </ul> </nav> 4.3.5. The aside element Categories: Flow content.  Sectioning content.  Palpable content.  Contexts in which this element can be used: Where flow content is expected.  Content model: Flow content, but with no main element descendants.  Tag omission in text/html: Neither tag is omissible Content attributes: Global attributes Allowed ARIA role attribute values: complementary role (default - do not set), note, search or presentation.  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  DOM interface: Uses HTMLElement.  The aside element represents a section of a page that consists of content that is tangentially related to the content of the parenting sectioning content, and which could be considered separate from that content. Such sections are often represented as sidebars in printed typography.  The element can be used for typographical effects like pull quotes or sidebars, for advertising, for groups of nav elements, and for other content that is considered separate from the main content of the nearest ancestor sectioning content.  Assistive Technology may convey the semantics of the aside to users. This information can provide a hint to users as to the type of content. For example the role of the element, which in this case is "complementary", can be announced by screen reader software when a user navigates to an aside element. User Agents may also provide methods to navigate to aside elements.  It’s not appropriate to use the aside element just for parentheticals, since those are part of the main flow of the document.  The following example shows how an aside is used to mark up background material on Switzerland in a much longer news story on Europe.  <aside> <h2>Switzerland</h2> <p>Switzerland, a land-locked country in the middle of geographic Europe, has not joined the geopolitical European Union, though it is a signatory to a number of European treaties.</p> </aside> The following example shows how an aside is used to mark up a pull quote in a longer article.  ...  <p>He later joined a large company, continuing on the same work.  <q>I love my job. People ask me what I do for fun when I’m not at work. But I’m paid to do my hobby, so I never know what to answer. Some people wonder what they would do if they didn’t have to work... but I know what I would do, because I was unemployed for a year, and I filled that time doing exactly what I do now.</q></p> <aside> <q> People ask me what I do for fun when I’m not at work. But I’m paid to do my hobby, so I never know what to answer. </q> </aside> <p>Of course his work — or should that be hobby? —      isn’t his only passion. He also enjoys other pleasures.</p> ...  The following extract shows how aside can be used for blogrolls and other side content on a blog: <body> <header> <h1>My wonderful blog</h1> <p>My tagline</p> </header> <aside> <!-- this aside contains two sections that are tangentially related to the page, namely, links to other blogs, and links to blog posts from this blog --> <nav> <h2>My blogroll</h2> <ul> <li><a href="https://blog.example.com/">Example Blog</a> </ul> </nav> <nav> <h2>Archives</h2> <ol reversed> <li><a href="/last-post">My last post</a> <li><a href="/first-post">My first post</a> </ol> </nav> </aside> <aside> <!-- this aside is tangentially related to the page also, it contains twitter messages from the blog author --> <h2>Twitter Feed</h2> <blockquote cite="https://twitter.example.net/t31351234"> I’m on vacation, writing my blog.  </blockquote> <blockquote cite="https://twitter.example.net/t31219752"> I’m going to go on vacation soon.  </blockquote> </aside> <article> <!-- this is a blog post --> <h2>My last post</h2> <p>This is my last post.</p> <footer> <p><a href="/last-post" rel=bookmark>Permalink</a> </footer> </article> <article> <!-- this is also a blog post --> <h2>My first post</h2> <p>This is my first post.</p> <aside> <!-- this aside is about the blog post, since it’s inside the <article> element; it would be wrong, for instance, to put the blogroll here, since the blogroll isn’t really related to this post specifically, only to the page as a whole --> <h1>Posting</h1> <p>While I’m thinking about it, I wanted to say something about posting. Posting is fun!</p> </aside> <footer> <p><a href="/first-post" rel=bookmark>Permalink</a> </footer> </article> <footer> <nav> <a href="/archives">Archives</a> —      <a href="/about">About me</a> —      <a href="/copyright">Copyright</a> </nav> </footer> </body> 4.3.6. The h1, h2, h3, h4, h5, and h6 elements Categories: Flow content.  Heading content.  Palpable content.  Contexts in which this element can be used: Where flow content is expected.  Content model: Phrasing content.  Tag omission in text/html: Neither tag is omissible Content attributes: Global attributes Allowed ARIA role attribute values: heading role (default - do not set), tab or presentation.  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  DOM interface: interface HTMLHeadingElement : HTMLElement {}; These elements represent headings for their sections.  These elements have a rank given by the number in their name. The h1 element has the highest rank, the h6 element has the lowest rank, and two elements with the same name have equal rank.  Use the rank of heading elements to create the document outline.  The following code shows how to mark up a document outline with six levels of headings.  <body> <h1>top level heading</h1> <section><h2>2nd level heading</h2> <section><h3>3nd level heading</h3> <section><h4>4th level heading</h4> <section><h5>5th level heading</h5> <section><h6>6th level heading</h6> </section> </section> </section> </section> </section> </body> The document outline would be the same if the section elements were not used.  h2–h6 elements must not be used to markup subheadings, subtitles, alternative titles and taglines unless intended to be the heading for a new section or subsection. Instead use the markup patterns in the §4.13 Common idioms without dedicated elements section of the specification.  Assistive technology often announces the presence and level of a heading to users, as a hint to understand the structure of a document and construct a "mental model" of its outline. For example the role of the element, which in this case is "heading" and the heading level "1" to "6", can be announced by screen reader software when a user navigates to an h1–h6 element. User Agents may also provide methods to navigate to h1–h6 elements.  As far as their respective document outlines (their heading and section structures) are concerned, these two snippets are semantically equivalent: <body> <h1>Let’s call it a draw(ing surface)</h1> <h2>Diving in</h2> <h2>Simple shapes</h2> <h2>Canvas coordinates</h2> <h3>Canvas coordinates diagram</h3> <h2>Paths</h2> </body> <body> <h1>Let’s call it a draw(ing surface)</h1> <section> <h2>Diving in</h2> </section> <section> <h2>Simple shapes</h2> </section> <section> <h2>Canvas coordinates</h2> <section> <h3>Canvas coordinates diagram</h3> </section> </section> <section> <h2>Paths</h2> </section> </body> Authors might prefer the former style for its terseness, or the latter style for its convenience in the face of heavy editing; which is best is purely an issue of preferred authoring style.  The two styles can be combined, for compatibility with legacy tools while still future-proofing for when that compatibility is no longer needed.  The semantics and meaning of the h1–h6 elements are further detailed in the section on §4.3.10 Headings and sections.  4.3.7. The header element Categories: Flow content.  Palpable content.  Contexts in which this element can be used: Where flow content is expected.  Content model: Flow content, but with no main element descendants, or header, footer elements that are not descendants of sectioning content which is a descendant of the header.  Tag omission in text/html: Neither tag is omissible Content attributes: Global attributes Allowed ARIA role attribute values: banner role (default - do not set) or presentation.  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  DOM interface: Uses HTMLElement.  The header element represents introductory content for its nearest ancestor sectioning content or sectioning root element. A header typically contains a group of introductory or navigational aids.  When the nearest ancestor sectioning content or sectioning root element is the body element, then it applies to the whole page.  A header element is intended to usually contain the section’s heading (an h1–h6 element), but this is not required. The header element can also be used to wrap a section’s table of contents, a search form, or any relevant logos.  Assistive Technology may convey the semantics of the header to users when the nearest ancestor sectioning content or sectioning root element is the body element. This information can provide a hint to users as to the type of content. For example the role of the element, which in this case is "banner", can be announced by screen reader software when a user navigates to an header element that is scoped to the body element. User Agents may also provide methods to navigate to header elements scoped to the body element.  Here are some sample headers. This first one is for a game: <header> <p>Welcome to...</p> <h1>Voidwars!</h1> </header> The following snippet shows how the element can be used to mark up a specification’s header: <header> <h1>Scalable Vector Graphics (SVG) 1.2</h1> <p>W3C Working Draft 27 October 2004</p> <dl> <dt>This version:</dt> <dd><a href="https://www.w3.org/TR/2004/WD-SVG12-20041027/">https://www.w3.org/TR/2004/WD-SVG12-20041027/</a></dd> <dt>Previous version:</dt> <dd><a href="https://www.w3.org/TR/2004/WD-SVG12-20040510/">https://www.w3.org/TR/2004/WD-SVG12-20040510/</a></dd> <dt>Latest version of SVG 1.2:</dt> <dd><a href="https://www.w3.org/TR/SVG12/">https://www.w3.org/TR/SVG12/</a></dd> <dt>Latest SVG Recommendation:</dt> <dd><a href="https://www.w3.org/TR/SVG/">https://www.w3.org/TR/SVG/</a></dd> <dt>Editor:</dt> <dd>Dean Jackson, W3C, <a href="mailto:dean@w3.org">dean@w3.org</a></dd> <dt>Authors:</dt> <dd>See <a href="#authors">Author List</a></dd> </dl> <p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notic ...  </header> The header element is not sectioning content; it doesn’t introduce a new section.  In this example, the page has a page heading given by the h1 element, and two subsections whose headings are given by h2 elements. The content after the header element is still part of the last subsection started in the header element, because the header element doesn’t take part in the outline algorithm.  <body> <header> <h1>Little Green Guys With Guns</h1> <nav> <ul> <li><a href="/games">Games</a> <li><a href="/forum">Forum</a> <li><a href="/download">Download</a> </ul> </nav> <h2>Important News</h2> <!-- this starts a second subsection --> <!-- this is part of the subsection entitled "Important News" --> <p>To play today’s games you will need to update your client.</p> <h2>Games</h2> <!-- this starts a third subsection --> </header> <p>You have three active games:</p> <!-- this is still part of the subsection entitled "Games" --> ...  For cases where an developer wants to nest a header or footer within another header: The header element can only contain a header or footer if they are themselves contained within sectioning content.  In this example, the article has a header which contains an aside which itself contains a header. This is conforming as the descendant header is contained within the aside element.  <article> <header> <h1>Flexbox: The definitive guide</h1> <aside> <header> <h2>About the author: Wes McSilly</h2> <p><a href="./wes-mcsilly/">Contact him! (Why would you?)</a></p> </header> <p>Expert in nothing but Flexbox. Talented circus sideshow.</p> </aside> </header> <p><ins>The guide about Flexbox was supposed to be here, but it turned out Wes wasn’t a Flexbox expert either.</ins></p> </article> 4.3.8. The footer element Categories: Flow content.  Palpable content.  Contexts in which this element can be used: Where flow content is expected.  Content model: Flow content, but with no main element descendants, or header, footer elements that are not descendants of sectioning content which is a descendant of the footer.  Tag omission in text/html: Neither tag is omissible Content attributes: Global attributes Allowed ARIA role attribute values: contentinfo role (default - do not set) or presentation.  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  DOM interface: Uses HTMLElement.  The footer element represents a footer for its nearest ancestor sectioning content or sectioning root element. A footer typically contains information about its section such as who wrote it, links to related documents, copyright data, and the like.  When the footer element contains entire sections, they represent appendices, indexes, long colophons, verbose license agreements, and other such content.  Assistive Technology may convey the semantics of the footer to users when the nearest ancestor sectioning content or sectioning root element is the body element. This information can provide a hint to users as to the type of content. For example the role of the element, which in this case is "content information", can be announced by screen reader software when a user navigates to an footer element that is scoped to the body element. User Agents may also provide methods to navigate to footer elements scoped to the body element.  Contact information for the author or editor of a section belongs in an address element, possibly itself inside a footer. Bylines and other information that could be suitable for both a header or a footer can be placed in either (or neither). The primary purpose of these elements is merely to help the author write self-explanatory markup that is easy to maintain and style; they are not intended to impose specific structures on authors.  Footers don’t necessarily have to appear at the end of a section, though they usually do.  When the nearest ancestor sectioning content or sectioning root element is the body element, then it applies to the whole page.  The footer element is not sectioning content; it doesn’t introduce a new section.  Here is a page with two footers, one at the top and one at the bottom, with the same content: <body> <footer><a href="../">Back to index...</a></footer> <div> <h1>Lorem ipsum</h1> <p>The ipsum of all lorems</p> </div> <p>A dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p> <footer><a href="../">Back to index...</a></footer> </body> Here is an example which shows the footer element being used both for a site-wide footer and for a section footer.  <!DOCTYPE HTML> <HTML><HEAD> <TITLE>The Ramblings of a Scientist</TITLE> <BODY> <h1>The Ramblings of a Scientist</h1> <MAIN> <ARTICLE> <H2>Episode 15</H2> <VIDEO SRC="/fm/015.ogv" CONTROLS PRELOAD> <P><A HREF="/fm/015.ogv">Download video</A>.</P> </VIDEO> <FOOTER> <!-- footer for article --> <P>Published <TIME DATETIME="2009-10-21T18:26-07:00">on 2009/10/21 at 6:26pm</TIME></P> </FOOTER> </ARTICLE> <ARTICLE> <H2>My Favorite Trains</H2> <P>I love my trains. My favorite train of all time is a Köf.</P> <P>It is fun to see them pull some coal cars because they look so dwarfed in comparison.</P> <FOOTER> <!-- footer for article --> <P>Published <TIME DATETIME="2009-09-15T14:54-07:00">on 2009/09/15 at 2:54pm</TIME></P> </FOOTER> </ARTICLE> </MAIN> <FOOTER> <!-- site wide footer --> <NAV> <P><A HREF="/credits.html">Credits</A> —      <A HREF="/tos.html">Terms of Service</A> —      <A HREF="/index.html">Blog Index</A></P> </NAV> <P>Copyright © 2009 Gordon Freeman</P> </FOOTER> </BODY> </HTML> Some site designs have what is sometimes referred to as "fat footers" — footers that contain a lot of material, including images, links to other articles, links to pages for sending feedback, special offers... in some ways, a whole "front page" in the footer.  This fragment shows the bottom of a page on a site with a "fat footer": ...  <footer> <nav> <section> <h2>Articles</h2> <p><img src="images/somersaults.jpeg" alt=""> Go to the gym with our somersaults class! Our teacher Jim takes you through the paces in this two-part article. <a href="articles/somersaults/1">Part 1</a> · <a href="articles/somersaults/2">Part 2</a></p> <p><img src="images/kindplus.jpeg"> Tired of walking on the edge of a clif<!-- sic -->? Our guest writer Lara shows you how to bumble your way through the bars. <a href="articles/kindplus/1">Read more...</a></p> <p><img src="images/crisps.jpeg"> The chips are down, now all that’s left is a potato. What can you do with it? <a href="articles/crisps/1">Read more...</a></p> </section> <ul> <li> <a href="/about">About us...</a> <li> <a href="/feedback">Send feedback!</a> <li> <a href="/sitemap">Sitemap</a> </ul> </nav> <p><small>Copyright © 2015 The Snacker —      <a href="/tos">Terms of Service</a></small></p> </footer> </body> 4.3.9. The address element Categories: Flow content.  Palpable content.  Contexts in which this element can be used: Where flow content is expected.  Content model: Flow content, but with no heading content descendants, no sectioning content descendants, and no header, footer, or address element descendants.  Tag omission in text/html: Neither tag is omissible Content attributes: Global attributes Allowed ARIA role attribute values: contentinfo role.  Allowed ARIA state and property attributes: Global aria-* attributes Any aria-* attributes applicable to the allowed roles.  DOM interface: Uses HTMLElement.  The address element represents the contact information for its nearest article or body element ancestor. If that is the body element, then the contact information applies to the document as a whole.  For example, a page at the W3C Web site related to HTML might include the following contact information: <ADDRESS> <A href="../People/Raggett/">Dave Raggett</A>, <A href="../People/Arnaud/">Arnaud Le Hors</A>, contact persons for the <A href="Activity">W3C HTML Activity</A> </ADDRESS> The address element must not be used to represent arbitrary addresses (e.g., postal addresses), unless those addresses are in fact the relevant contact information. (The p element is the appropriate element for marking up postal addresses in general.) The address element must not contain information other than contact information.  For example, the following is non-conforming use of the address element: <ADDRESS>Last Modified: 1999/12/24 23:37:50</ADDRESS> Typically, the address element would be included along with other information in a footer element.  The contact information for a node node is a collection of address elements defined by the first applicable entry from the following list: If node is an article element If node is a body element The contact information consists of all the address elements that have node as an ancestor and do not have another body or article element ancestor that is a descendant of node.  If node has an ancestor element that is an article element If node has an ancestor element that is a body element The contact information of node is the same as the contact information of the nearest article or body element ancestor, whichever is nearest.  If node’s node document has a body element The contact information of node is the same as the contact information of the body element of the Document.  Otherwise There is no contact information for node.  User agents may expose the contact information of a node to the user, or use it for other purposes, such as indexing sections based on the sections" contact information.  In this example the footer contains contact information and a copyright notice.  <footer> <address> For more details, contact <a href="mailto:js@example.com">John Smith</a>.  </address> <p><small>© copyright 2038 Example Corp.</small></p> </footer> 4.3.10. Headings and sections The h1–h6 elements are headings.  The first element of heading content in an element of sectioning content represents the heading for that section. Subsequent headings of equal or higher rank start new (implied) sections, headings of lower rank start implied subsections that are part of the previous one. In both cases, the element represents the heading of the implied section.  h1–h6 elements must not be used to markup subheadings, subtitles, alternative titles and taglines unless intended to be the heading for a new section or subsection. Instead use the markup patterns in the §4.13 Common idioms without dedicated elements section of the specification.  Certain elements are said to be sectioning roots, including blockquote and td elements. These elements can have their own outlines, but the sections and headings inside these elements do not contribute to the outlines of their ancestors.  blockquote body details fieldset figure td Sectioning content elements are always considered subsections of their nearest ancestor sectioning root or their nearest ancestor element of sectioning content, whichever is nearest, regardless of what implied sections other headings may have created.  For the following fragment: <body> <h1>Foo</h1> <h2>Bar</h2> <blockquote> <h3>Bla</h3> </blockquote> <p>Baz</p> <h2>Quux</h2> <section> <h3>Thud</h3> </section> <p>Grunt</p> </body> ...the structure would be: Foo (heading of explicit body section, containing the "Grunt" paragraph) Bar (heading starting implied section, containing a block quote and the "Baz" paragraph) Quux (heading starting implied section with no content other than the heading itself) Thud (heading of explicit section section) Notice how the section ends the earlier implicit section so that a later paragraph ("Grunt") is back at the top level.  Sections may contain headings of a rank equal to their section nesting level. Authors should use headings of the appropriate rank for the section’s nesting level.  Authors are also encouraged to explicitly wrap sections in elements of sectioning content, instead of relying on the implicit sections generated by having multiple headings in one element of sectioning content.  For example, the following is correct: <body> <h1>Apples</h1> <p>Apples are fruit.</p> <section> <h2>Taste</h2> <p>They taste lovely.</p> <h3>Sweet</h3> <p>Red apples are sweeter than green ones.</p> <h3>Color</h3> <p>Apples come in various colors.</p> </section> </body> However, the same document would be more clearly expressed as: <body> <h1>Apples</h1> <p>Apples are fruit.</p> <section> <h2>Taste</h2> <p>They taste lovely.</p> <section> <h3>Sweet</h3> <p>Red apples are sweeter than green ones.</p> </section> </section> <section> <h3>Color</h3> <p>Apples come in various colors.</p> </section> </body> Both of the documents above are semantically identical and would produce the same outline in compliant user agents.  4.3.10.1. Creating an outline There are currently no known native implementations of the outline algorithm in graphical browsers or assistive technology user agents, although the algorithm is implemented in other software such as conformance checkers and browser extensions. Therefore the outline algorithm cannot be relied upon to convey document structure to users. Authors should use heading rank (h1-h6) to convey document structure.  This section is non-normative This section defines an algorithm for creating an outline for a sectioning content element or a sectioning root element. It is defined in terms of a walk over the nodes of a DOM tree, in tree order, with each node being visited when it is entered and when it is exited during the walk.  The outline for a sectioning content element or a sectioning root element consists of a list of one or more potentially nested sections. The element for which an outline is created is said to be the outline’s owner.  A section is a container that corresponds to some nodes in the original DOM tree. Each section can have one heading associated with it, and can contain any number of further nested sections. The algorithm for the outline also associates each node in the DOM tree with a particular section and potentially a heading. (The sections in the outline aren’t section elements, though some may correspond to such elements — they are merely conceptual sections.) The following markup fragment: <body> <h1>A</h1> <p>B</p> <h2>C</h2> <p>D</p> <h2>E</h2> <p>F</p> </body> ...results in the following outline being created for the body node (and thus the entire document): Section created for body node. Associated with heading "A". Also associated with paragraph "B". Nested sections: Section implied for first h2 element. Associated with heading "C". Also associated with paragraph "D". No nested sections.  Section implied for second h2 element. Associated with heading "E". Also associated with paragraph "F". No nested sections.  The algorithm that must be followed during a walk of a DOM subtree rooted at a sectioning content element or a sectioning root element to determine that element’s outline is as follows: Let current outline target be null. (It holds the element whose outline is being created.) Let current section be null. (It holds a pointer to a section, so that elements in the DOM can all be associated with a section.) Create a stack to hold elements, which is used to handle nesting. Initialize this stack to empty.  Walk over the DOM in tree order, starting with the sectioning content element or sectioning root element at the root of the subtree for which an outline is to be created, and trigger the first relevant step below for each element as the walk enters and exits it.  When exiting an element, if that element is the element at the top of the stack The element being exited is a heading content element or an element with a hidden attribute.  Pop that element from the stack.  If the top of the stack is a heading content element or an element with a hidden attribute Do nothing.  When entering an element with a hidden attribute Push the element being entered onto the stack. (This causes the algorithm to skip that element and any descendants of the element.) When entering a sectioning content element Run these steps: If current outline target is not null, run these substeps: If the current section has no heading, create an implied heading and let that be the heading for the current section.  Push current outline target onto the stack.  Let current outline target be the element that is being entered.  Let current section be a newly created section for the current outline target element.  Associate current outline target with current section.  Let there be a new outline for the new current outline target, initialized with just the new current section as the only section in the outline.  When exiting a sectioning content element, if the stack is not empty Run these steps: If the current section has no heading, create an implied heading and let that be the heading for the current section.  Pop the top element from the stack, and let the current outline target be that element.  Let current section be the last section in the outline of the current outline target element.  Append the outline of the sectioning content element being exited to the current section. (This does not change which section is the last section in the outline.) When entering a sectioning root element Run these steps: If current outline target is not null, push current outline target onto the stack.  Let current outline target be the element that is being entered.  Let current outline target’s parent section be current section.  Let current section be a newly created section for the current outline target element.  Let there be a new outline for the new current outline target, initialized with just the new current section as the only section in the outline.  When exiting a sectioning root element, if the stack is not empty Run these steps: If the current section has no heading, create an implied heading and let that be the heading for the current section.  Let current section be current outline target’s parent section.  Pop the top element from the stack, and let the current outline target be that element.  When exiting a sectioning content element or a sectioning root element (when the stack is empty) The current outline target is the element being exited, and it is the sectioning content element or a sectioning root element at the root of the subtree for which an outline is being generated.  If the current section has no heading, create an implied heading and let that be the heading for the current section.  Skip to the next step in the overall set of steps. (The walk is over.) When entering a heading content element If the current section has no heading, let the element being entered be the heading for the current section.  Otherwise, if the element being entered has a rank equal to or higher than the heading of the last section of the outline of the current outline target, or if the heading of the last section of the outline of the current outline target is an implied heading, then create a new section and append it to the outline of the current outline target element, so that this new section is the new last section of that outline. Let current section be that new section. Let the element being entered be the new heading for the current section.  Otherwise, run these substeps: Let candidate section be current section.  Heading loop: If the element being entered has a rank lower than the rank of the heading of the candidate section, then create a new section, and append it to candidate section. (This does not change which section is the last section in the outline.) Let current section be this new section. Let the element being entered be the new heading for the current section. Abort these substeps.  Let new candidate section be the section that contains candidate section in the outline of current outline target.  Let candidate section be new candidate section.  Return to the step labeled heading loop.  Push the element being entered onto the stack. (This causes the algorithm to skip any descendants of the element.) Recall that h1 has the highest rank, and h6 has the lowest rank.  Otherwise Do nothing.  In addition, whenever the walk exits a node, after doing the steps above, if the node is not associated with a section yet, associate the node with the section current section.  Associate all non-element nodes that are in the subtree for which an outline is being created with the section with which their parent element is associated.  Associate all nodes in the subtree with the heading of the section with which they are associated, if any.  The tree of sections created by the algorithm above, or a proper subset thereof, must be used when generating document outlines, for example when generating tables of contents.  The outline created for the body element of a Document is the outline of the entire document.  When creating an interactive table of contents, entries should jump the user to the relevant sectioning content element, if the section was created for a real element in the original document, or to the relevant heading content element, if the section in the tree was generated for a heading in the above process.  Selecting the first section of the document therefore always takes the user to the top of the document, regardless of where the first heading in the body is to be found.  The outline depth of a heading content element associated with a section section is the number of sections that are ancestors of section in the outermost outline that section finds itself in when the outlines of its Document"s elements are created, plus 1. The outline depth of a heading content element not associated with a section is 1.  User agents should provide default headings for sections that do not have explicit section headings.  Consider the following snippet: <body> <nav> <p><a href="/">Home</a></p> </nav> <p>Hello world.</p> <aside> <p>My cat is cute.</p> </aside> </body> Although it contains no headings, this snippet has three sections: a document (the body) with two subsections (a nav and an aside). A user agent could present the outline as follows: Untitled document Navigation Sidebar These default headings ("Untitled document", "Navigation", "Sidebar") are not specified by this specification, and might vary with the user’s language, the page’s language, the user’s preferences, the user agent implementor’s preferences, etc.  The following JavaScript function shows how the tree walk could be implemented. The root argument is the root of the tree to walk (either a sectioning content element or a sectioning root element), and the enter and exit arguments are callbacks that are called with the nodes as they are entered and exited. [ECMA-262] function (root, enter, exit) { var node = root; start: while (node) { enter(node); if (node.firstChild) { node = node.firstChild; continue start; } while (node) { exit(node); if (node == root) { node = null; } else if (node.nextSibling) { node = node.nextSibling; continue start; } else { node = node.parentNode; } } } } 4.3.11. Usage summary This section is non-normative.  Element	Purpose Example body	<!DOCTYPE HTML> <html> <head> <title>Steve Hill’s Home Page</title> </head> <body> <p>Hard Trance is My Life.</p> </body> </html> article	<article> <img src="/tumblr_masqy2s5yn1rzfqbpo1_500.jpg" alt="Yellow smiley face with the caption "masif""> <p>My fave Masif tee so far!</p> <footer>Posted 2 days ago</footer> </article> <article> <img src="/tumblr_m9tf6wSr6W1rzfqbpo1_500.jpg" alt=""> <p>Happy 2nd birthday Masif Saturdays!!!</p> <footer>Posted 3 weeks ago</footer> </article> section	<h1>Biography</h1> <section> <h1>The facts</h1> <p>1500+ shows, 14+ countries</p> </section> <section> <h1>2010/2011 figures per year</h1> <p>100+ shows, 8+ countries</p> </section> nav	<nav> <ul> <li><a href="/">Home</a> <li><a href="/biog.html">Bio</a> <li><a href="/discog.html">Discog</a> </ul> </nav> aside	<h1>Music</h1> <p>As any burner can tell you, the event has a lot of trance.</p> <aside>You can buy the music we played at our <a href="buy.html">playlist page</a>.</aside> <p>This year we played a kind of trance that originated in Belgium, Germany, and the Netherlands in the mid 90s.</p> h1–h6	A section heading <h1>The Guide To Music On The Playa</h1> <h2>The Main Stage</h2> <p>If you want to play on a stage, you should bring one.</p> <h2>Amplified Music</h2> <p>Amplifiers up to 300W or 90dB are welcome.</p> header	<article> <header> <h1>Hard Trance is My Life</h1> <p>By DJ Steve Hill and Technikal</p> </header> <p>The album with the amusing punctuation has red artwork.</p> </article> footer	<article> <h1>Hard Trance is My Life</h1> <p>The album with the amusing punctuation has red artwork.</p> <footer> <p>Artists: DJ Steve Hill and Technikal</p> </footer> </article> address	<address> To book DJ Steve Hill and Technikal, contact our <a href="mailto:management@example.com">management</a>.  </address> 4.3.11.1. Article or section?  This section is non-normative.  A section forms part of something else. An article is its own thing. But how does one know which is which? Mostly the real answer is "it depends on author intent".  For example, one could imagine a book with a "Granny Smith" chapter that just said "These juicy, green apples make a great filling for apple pies."; that would be a section because there’d be lots of other chapters on (maybe) other kinds of apples.  On the other hand, one could imagine a tweet or tumblr post or newspaper classified ad that just said "Granny Smith. These juicy, green apples make a great filling for apple pies."; it would then be articles because that was the whole thing.  Comments on an article are not part of the article on which they are commenting, but are related, therefore may be contained in their own nested article.← 4.2 Document metadata — Table of contents — 4.4 Grouping content →';
