<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap-theme.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/github-markdown.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/page.css" />
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.min.js"></script>
    <style type="text/css">

    </style>

</head>
<body class="markdown-body">
    <div id="nav" class="row">
<a class="text-info pull-right" href="javascript:history.back()">Back</a>
    </div>

<h1> graph layout</h1>
<blockquote><p> 网络拓扑图布局算法研究</p></blockquote><h2> 一、综述</h2>
<h3> 1.1 参考资料</h3>
<p><code>Github</code>：</p>
<ol><li><a href="https://github.com/jacomyal/sigma.js">https://github.com/jacomyal/sigma.js</a></li>
<li><a href="https://github.com/anvaka/VivaGraphJS">https://github.com/anvaka/VivaGraphJS</a></li>
<li><a href="https://github.com/anvaka/ngraph.forcelayout">https://github.com/anvaka/ngraph.forcelayout</a></li>
<li><a href="https://github.com/dhotson/springy">https://github.com/dhotson/springy</a></li></ol>
<p><code>其他</code>：</p>
<ol><li>一种改进的可视化布局算法IGVA; 徐红云,陈志锋</li>
<li>VERVIEW OF ALGORITHMS FOR GRAPH DRAWING; Pajntar B.; <a href="http://ailab.ijs.si/dunja/SiKDD2006/Papers/Pajntar.pdf">http://ailab.ijs.si/dunja/SiKDD2006/Papers/Pajntar.pdf</a></li>
<li><a href="http://cs.brown.edu/~rt/gdhandbook/">http://cs.brown.edu/~rt/gdhandbook/</a></li>
<li><a href="http://www.ogdf.net/doku.php">http://www.ogdf.net/doku.php</a></li></ol>
<h3> 1.2 评价标准</h3>
<p>评价标准：<code>性能</code>、<code>美观</code>并重</p>
<p><code>美学标准</code>：</p>
<ol><li><code>边交叉</code>数量最小原则。</li>
<li><code>直线边</code>原则。曲边会增加图的复杂度。</li>
<li><code>邻接点</code>空间位置接近原则。这样可以减小边的长度。</li>
<li><code>边平衡</code>布局原则。以相同节点为出发点的多条边应尽量以该节点为中心平衡布局。</li>
<li>节点<code>层次</code>布局原则。引入层的概念，将节点尽量布局在水平或竖直的不同层上。</li></ol>
<script src="http://258i.com/static/build/sigma/sigma.min.js">

</script>
<script src="http://258i.com/static/build/sigma/plugins/sigma.plugins.animate.min.js">

</script>
<script src="http://258i.com/static/build/sigma/plugins/sigma.layout.noverlap.min.js">

</script>
<script src="http://258i.com/static/build/sigma/plugins/sigma.layout.forceAtlas2.min.js">

</script>
<script src="http://258i.com/static/bower_components/vivagraphjs/dist/vivagraph.min.js">

</script>
<script src="http://258i.com/static/bower_components/lodash/dist/lodash.min.js">

</script>

<script src="./js/network.js">

</script>
<script src="./js/network-0520.js">

</script>
<script src="./js/networkGraph0520-allEdges.js">

</script>
<script src="./js/network-grid-0521.js">

</script>
<script src="./js/networkGraph-tree-0521.js">

</script>
<script src="./js/network-forceAtlas2-0510.js">

</script>
<script src="./js/network-2circle-0523.js">

</script>
<script src="./js/network-edges-between-the-same-level-nodes-0524.js">

</script>
<script src="./js/network-edges-between-the-same-level-nodes-2-0524.js">

</script>
<script src="./js/network-edges-between-the-same-level-nodes-3-0531.js">

</script>
<script src="./js/network-tree-0524.js">

</script>
<script src="./js/network-edges-between-levels-0526.js">

</script>
<script src="./js/network-many-children-0526.js">

</script>
<script src="./js/network-forest-0527.js">

</script>
<script src="./js/network-simpletree-0528.js">

</script>

<script src="http://258i.com/static/bower_components/snippets/js/mp/fly.js">

</script>
<style type="text/css">

@import "http://258i.com/static/bower_components/snippets/css/mp/style.css";
.test-graph {
    height: 400px;
}
.test-graph svg {
    width: 100%;
    height: 100%;
}

</style>





<h2> 二、快速启动</h2>

<h3> 2.1 getUniqueSigmaInstance</h3>
<p>以下代码提供<code>sigma</code>实例的生成器，根据<code>实例ID</code>在上下文中只保持一个实例，即使<code>多次调用</code>也是如此。</p>
<pre data-script="javascript editable"><code>
function getUniqueSigmaInstance(instId, config, isSearch){

    var instances = (
            arguments.callee.__instances
                || ( arguments.callee.__instances = [] )
        )
        ;

    if(!instances[instId]) {
        if(isSearch){
            return false;
        }

        if(!config) {
            instances[instId] = new sigma();
        }
        else {
            instances[instId] = new sigma(
                $.extend(
                    {}
                    , config
                ) 
            );
        }
    }
    else {
        if(isSearch == 2) {
            var ret = instances[instId];
            delete instances[instId];
            return ret;
        }
    }

    return instances[instId];
}

function isSigmaInstanceExisted(instId){
    return getUniqueSigmaInstance(instId, null, 2);
}  </code></pre>
<h3> 2.2 getRandomGraph()</h3>
<p><code>getRandomGraph()</code>：获取随机生成的图形数据。</p>
<pre data-script="javascript editable"><code>function getRandomGraph(numOfNodes, numOfEdges, fixSize){

    var i
        , s
        , N = numOfNodes
        , E = numOfEdges
        , g = { nodes: [], edges: [] }
        ;

    for(i=0; i&lt;N; i++){
        g.nodes.push({
            id: 'n' + i
            , label: '' + i
            , x: Math.random()
            , y: Math.random()
            , size: fixSize || Math.random()
            , color: fly.randomColor() 
        });
    }

    for(i=0; i&lt;E; i++){
        var edge = {
            id: 'e' + i
            , source: 'n' + (Math.random() * N | 0) 
            , target: 'n' + (Math.random() * N | 0) 
            , size: fixSize ? 1 : 1 * Math.random()
            // , type: 'curve'
            // , color: fly.randomColor() 
            , color: '#ccc'
            , hover_color: '#f00'
        };

        if(edgeExists(edge)){
            continue;
        }
        else {
            g.edges.push(edge);
        }

    }

    function edgeExists(edge){
        for(var i=0; i&lt;g.edges.length; i++){
            if(g.edges[i].source == edge.source
                &amp;&amp; g.edges[i].target == edge.target) {
                return true;
            }
        }
        return false;
    }

    return g;
}  </code></pre>
<h3> 2.3 getClusterGraph()</h3>
<p><code>getClusterGraph()</code>：获取簇图形数据。</p>

<pre data-script="javascript editable"><code>function getClusterGraph(
    numOfNodes
    , options){

    var opt = options || {} 
        , graph = {nodes: [], edges: []}
        , nid = 1
        , eid = 1
        , xMax = opt.xMax || 300
        , yMax = opt.yMax || 200
        , nodeSize = opt.nodeSize || 1
        ;

    for(var i=0; i&lt;numOfNodes; i++){
        graph.nodes.push({
            id: 'n' + nid
            , label: 'n' + nid++
            , x: xMax * Math.random() 
            , y: yMax * Math.random() 
            , size: nodeSize
            , color: fly.randomColor()
        }); 
    }

    for(i=1; i&lt;numOfNodes; i++){
        graph.edges.push({
            id: 'e' + eid++
            , source: 'n1'
            , target: graph.nodes[i].id
            , color: '#ccc'
            , hoverColor: '#f00'
        });
    }

    return graph;
}

// console.log(getClusterGraph(30, {xMax: 300, yMax: 200, nodeSize: 10}));  </code></pre>
<h2> 三、自动布局</h2>




<h3> 3.1 Noverlap算法</h3>

<p>静态布局，计算好目标位置后，再进行渲染。可能最终渲染时会添加部分补间动画，但能很快到达目标状态。有稳定的感觉。</p>
<p>擅长解决<code>节点重叠</code>的问题。</p>
<p><code>无法</code>达到边的长度均衡，交叉边最少的要求。</p>
<p>以下例子使用sigmajs自带的<code>noverlap</code>插件来实现。</p>

<style type="text/css">

.test-graph div {
    float: left;
    height: 100%;
    width: 50%;
    border: 1px dotted #666;
}
.test-graph div.test-graph-left-top,
.test-graph div.test-graph-right-top,
.test-graph div.test-graph-left-bottom,
.test-graph div.test-graph-right-bottom {
    height: 50%;
}

</style>

<div id="test_10">
<div class="test-container">
<div id="test_10_graph" class="test-graph">
<div class="test-graph-left"></div>
<div class="test-graph-right"></div>
</div>
<div class="test-console"></div>
<pre data-script="javascript editable"><code>
(function(){

    var s = fly.createShow('#test_10');
    var g1 = getRandomGraph(200, 200, 1);
    var g2 = {
            nodes: g1.nodes.slice()
            , edges: g1.edges.slice() 
        };
    var containerId = 'test_10_graph';
    var rendererSettings = {
            // captors settings
            doubleClickEnabled: true
            , mouseWheelEnabled: false

            // rescale settings
            , minEdgeSize: 0.5
            , maxEdgeSize: 1
            , minNodeSize: 1 
            , maxNodeSize: 5

            // renderer settings
            , edgeHoverColor: fly.randomColor() 
            , edgeHoverSizeRatio: 1
            , edgeHoverExtremities: true
            , drawLabels: false
        };
    var sigmaSettings = {
            // rescale settings 
            sideMargin: 0.1 

            // instance global settings
            , enableEdgeHovering: true
            , edgeHoverPrecision: 5
        };

    var sm1, sm2;

    if((sm1 = isSigmaInstanceExisted('test_10_left'))
        &amp;&amp; (sm2 = isSigmaInstanceExisted('test_10_right'))){
        sm1.kill();
        sm2.kill();
    };

    sm1 = getUniqueSigmaInstance(
                'test_10_left'
                , {
                    settings: sigmaSettings 
                    , graph: g1
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-left')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm2 = getUniqueSigmaInstance(
                'test_10_right'
                , {
                    settings: sigmaSettings 
                    , graph: g2
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-right')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm1.refresh();
    var noverlapListener = sm2.configNoverlap({
            nodeMargin: 0.1,
            scaleNodes: 1.05,
            gridSize: 20,
            easing: 'quadraticInOut',
            duration: 5000
        });

    sm2.startNoverlap();


})(); </code></pre>
</div>
<div class="test-panel"></div>
</div>




<h3> 3.2 FDA算法</h3>
<p>FDA(Force-directed Algorithm)是图布局研究中的重要研究成果，也是最知名的图布局算法之一，在网络
节点布局中占据了主导地位，该算法也称为<code>弹性模型(Sprint Embedded Model)</code>。FDA算法中另一个比较著名
的算法是<code>GVA(Grid Variant Algorithm)</code>，也叫做<code>FR算法</code>。</p>
<p><code>动态</code>布局，计算过程与渲染同时进行。动态效果好，但有不稳定的感觉。</p>
<p>最终布局效果（<code>依赖</code>收敛时间）：</p>
<ol><li>每条边<code>长度</code>趋于<code>一致</code>。</li>
<li>节点<code>不重合</code>。</li></ol>
<p>依赖收敛时间，如果收敛时间太长，图形会一直跳动，有种<code>不稳定</code>的感觉。</p>
<p>以下例子使用vivagraph来实现，使用了<code>Viva.Graph.Layout.forceDirected</code>布局算法。 </p>


<div id="test_20" class="test">
<div class="test-container">
<div id="test_20_graph" class="test-graph"></div>
<div class="test-console"></div>
<pre data-script="javascript editable"><code>
(function(){

    var s = fly.createShow('#test_20');
    var g = getRandomGraph(20, 40, 1);
    var containerId = 'test_20_graph';
    var graph, renderer;

    if($('#' + containerId).data('viva-graph')){
        graph = $('#' + containerId).data('viva-graph'); 
    }
    else {
        var graphGenerator = Viva.Graph.generator();
        graph = graphGenerator.grid(8, 8);
        // graph = Viva.Graph.graph();
        $('#' + containerId).data('viva-graph', graph); 
    }

    /*
    graph.clear();
    g.nodes.forEach(function(node){
        graph.addNode(node.id, {x: node.x, y: node.y});
    });
    g.edges.forEach(function(edge){
        graph.addLink(edge.source, edge.target);
    });
    */

    renderer = $('#' + containerId).data('viva-renderer'); 
    renderer &amp;&amp; renderer.dispose();

    var layout = Viva.Graph.Layout.forceDirected(
        graph
        , {
            springLength: 10
            , springCoeff: 0.0005
            , dragCoeff: 0.02
            , gravity: -1.2
        }
    );

    // https://github.com/anvaka/VivaGraphJS/blob/master/src/View/renderer.js
    renderer = Viva.Graph.View.renderer(
        graph
        , {
            container: $('#' + containerId)[0]
            , layout: layout
            , interactive: false
        }
    );
    $('#' + containerId).data('viva-renderer', renderer); 

    renderer.run();

    setTimeout(function(){
        renderer.pause();
    }, 5000);

})(); </code></pre>
</div>
<div class="test-panel"></div>
</div>


<h3> 3.3 forceAtlas2算法</h3>
<blockquote><p> <code>ForceAtlas2</code>, a <code>continuous graph layout</code> algorithm for handy network visualization designed for the <code>Gephi</code> software.</p></blockquote>
<p><code>相连</code>节点间有<code>胡克引力</code>，会互相<code>吸引</code>；<code>不相连</code>节点有<code>库仑斥力</code>，会互相<code>远离</code>。以及所有节点都有<code>重力</code>，会向中心靠拢。</p>
<ul><li>对于<code>森林</code>的展示，效果不是很好</li>
<li><code>收敛</code>速度慢，或者<code>长久无法</code>收敛，导致某些交互效果无法响应，比如hover。这时调用<pre><code>sigmaInst.killForceAtlas2(); </code></pre>
<p>可能是一个好办法。</p>
</li></ul>
<p>整个算法以一个<code>模拟</code><code>物理系统</code>的方式进行多次迭代，需要配置<code>合适</code>的<code>参数</code>来获得较好的布局效果。这个可能比较费时间。目前比较有效的几个参数如下：</p>
<pre><code>{
    worker: true
    , barnesHutOptimize: false
    , scalingRatio: 260
    , slowDown: 3
    , outboundAttractionDistribution: 1
    , gravity: 15
}  </code></pre>
<p>另外，<code>整个</code>系统能量的最小化比较容易达到，但是<code>局部</code>能量的最小化却比较不确定，容易出现<code>局部</code>节点<code>抖动</code>的情况。不过节点抖动也有一定的规律可循，通过增加新的优化选项字段<code>preventShaking</code>来避免。</p>
<pre><code>{
    preventShaking: true
}  </code></pre>
<p>相关代码如下，思路为发现抖动的节点，则将其<code>设为静止</code>不再参与物理系统的运行：</p>
<pre><code>...
var shakingThreshold = W.settings.shakingThreshold || 0.05;
var dx = NodeMatrix[np(n, 'dx')];
var oldDx = NodeMatrix[np(n, 'old_dx')];
var dy = NodeMatrix[np(n, 'dy')];
var oldDy = NodeMatrix[np(n, 'old_dy')];

if(W.settings.preventShaking){
  if(Math.abs(Math.abs(dx) - Math.abs(oldDx)) / Math.abs(dx) &lt; shakingThreshold
      &amp;&amp; Math.abs(dx - oldDx) / ( 2 * Math.abs(dx) ) > 1 - shakingThreshold
    || Math.abs(Math.abs(dy) - Math.abs(oldDy)) / Math.abs(dy) &lt; shakingThreshold
      &amp;&amp; Math.abs(dy - oldDy) / ( 2 * Math.abs(dy) ) > 1 - shakingThreshold) {
    NodeMatrix[np(n, 'fixed')] = 1;
  }
}
...  </code></pre>
<p>在项目中，我们将这种算法获得的布局称为<code>Organic layout</code>（<code>有机体布局</code>）。该布局显示出一种<code>内在</code>的<code>平衡感</code>、<code>簇布局</code>、<code>少交叉边</code>等特点。本质上还是<code>力导向</code>布局算法的衍生。</p>
<p><a href="http://docs.yworks.com/yfiles/doc/demo/layout/module/SmartOrganicLayoutModule.java.html">http://docs.yworks.com/yfiles/doc/demo/layout/module/SmartOrganicLayoutModule.java.html</a></p>

<p>以下例子使用sigmajs自带的<code>forceAtlas2</code>算法来实现。</p>


<div id="test_30">
<div class="test-container">
<div id="test_30_graph" class="test-graph">
<div class="test-graph-left"></div>
<div class="test-graph-right"></div>
</div>
<div class="test-console"></div>
<pre data-script="javascript editable"><code>
(function(){

    var s = fly.createShow('#test_30');
    // var g1 = getRandomGraph(80, 200, 1);
    // var g1 = networkGraph_FR;
    // var g1 = networkGraph_ForceAtlas2;
    // var g1 = networkGraph0520_allEdges;
    var g1 = networkGraph_grid_0521; 
    var g1 = networkGraph_tree_0521;
    var g1 = networkGraph_2circles_0523;
    var g1 = networkGraph_edges_between_the_same_level_nodes;
    var g1 = networkGraph_edges_between_the_same_level_nodes_2;
    var g1 = networkGraph_many_children_0526;
    var g2 = {
            nodes: g1.nodes.slice()
            , edges: g1.edges.slice() 
        };
    var containerId = 'test_30_graph';
    var rendererSettings = {
            // captors settings
            doubleClickEnabled: true
            , mouseWheelEnabled: false

            // rescale settings
            , minEdgeSize: 0.5
            , maxEdgeSize: 1
            , minNodeSize: 1 
            , maxNodeSize: 5

            // renderer settings
            , edgeHoverColor: fly.randomColor() 
            , edgeHoverSizeRatio: 1
            , edgeHoverExtremities: true
            , drawEdges: true
            , drawLabels: false
        };
    var sigmaSettings = {
            // rescale settings 
            sideMargin: 0.1 

            // instance global settings
            , enableEdgeHovering: true
            , edgeHoverPrecision: 5
        };

    var sm1, sm2;

    if((sm1 = isSigmaInstanceExisted('test_30_left'))
        &amp;&amp; (sm2 = isSigmaInstanceExisted('test_30_right'))){
        sm1.kill();
        sm2.kill();
    };

    sm1 = getUniqueSigmaInstance(
                'test_30_left'
                , {
                    settings: sigmaSettings 
                    , graph: g1
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-left')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm2 = getUniqueSigmaInstance(
                'test_30_right'
                , {
                    settings: sigmaSettings 
                    , graph: g2
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-right')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm1.refresh();
    sm2.startForceAtlas2({
        worker: true
        , barnesHutOptimize: false
        , scalingRatio: 260
        , slowDown: 1
        , outboundAttractionDistribution: 1
        , gravity: 15
        , preventShaking: 1
        , shakingThreshold: 0.1
    }); 

    setTimeout(function(){
        sm2.killForceAtlas2();
        var noverlapListener = sm2.configNoverlap({
                nodeMargin: 5,
                scaleNodes: 1.05,
                gridSize: 20,
                easing: 'quadraticInOut',
                duration: 1000
            });
        sm2.startNoverlap();
    }, 5000);

})(); </code></pre>
</div>
<div class="test-panel"></div>
</div>


<h3> 3.4 Yifan Hu算法</h3>
<p>使用<code>Edge Bundling</code>（边捆绑技术）。Todo</p>




<h2> 四、固定布局</h2>

<h3> 4.1 新增常用方法</h3>

<h4> 4.1.1 sortByNodesDegree</h4>
<p><code>sortByNodesDegree()</code>：按节点度进行排序。</p>
<pre data-script="javascript"><code>sigma.classes.graph.addMethod(
    'sortByNodesDegree'
    , function(reverse){
    var nodes = this.nodesArray
        , me = this
        ;

    nodes.forEach(function(node){
        node.degree = me.degree(node.id);
    });
    nodes.sort(function(a, b){
        return reverse 
            ? b.degree - a.degree
            : a.degree - b.degree;
    });

    return this;
});  </code></pre>
<h4> 4.1.2 getNodeById</h4>
<p><code>getNodeById()</code>：根据<code>节点id</code>获取节点<code>对象</code>。</p>
<pre data-script="javascript"><code>sigma.utils.getNodeById
    = function(nodes, id){
        if(!nodes) {
            return null;
        }
        for(var i=0; i&lt;nodes.length; i++){
            if(nodes[i].id == id){
                return nodes[i];
            }
        }
        return null;
    }  </code></pre>
<h4> 4.1.3 widthTravel</h4>
<p><code>widthTravel(root)</code>：从root节点开始对图进行广度遍历，遍历过程中<code>忽略</code><code>父节点</code>和<code>兄弟</code>节点。</p>
<p><code>广度</code>遍历过程可以形成<code>树形</code>结构。如下图所示：</p>
<p style="text-align:center"><img src="./img/graph-width-travel.png" width="560"></p>
<pre data-script="javascript"><code>sigma.utils.widthTravel
    = function(nodes, edges, root, callbacks, excludes) {

    if(!nodes || !nodes.length){
        return;
    }

    var cbs = callbacks || {}
        , edges = edges || []
        , queue = []
        , parentAndSiblingNodes = excludes || {}
        , node = root || nodes[0]
        , children
        ;

    node._wt_level = 1;
    queue.push(node);
    parentAndSiblingNodes[node.id] = 1;

    while((node = queue.splice(0, 1)).length > 0){
        node = node[0];
        children = getChildren(node); 
        node._wt_children = children;
        queue = queue.concat(children);

        if(typeof cbs['onNode'] == 'function'){
            cbs['onNode'](node);
        }
    }

    function getChildren(node){
        var id = node.id
            , children = []
            , childId
            , child
            ;
        edges.forEach(function(edge){
            if(
                edge.source == id
                || edge.target == id
              ){
                childId = edge.source;
                if(childId == id){
                    childId = edge.target;
                }
                if(!parentAndSiblingNodes[childId]){
                    parentAndSiblingNodes[childId] = 1;
                    child = sigma.utils.getNodeById(nodes, childId);
                    child._wt_level = node._wt_level + 1;
                    children.push(child);
                }
            }
        });
        return children;
    }

};

sigma.classes.graph.addMethod(
    'widthTravel'
    , function(root, callbacks, excludes){

    var me = this
        , nodes = me.nodesArray
        , edges = me.edgesArray
        , root = root || nodes[0]
        , cbs = callbacks || {}
        ;

    sigma.utils.widthTravel(
        nodes     
        , edges
        , root
        , cbs
        , excludes
    );

    return me;

});     </code></pre>
<h4> 4.1.4 getLayoutForest</h4>
<p><code>getLayoutForest()</code>：生成布局森林。对图进行<code>广度</code>遍历，获得其<code>遍历树</code>。</p>
<pre data-script="javascript"><code>sigma.utils.getLayoutForest
    = function(nodes, edges, options){

    var opt = options || {}
        , nodesVisited = {}
        , forest = []
        , node = opt.root || nodes[0]
        , excludes = opt.excludes
        ;

    do {
        sigma.utils.widthTravel(
            nodes
            , edges
            , node
            , {
                onNode: function(node){
                    nodesVisited[node.id] = true;
                }
            } 
            , excludes
        )
        forest.push(node);
        ;
    } while((node = hasMore()));

    function hasMore(){
        for(var i=0; i&lt;nodes.length; i++){
            if(!nodesVisited[nodes[i].id]){
                return nodes[i];
            }
        }
        return 0;
    }

    return forest;
};

sigma.classes.graph.addMethod(
    'getLayoutForest'
    , function(options){
    var opt = options || {}
        , me = this
        , nodes = me.nodesArray
        , edges = me.edgesArray
        ;

    return sigma.utils.getLayoutForest(nodes, edges, opt); 
});    </code></pre>
<h4> 4.1.5 computeLeaves</h4>
<p><code>computeLeaves()</code>：计算布局森林每个节点包含的叶子节点数。</p>
<pre data-script="javascript editable"><code>sigma.utils.computeLeaves
    = function(forest){

    forest.forEach(function(tree){

        // if there is a circuit
        if(tree._circuit){
            tree._circuit.forEach(function(node){
                depthTravel(node);
            });
        }
        else {
            depthTravel(tree);

        }

        function depthTravel(node){
            var children = node._wt_children
                , _leaves
                , leaves = 0
                ;
            if(children.length == 0){
                _leaves = [1];
            }
            else {
                _leaves = children.map(function(node){
                    return depthTravel(node);
                }); 
            }

            _leaves.forEach(function(item){
                leaves += item;
            });

            return ( node._wt_leaves = leaves );
        }

    });

}   </code></pre>
<h4> 4.1.6 depthTravel</h4>
<p><code>depthTravel()</code>：从<code>root</code>节点开始对图进行深度遍历，遍历过程忽略已经访问过的节点。</p>
<pre data-script="javascript"><code>sigma.utils.depthTravel
    = function(nodes, edges, root, callbacks) {

    if(!nodes || !nodes.length){
        return;
    }

    var cbs = callbacks || {}
        , visitedNodes = {}
        , node = root || nodes[0]
        , children
        ;

    edges = edges || [];

    node._dt_level = 1;
    _depthTravel(node);

    function _depthTravel(node){
        if(visitedNodes[node.id]){
            return;
        }
        visitedNodes[node.id] = 1;

        if(typeof cbs['onNode'] == 'function'){
            cbs['onNode'](node);
        }

        var children = getChildren(node); 
        if(children.length > 0){
            children.forEach(function(child){
                _depthTravel(child);
            });
        }
    }

    function getChildren(node){
        var id = node.id
            , children = []
            , childId
            , child
            ;
        edges.forEach(function(edge){
            if(
                edge.source == id
                || edge.target == id
              ){
                childId = edge.source;
                if(childId == id){
                    childId = edge.target;
                }
                if(!visitedNodes[childId]){
                    child = sigma.utils.getNodeById(nodes, childId);
                    child._dt_level = node._dt_level + 1;
                    children.push(child);
                }
            }
        });
        return children;
    }

};

sigma.classes.graph.addMethod(
    'depthTravel'
    , function(root, callbacks){

    var me = this 
        , nodes = me.nodesArray
        , edges = me.edgesArray
        ;

    sigma.utils.depthTravel(
        nodes
        , edges
        , root 
        , callbacks
    );

    return me;

});    </code></pre>
<h4> 4.1.7 getCircuits</h4>
<p><code>getCircuits()</code>：从root节点开始，寻找所有回路。<code>方式</code>为对图进行<code>深度</code>遍历，当<code>root</code>的一个<code>非邻接</code>节点有一条到root的边，则构成一条<code>回路</code>。</p>
<p><code>注意</code>：</p>
<ol><li>这个算法需要找出从root开始的<code>所有</code>回路，所以算法中使用的深度遍历，<code>不完全</code><code>等同于</code><code>depthTravel</code>，一个节点只访问一次。该算法中，<code>节点</code>可能被<code>多次</code>访问。</li>
<li>需要<code>排除</code>这种回路： <code>n1</code> -> <code>n2</code> -> <code>n1</code></li></ol>
<p>代码如下：</p>
<pre data-script="javascript"><code>sigma.utils.getCircuits
    = function(nodes, edges, root) {

    var nLen = nodes.length || 1
        , eLen = edges.length || 1
        ;

    if(eLen &lt;= 50 &amp;&amp; eLen / nLen &lt;= 1.25){
        return sigma.utils.getCircuitsSlow(nodes, edges, root); 
    }
    else { 
        return sigma.utils.getCircuitsFast(nodes, edges, root); 
    }

};

sigma.classes.graph.addMethod(
    'getCircuits'
    , function(root){

    var me = this
        , nodes = me.nodesArray
        , edges = me.edgesArray
        , root = root || nodes[0]
        ;

    return sigma.utils.getCircuits(nodes, edges, root);

});  </code></pre>
<p>提供了两个算法，<code>getCircuitsSlow</code>与<code>getCircuitsFast</code>，前者速度<code>快</code>，但<code>不一定</code>找出<code>所有</code>回路；后者速度<code>慢</code>，能找出<code>所有</code>回路。<code>getCircuits</code>方法根据<code>边的数目</code>来决定使用哪个算法。</p>

<pre data-script="javascript"><code>sigma.utils.getCircuitsSlow
    = function(nodes, edges, root) {

    if(!nodes || !nodes.length){
        return;
    }

    var me = this
        , root = root || nodes[0]
        , children
        , path = []
        , circuits = []
        , isStop = 0
        ;

    edges = edges || [];

    root._dt_level = 1;
    _depthTravel(root);
    return circuits;

    function _depthTravel(node){
        if(isStop){
            return;
        }

        if(!isNodeInPath(node)){
            path.push(node);

            var children = getChildren(node); 
            if(children.length > 0){
                children.forEach(function(child){
                    _depthTravel(child);
                });
            }

            path.pop(node);
        }
        else if(node.id == root.id
            &amp;&amp; path.length > 2){
            circuits.push(path.slice());  
            if(circuits.length >= 20){
                isStop = 1;
            }
        }
    }

    function isNodeInPath(node){
        return path.map(function(_node){return _node.id;})
            .indexOf(node.id)
            != -1
            ;
    }

    function getChildren(node){
        var id = node.id
            , children = []
            , childId
            , child
            ;

        if(node._tmp_children){
            return node._tmp_children; 
        }

        edges.forEach(function(edge){
            if(
                edge.source == id
                || edge.target == id
              ){
                childId = edge.source;
                if(childId == id){
                    childId = edge.target;
                }

                child = sigma.utils.getNodeById(nodes, childId);
                children.push(child);
            }
        });

        return (node._tmp_children = children);
    }

};



sigma.utils.getCircuitsFast
    = function(nodes, edges, root) {

    if(!nodes || !nodes.length){
        return;
    }

    var me = this
        , root = root || nodes[0]
        , visitedNodes = {}
        , children
        , path = []
        , circuits = []
        ;

    edges = edges || [];

    _depthTravel(root);
    return circuits;

    function _depthTravel(node){
        if(visitedNodes[node.id]){
            return;
        }
        visitedNodes[node.id] = 1;
        path.push(node);

        var children = getChildren(node); 
        if(children.length > 0){
            children.forEach(function(child){
                _depthTravel(child);
            });
        }
        path.pop(node);
    }

    function getChildren(node){
        var id = node.id
            , children = []
            , childId
            , child
            ;
        edges.forEach(function(edge){
            if(
                edge.source == id
                || edge.target == id
              ){
                childId = edge.source;
                if(childId == id){
                    childId = edge.target;
                }

                if(childId == root.id &amp;&amp; path.length > 2){
                    circuits.push(path.slice());  
                }                        

                if(!visitedNodes[childId]){
                    child = sigma.utils.getNodeById(nodes, childId);
                    children.push(child);
                }

            }
        });
        return children;
    }

};    </code></pre>
<h4> 4.1.8 getMaxDegreeNode</h4>

<p><code>getMaxDegreeNode()</code>：获得图形最大度数节点。</p>
<pre data-script="javascript"><code>sigma.utils.getMaxDegreeNode
    = function(nodes, edges){

    if(!nodes || !edges) {
        return null;
    }

    var degreeArr = [] 
        , degree
        , node, edge, i, j
        ;

    for(i=0; i&lt;nodes.length; i++){
        node = nodes[i];
        degree = {
            id: node.id
            , data: 0
        };
        degreeArr.push(degree);

        for(j=0; j&lt;edges.length; j++){
            edge = edges[j]; 
            if(
                edge.source  == node.id
                || edge.target  == node.id
            ){
                degree.data++;
            }
        }
    }
    degreeArr.sort(function(a, b){
        return b.data - a.data;
    });

    return degreeArr.length
        ? sigma.utils.getNodeById(nodes, degreeArr[0].id)
        : null;

};

sigma.classes.graph.addMethod(
    'getMaxDegreeNode'
    , function(){

    var nodes = nodes || this.nodesArray
        , edges = edges || this.edgesArray
        , me = this
        ;

    return sigma.utils.getMaxDegreeNode(nodes, edges);        
});     </code></pre>
<h4> 4.1.9 getCircleForest</h4>
<p><code>getCircleForest()</code>：获得<code>环形</code>布局<code>森林</code>。</p>
<pre data-script="javascript"><code>sigma.utils.getCircleForest
    = function(nodes, edges, options){

    var opt = options || {} 
        , circuits
        , circuit
        , tree = opt.root 
            || ( opt.makeMaxDegreeNodeRoot 
                ? sigma.utils.getMaxDegreeNode(nodes, edges) : null )
            || nodes[0]
        , excludes
        , nodesVisited = {}
        , forest = []
        ;

    edges = edges || [];

    do {
        circuits = sigma.utils.getCircuits(nodes, edges, tree);
        excludes = {};

        if(circuits.length > 0){
            circuits.sort(function(a, b){
                return b.length - a.length;
            });

            // the longest circuit
            tree._circuit = circuit = circuits[0]; 

            circuit.forEach(function(_node){
                excludes[_node.id] = 1;
            });

            circuit.forEach(function(_node){
                sigma.utils.widthTravel(
                    nodes
                    , edges
                    , _node
                    , {
                        onNode: function(__node){
                            nodesVisited[__node.id] = 1;
                        }
                    }
                    , excludes
                );
            });
        }
        else {
            sigma.utils.widthTravel(
                nodes
                , edges
                , tree
                , {
                    onNode: function(__node){
                        nodesVisited[__node.id] = 1;
                    }
                }
            );
        }

        forest.push(tree);

    } while((tree = hasMore()));

    function hasMore(){
        for(var i=0; i&lt;nodes.length; i++){
            if(!nodesVisited[nodes[i].id]){
                return nodes[i];
            }
        }
        return 0;
    } 

    return forest;

};

sigma.classes.graph.addMethod(
    'getCircleForest'
    , function(options){

    var me = this
        , nodes = me.nodesArray
        , edges = me.edgesArray
        ;

    return sigma.utils.getCircleForest(nodes, edges, options);
});    </code></pre>
<h4> 4.1.10 computeCircleTreeRect</h4>
<p><code>computeCircleTreeRect()</code>：获取<code>环形布局树</code>的<code>空间</code>占用，用<code>矩形</code>表示。</p>
<pre data-script="javascript"><code>sigma.utils.computeCircleTreeRect
    = function(tree){

    var maxLevel = tree._wt_maxlevel
        , hasCircuit = tree._circuit ? 1 : 0
        , width = hasCircuit ? 2 * maxLevel : maxLevel
        ;

    if(maxLevel){
        return {
            x: 0
            , y: 0 
            , w: width 
            , h: width 
        };
    }

    return null;
}    </code></pre>
<h4> 4.1.11 computeHierarchyTreeRect</h4>
<p><code>computeHierarchyTreeRect()</code>：获取<code>层次布局树</code>的<code>空间</code>占用，用<code>矩形</code>表示。</p>
<pre data-script="javascript"><code>sigma.utils.computeHierarchyTreeRect
    = function(tree, offsetX){

    var maxLevel = tree._wt_maxlevel
        , leaves = tree._wt_leaves
        , height = maxLevel || 1
        , width = leaves || 1
        ;

    if(maxLevel){
        return {
            x: offsetX || 0
            , y: 0 
            , w: width 
            , h: height 
        };
    }

    return null;
}    </code></pre>
<h4> 4.1.12 getNodesRect </h4>
<p><code>getNodesRect()</code>：获取<code>节点集合</code>的<code>空间</code>占用，用<code>矩形</code>表示。</p>
<pre data-script="javascript"><code>sigma.utils.getNodesRect
    = function(nodes, options){

    var opt = options || {}
        , xMin = Infinity
        , yMin = Infinity
        , xMax = -Infinity
        , yMax = -Infinity
        , readPrefix = opt.readPrefix || ''
        , ignoreNodeSize = typeof opt.ignoreNodeSize == 'undefined'
            ? true : opt.ignoreNodeSize
        , node, i, x, y, size
        ;

    i = nodes.length - 1;
    while(i >= 0){
        node = nodes[i];
        x = node[readPrefix + 'x'] || 0;
        y = node[readPrefix + 'y'] || 0;
        size = ignoreNodeSize 
            ? 0 : node[readPrefix + 'size'] || node['size'] || 0.2;
        if(x - size &lt; xMin){
            xMin = x - size;
        }
        if(x + size > xMax){
            xMax = x + size;
        }
        if(y - size &lt; yMin){
            yMin = y - size;
        }
        if(y + size > yMax){
            yMax = y + size;
        }
        i--;
    }

    if(nodes.length == 0){
        xMin = 0;
        yMin = 0;
        xMax = 0;
        yMax = 0;
    }

    return {
        x: xMin
        , y: yMin
        , w: xMax - xMin
        , h: yMax - yMin
    };
}   </code></pre>
<h4> 4.1.13 normailizeSophonNodes </h4>
<p><code>normalizeSophonNodes()</code>：标准化节点。</p>
<pre data-script="javascript"><code>sigma.utils.normalizeSophonNodes
    = function(nodes, options){

    if(!nodes){
        return null;
    }

    var opt = options || {} 
        , center = opt.center || {x:0, y:0}
        // , size = opt.size || 10
        , prefix = opt.readPrefix || ''
        , rect = sigma.utils.getNodesRect(nodes, opt) 
        , nodesCenter = {
            x: rect.x + rect.w / 2
            , y: rect.y + rect.h / 2
        }
        , dx = center.x - nodesCenter.x
        , dy = center.y - nodesCenter.y
        ;

    nodes.forEach(function(node){
        node[prefix + 'x'] += dx;
        node[prefix + 'y'] += dy;
        // node.size = size;
    });

    return nodes;
}

sigma.prototype.normalizeSophonNodes
    = function(options){

    sigma.utils.normalizeSophonNodes(
        // note: `this.graph.nodesArray` will not work
        this.graph.nodes()
        , options
    );

    return this;
};     </code></pre>
<h4> 4.1.14 alignCenter</h4>
<p><code>alignCenter()</code>：对图形进行<code>居中全景</code>布局。</p>
<pre data-script="javascript editable"><code>sigma.prototype.alignCenter = function(options){
    var opt = options || {} 
        , me = this
        , rect = sigma.utils.getNodesRect(me.graph.nodes(), opt) 
        , cameras = me.cameras
        , camera
        , renderer
        , readPrefix = opt.readPrefix || ''
        , writePrefix = opt.writePrefix || ''
        , ratio
        , height
        , width
        , i
        ;

    for(i in cameras){
        camera = cameras[i];
        renderer = me.renderersPerCamera[camera.id][0];
        ratio = camera.ratio;
        height = renderer.height;
        width = renderer.width;

        // wholeview mode by setting an appropriate camera ratio
        if(opt.wholeView){
            ratio = Math.max(rect.w / width, rect.h / height) * 1.3;
        }
        // another wholeview mode by rescaling coordinates 
        else if(opt.rescaleToViewport){
            sigma.middlewares.rescale.call(
                me
                , readPrefix
                , writePrefix
                , {
                    width: width
                    , height: height
                    , autoRescale: ['nodePosition']
                    , scalingMode: 'inside'
                    , rescaleIgnoreSize: 1
                    , sideMargin: Math.min(rect.h, rect.w) * 0.2 
                }
            );
            ratio = 1;
        }

        camera.goTo({
            x: rect.x + rect.w / 2
            , y: rect.y + rect.h / 2
            // prevents `ratio = 0`
            , ratio: ratio || 1
        });
    }

    return me;
}    </code></pre>
<h4> 4.1.15 resize</h4>
<p><code>resize(ratio)</code>：按比例改变图形尺寸[<code>暂未验证</code>]。</p>
<pre data-script="javascript"><code>sigma.classes.graph.addMethod(
    'resize'
    , function(ratio){

    var nodes = this.nodesArray
        , edges = this.edgesArray
        , me = this
        , ratio = ratio || 1
        , prefix = prefix || ''
        , i = 0
        ;

    while(i&lt;nodes.length){
        nodes[i]['size'] *= ratio;
        nodes[i]['x'] *= ratio;
        nodes[i]['y'] *= ratio;
        i++;
    } 

    return me;

});      </code></pre>
<h4> 4.1.16 Grid类</h4>

<p><code>Grid工具类</code>：</p>

<pre data-script="javascript editable"><code>(function(){

    function Grid(xSize, ySize){
        var me = this;

        me.xSize = xSize || 10;
        me.ySize = ySize || 10;
        me.grid = [];
        me.blockList = {};

        me.init();
    }

    var prototype = {

        init: function(){
            var me = this
                , grid = me.grid
                ; 

            for(var i=0; i&lt;me.ySize; i++){
                grid.push([]);
                for(var j=0; j&lt;me.xSize; j++){
                    grid[i].push(0);
                }
            }
        }

        , getBlockRect: function(id){
            return this.blockList[id];
        }

        , getMinSquare: function(){
            var me = this
                , square = null
                , grid = me.grid
                , i, j
                , xMax = 0
                , yMax = 0
                , max
                ;

            for(i=0; i&lt;me.xSize; i++){
                for(j=0; j&lt;me.ySize; j++){
                    if(grid[i][j]){
                        xMax = Math.max(i + 1, xMax);
                        yMax = Math.max(j + 1, xMax);
                    }
                }
            } 

            if(xMax > 0 &amp;&amp; yMax > 0){
                max = Math.max(xMax, yMax);
                square = {
                    x: 0, y: 0
                    , w: max
                    , h: max
                }
            }

            return square;
        }

        , getMaxSpareRect: function(minSquare){
            var me = this
                , grid = me.grid
                , square = minSquare || me.getMinSquare()
                , rect
                , iStart, jStart
                , i, j
                ; 

            if(!square){
                rect = {
                    x: 0 
                    , y: 0
                    , w: me.xSize
                    , h: me.ySize
                };
            } 
            else {
                jStart = square.x + square.w - 1;
                iStart = square.y + square.h - 1;

                if(grid[iStart][jStart]){
                    if(iStart &lt; me.ySize - 1 &amp;&amp; jStart &lt; me.xSize - 1){
                        iStart++;
                        jStart++;
                    }
                    else {
                        rect = null;
                    }
                }

                var w
                    , h
                    , wMax = Infinity
                    , areas = [];

                h = 0;

                for(i=iStart; i >= 0; i--){
                    h++;
                    w = 0;
                    for(j=jStart; j>=0; j--){
                        w++; 
                        if(grid[i][j]){
                            wMax = Math.min(w - 1, wMax);
                            areas.push({
                                x: jStart - wMax + 1 
                                , y: i 
                                , w: wMax
                                , h: h
                                , area: wMax * h  
                            });
                            break;
                        }
                    }
                    if(j &lt; 0){
                        wMax = Math.min(w, wMax);
                        areas.push({
                            x: 0
                            , y: i 
                            , w: wMax
                            , h: h
                            , area: wMax * h  
                        });
                    }
                }

                areas.sort(function(a, b){
                    return b.area - a.area;
                });
                rect = areas[0];
            }

            return rect;
        }

        , placeBlock: function(id, block, debug){
            var me = this
                , minSquare = me.getMinSquare()
                , maxSpareRect
                , pos = {x: 0, y: 0}
                ;

            if(!minSquare){
                pos.x = 0;
                pos.y = 0;
            }
            else {
                maxSpareRect = me.getMaxSpareRect(minSquare);
                if(!maxSpareRect) {
                    pos.x = minSquare.x + minSquare.w;
                    pos.y = 0;
                }
                else {
                    pos.x = maxSpareRect.x;
                    pos.y = maxSpareRect.y;
                }
            }

            me.addBlock(id, pos, block, debug); 
        } 

        , addBlock: function(id, pos, block, debug){
            var me = this
                , grid = me.grid
                ;

            for(var i=pos.y; i&lt;pos.y + block.h &amp;&amp; i&lt;me.ySize; i++){
                for(var j=pos.x; j&lt;pos.x + block.w &amp;&amp; j&lt;me.xSize; j++){
                    if(!grid[i][j]){
                        grid[i][j] = debug ? id : 1;
                    }
                    else {
                        throw new Error('grid[' + i + '][' + j + '] is occupied!');
                    }
                }
            }     
            block.gridPos = pos;
            me.blockList[id] = block; 
        }

    };

    function extend(dest, src){
        for(var i in src){
            dest[i] = src[i];
        }
    }

    extend(Grid.prototype, prototype);

    window.Grid = Grid;

})();    </code></pre>
<h4> 4.1.17 adjustSiblingsOrder()</h4>
<p><code>adjustSiblingsOrder(parent, edges)</code>：<code>层次</code>布局中，<code>同层次</code>的<code>兄弟</code>节点之间如果存在边，则调整<code>有边</code>的兄弟节点<code>靠近</code>。</p>
<pre data-script="javascript"><code>sigma.utils.adjustSiblingsOrder
    = function(parentNode, edges) {

    if(!parentNode || !parentNode._wt_children){
        console.log(arguments.callee
            , 'parentNode is null or parentNode._wt_children is not existed');
        return;
    }

    var nodes = parentNode._wt_children
        , edges = edges || []
        , visitedNodes = {}
        , node
        , index
        , len = nodes.length
        , j
        , adjacentNodes
        , flagLeft
        , flagRight
        ;

    while((index = _hasMoreIndex()) >= 0){
        node = nodes[index];
        visitedNodes[node.id] = 1;
        adjacentNodes = _getAdjacentNodes(node, nodes);
        flagLeft = 0;
        flagRight = 0;
        if(adjacentNodes &amp;&amp; adjacentNodes.length){

            if(index>0 &amp;&amp; adjacentNodes.indexOf(nodes[index-1]) &lt; 0){
                for(j=index-1; j>=0; j--){
                    if(adjacentNodes.indexOf(nodes[j]) >= 0){
                        nodes.splice(index, 1);
                        nodes.splice(j, 0, node);
                        flagLeft = 1;
                        break;
                    }
                }
            } 

            if(flagLeft){
                continue;
            }

            if(index&lt;len - 1 &amp;&amp; adjacentNodes.indexOf(nodes[index+1]) &lt; 0){
                for(j=index+1; j&lt;len; j++){
                    if(adjacentNodes.indexOf(nodes[j]) >= 0){
                        nodes.splice(j-1, 0, node);
                        nodes.splice(index, 1);
                        break;
                    }
                }
            } 

        }
    }

    function _hasMoreIndex(){
        for(var i=0; i&lt;len; i++){
            var _node = nodes[i];
            if(!visitedNodes[_node.id]){
                return i;            
            }
        }
        return -1;
    }

    function _getAdjacentNodes(node) {
        var retNodes = [];
        edges.forEach(function(edge){
            var adjNodeId, adjNode;

            if(edge.source == node.id){
                adjNodeId = edge.target;
            }

            if(edge.target == node.id){
                adjNodeId = edge.source;
            }

            if(!adjNodeId){
                return;
            }

            if(adjNodeId != node.id){
                if(nodes.map(function(node){return node.id;})
                    .indexOf(adjNodeId) >= 0){
                    adjNode = sigma.utils.getNodeById(nodes, adjNodeId);
                    retNodes.push(adjNode);
                }
            }
        });
        return retNodes;
    }

};   </code></pre>
<h4> 4.1.18 avoidSameLevelTravelThrough()</h4>
<p><code>avoidSameLevelTravelThrough(nodesOfSameLevel, edges)</code>：层次布局中，属于<code>同一层级</code>的所有节点中，<code>非靠近</code>节点之间存在边相连，调整中间节点的<code>上下位置</code>，<code>避免</code>边<code>穿过</code>中间节点，造成不直观的效果。</p>
<pre data-script="javascript"><code>sigma.utils.avoidSameLevelTravelThrough
    = function(nodesOfSameLevel, edges) {

    if(!nodesOfSameLevel){
        console.log(arguments.callee
            , 'nodesOfSameLevel is null');
        return;
    }

    var nodes = nodesOfSameLevel 
        , edges = edges || []
        , unit = unit || 1
        , node, fromNode, toNode
        , len = nodes.length
        , i, j, k
        ;

    nodes.forEach(function(node){
        delete node._wt_dy;
    });

    for(i=0; i&lt;len; i++){
        fromNode = nodes[i];
        for(j=i+2; j&lt;len; j++){
            toNode = nodes[j];
            if(_isConnected(fromNode, toNode)){
                for(k=i+1; k&lt;j; k++){
                    node = nodes[k];     
                    // adjust once
                    if(node._wt_dy) {
                        continue;
                    }
                    node._wt_dy = ( k % 2 == 0 ? -1 : 1 );
                }
            }
        }
    } 

    function _isConnected(fromNode, toNode){
        for(var i=0; i&lt;edges.length; i++){
            var edge = edges[i];
            if(edge.source == fromNode.id
                    &amp;&amp; edge.target == toNode.id
                || edge.source == toNode.id
                    &amp;&amp; edge.target == fromNode.id) {
                return 1;
            } 
        }
        return 0;
    }

};   </code></pre>
<h4> 4.1.19 avoidChildrenTravelThrough()</h4>
<p><code>avoidChildrenTravelThrough(parent, edges)</code>：层次布局中，属于<code>同一父节点</code>的所有<code>兄弟</code>节点中，<code>非靠近</code>节点之间存在边相连，调整中间节点的<code>上下位置</code>，<code>避免</code>边<code>穿过</code>中间节点，造成不直观的效果。</p>

<pre data-script="javascript"><code>sigma.utils.avoidChildrenTravelThrough
    = function(parentNode, edges) {

    if(!parentNode || !parentNode._wt_children){
        console.log(arguments.callee
            , 'parentNode is null or parentNode._wt_children is not existed');
        return;
    }

    sigma.utils.avoidSameLevelTravelThrough(
        parentNode._wt_children
        , edges
    );
};  </code></pre>
<h3> 4.2 常用方法验证 </h3>


<h4> 4.2.1 验证一</h4>
<p>以下验证<code>sortByNodesDegree</code>, <code>getLayoutForest</code>, <code>computeLeaves</code>, <code>widthTravel</code>以及<code>depthTravel</code>等方法：</p>

<div id="test_35" class="test">
<div class="test-console"></div>
<div class="test-container">
<div id="test_35_graph" class="test-graph"></div>
<pre data-script="javascript editable"><code>(function(){

    var s = fly.createShow('#test_35');
    var g = getRandomGraph(5, 10, 18);
    var g = networkGraph_simpletree_0528;
    var color = fly.randomColor();
    var g1 = {
            nodes: [
                {id: 'n2', x: 0.1, y: -0.1, size: 1, label: '(1000, -1000)', color: color}
                , {id: 'n0', x: 0, y: 0, size: 1, label: '(0, 0)', color: color}
                , {id: 'n1', x: 0.1, y: 0.1, size: 1, label: '(1000, 1000)', color: color}
                , {id: 'n3', x: 0.2, y: 0, size: 1, label: '(2000, 0)', color: color}
                , {id: 'n4', x: 0.1, y: 0, size: 1, label: '(1000, 0)', color: color}
            ]
            , edges: [
                { id: 'e0', source: 'n0', target: 'n2' }
                , { id: 'e1', source: 'n1', target: 'n3' }
            ]
        };
    var containerId = 'test_35_graph';
    var rendererSettings = {
            // captors settings
            doubleClickEnabled: true
            , mouseWheelEnabled: false

            // rescale settings
            , minEdgeSize: 0.5
            , maxEdgeSize: 1
            , minNodeSize: 1 
            , maxNodeSize: 5

            // renderer settings
            , edgeHoverColor: fly.randomColor() 
            , edgeHoverSizeRatio: 1
            , edgeHoverExtremities: true
        };
    var sigmaSettings = {
            // rescale settings 
            sideMargin: 0.1 

            // instance global settings
            , enableEdgeHovering: true
            , edgeHoverPrecision: 5
            , autoRescale: false
        };
    var sm;
    if((sm = isSigmaInstanceExisted('test_35'))){
        sm.kill();
    };

    sm = getUniqueSigmaInstance(
            'test_35'
            , {
                settings: sigmaSettings 
                , graph: g
                , renderers: [
                    {
                        type: 'canvas' 
                        , container: $('#' + containerId)[0]
                        , settings: rendererSettings
                    }
                ]
            }
        );

    sm.graph
        .clear()
        .read(g)
        ;
    sm.refresh();

    s.show('start sortByNodesDegree: ');
    s.append_show('Input: ', sm.graph.nodes().map(function(node){return { id: node.id };}));
    sm.graph
        .sortByNodesDegree(1)
        ;
    s.append_show('Output: ', sm.graph.nodes().map(
            function(node){return { id: node.id, degree: node.degree };}
        )
    );

    s.append_show('');
    s.append_show('start getLayoutForest: ');
    var forest = sm.graph
        .getLayoutForest({root: sm.graph.nodes('n0')})
        ;
    s.append_show(
        'layout forest has ' + forest.length + ' trees'
        , forest
    );

    s.append_show('');
    s.append_show('start computeLeaves: ');
    sigma.utils.computeLeaves(forest);
    s.append_show('tree width', forest.map(function(tree){return tree._wt_leaves;}));

    s.append_show('');
    s.append_show('start widthTravel: ');
    forest.forEach(function(tree){
        sm.graph
            .widthTravel(
                tree
                , {
                    onNode: function(node){
                        s.append_show(
                            'visit', node.id
                            , 'level: ' + node._wt_level
                            , 'leaves: ' + node._wt_leaves
                            , 'children: ' 
                                + ( 
                                    node._wt_children
                                    ? node._wt_children.map(function(_node){
                                        return _node.id;
                                    }).join(', ')
                                    : ''
                                )
                        );
                    }
                }
            )
            ;
    });

    s.append_show('');
    s.append_show('start depthTravel: ');
    sm.graph
        .depthTravel(
            sm.graph.nodes('n0')
            , {
                onNode: function(node){
                    s.append_show(
                        'visit', node.id
                        , 'level: ' + node._dt_level
                    );
                }
            }
        )
        ;

    var cam0 = sm.cameras[0];
    // solution 1
    // cam0.settings('autoRescale', true);
    // solution 2
    sigma.middlewares.rescale.call(
        sm
        , ''
        , ''
        , {
            width: sm.renderersPerCamera[cam0.id][0].width
            , height: sm.renderersPerCamera[cam0.id][0].height
            , autoRescale: ['nodePosition']
            , scalingMode: 'inside'
            , rescaleIgnoreSize: 0
        }
    );
    sm.refresh();

})(); </code></pre>
</div>
<div class="test-panel">
</div>
</div>



<h4> 4.2.2 验证二</h4>
<p>以下验证<code>getMaxDegreeNode</code>, <code>getCircleForest</code>等方法：</p>

<div id="test_35_5" class="test">
<div class="test-console"></div>
<div class="test-container">
<div id="test_35_5_graph" class="test-graph"></div>
<pre data-script="javascript editable"><code>(function(){

    var s = fly.createShow('#test_35_5');
    var g = getRandomGraph(5, 10, 1);
    var g = networkGraph_2circles_0523;
    var containerId = 'test_35_5_graph';
    var rendererSettings = {
            // captors settings
            doubleClickEnabled: true
            , mouseWheelEnabled: false

            // rescale settings
            , minEdgeSize: 0.5
            , maxEdgeSize: 1
            , minNodeSize: 1 
            , maxNodeSize: 5

            // renderer settings
            , edgeHoverColor: fly.randomColor() 
            , edgeHoverSizeRatio: 1
            , edgeHoverExtremities: true
        };
    var sigmaSettings = {
            // rescale settings 
            sideMargin: 0.1 

            // instance global settings
            , enableEdgeHovering: true
            , edgeHoverPrecision: 5
        };
    var sm;
    if((sm = isSigmaInstanceExisted('test_35_5'))){
        sm.kill();
    };

    sm = getUniqueSigmaInstance(
            'test_35_5'
            , {
                settings: sigmaSettings 
                , graph: g
                , renderers: [
                    {
                        type: 'canvas' 
                        , container: $('#' + containerId)[0]
                        , settings: rendererSettings
                    }
                ]
            }
        );

    sm.graph
        .clear()
        .read(g)
        ;
    sm.refresh();

    var circuits 
            = sm.graph
                .getCircuits(sm.graph.nodes('n0'));

    s.show('start getCircuits: ');
    s.append_show(circuits.length + ' circuits.'); 
    circuits.forEach(function(circuit){
        s.append_show(
            circuit.map(
                function(node){
                    return node.id;
                }
            )
        );
    });

    var forest = sm.graph.getCircleForest();
    sigma.utils.computeLeaves(forest);

    // 控制台中验证
    // console.log(forest);

    s.append_show('start getMaxDegreeNode:');
    var maxDegreeNode = sm.graph.getMaxDegreeNode();
    s.append_show(maxDegreeNode.id);

})(); </code></pre>
</div>
<div class="test-panel">
</div>
</div>


<h4> 4.2.3 验证三</h4>
<p>图形化展示，验证从<code>图形</code>获得<code>遍历森林</code>的过程：</p>

<div id="test_36" class="test">
<div class="test-container">
<div id="test_36_graph" class="test-graph">
<div class="test-graph-left"></div>
<div class="test-graph-right"></div>
</div>
<div class="test-console"></div>
<pre data-script="javascript editable"><code>
(function(){

    var s = fly.createShow('#test_36');
    var g1 = getRandomGraph(10, 10, 1);
    var g1 = networkGraph_FR;
    // var g1 = networkGraph_ForceAtlas2;
    var g2 = {
            nodes: g1.nodes.slice()
            , edges: g1.edges.slice()
        }
        , g3 = {
            nodes: g1.nodes.slice()
            , edges: [] 
        }
        ;
    var containerId = 'test_36_graph';
    var rendererSettings = {
            // captors settings
            doubleClickEnabled: true
            , mouseWheelEnabled: false

            // rescale settings
            , minEdgeSize: 0.5
            , maxEdgeSize: 1
            , minNodeSize: 1 
            , maxNodeSize: 5

            // renderer settings
            , edgeHoverColor: fly.randomColor() 
            , edgeHoverSizeRatio: 1
            , edgeHoverExtremities: true
        };
    var sigmaSettings = {
            // rescale settings 
            sideMargin: 0.1 

            // instance global settings
            , enableEdgeHovering: true
            , edgeHoverPrecision: 5
        };

    var sm1, sm2;

    if((sm1 = isSigmaInstanceExisted('test_36_left'))
        &amp;&amp; (sm2 = isSigmaInstanceExisted('test_36_right'))){
        sm1.kill();
        sm2.kill();
    };

    sm1 = getUniqueSigmaInstance(
                'test_36_left'
                , {
                    settings: sigmaSettings 
                    , graph: g1
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-left')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm2 = getUniqueSigmaInstance(
                'test_36_right'
                , {
                    settings: sigmaSettings 
                    , graph: g2
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-right')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm1.refresh();

    var forest = sm2.graph.getLayoutForest()
        , index = 0
        ;

    sigma.utils.computeLeaves(forest);
    forest.forEach(function(tree){

        depthTravel(tree);

        function depthTravel(node){
            var children = node._wt_children
                ;
            if(children.length > 0){
                children.forEach(function(child){
                    depthTravel(child);
                    g3.edges.push({
                        id: 'e' + index++ 
                        , source: node.id
                        , target: child.id
                        , color: '#ccc'
                    });
                }); 
            }
        }

    });

    s.show('遍历森林结果：');
    s.append_show(
        forest.length + '棵树'
        , forest.map(function(tree){return tree.id;})
        , '树宽', forest.map(function(tree){return tree._wt_leaves;})
    );

    sm2.graph
        .clear()
        .read(g3)
        ;
    sm2.refresh();

})(); </code></pre>
</div>
<div class="test-panel"></div>
</div>



<h4> 4.2.4 验证四</h4>

<p>验证<code>adjustSiblingsOrder</code>, <code>avoidChildrenTravelThrough</code>等方法。</p>


<div id="test_37" class="test">
<div class="test-container">
<div id="test_37_graph" class="test-graph">
<div class="test-graph-left"></div>
<div class="test-graph-right"></div>
</div>
<div class="test-console"></div>
<pre data-script="javascript editable"><code>
(function(){

    var s = fly.createShow('#test_37');
    var g1 = getRandomGraph(10, 10, 1);
    var g1 = networkGraph_edges_between_the_same_level_nodes_2;
    var g2 = networkGraph_edges_between_the_same_level_nodes;
    var containerId = 'test_37_graph';
    var rendererSettings = {
            // captors settings
            doubleClickEnabled: true
            , mouseWheelEnabled: false

            // rescale settings
            , minEdgeSize: 0.5
            , maxEdgeSize: 1
            , minNodeSize: 1 
            , maxNodeSize: 5

            // renderer settings
            , edgeHoverColor: fly.randomColor() 
            , edgeHoverSizeRatio: 1
            , edgeHoverExtremities: true
        };
    var sigmaSettings = {
            // rescale settings 
            sideMargin: 5 

            // instance global settings
            , enableEdgeHovering: true
            , edgeHoverPrecision: 5
        };

    var sm1, sm2;

    if((sm1 = isSigmaInstanceExisted('test_37_left'))
        &amp;&amp; (sm2 = isSigmaInstanceExisted('test_37_right'))){
        sm1.kill();
        sm2.kill();
    };

    sm1 = getUniqueSigmaInstance(
                'test_37_left'
                , {
                    settings: sigmaSettings 
                    , graph: g1
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-left')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm2 = getUniqueSigmaInstance(
                'test_37_right'
                , {
                    settings: sigmaSettings 
                    , graph: g2
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-right')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    var forest = sm1.graph.getLayoutForest()
        ;

    forest.forEach(function(tree){

        s.show('before order adjusting:');
        s.append_show(
            tree._wt_children.map(function(node){
                return node.id;
            })
        );

        sigma.utils.adjustSiblingsOrder(tree, sm1.graph.edges());

        s.append_show('after order adjusting:');
        s.append_show(
            tree._wt_children.map(function(node){
                return node.id;
            })
        );

        tree = sm1.graph.nodes('n3'); 
        s.append_show('before order adjusting:');
        s.append_show(
            tree._wt_children.map(function(node){
                return node.id;
            })
        );

        sigma.utils.adjustSiblingsOrder(tree, sm1.graph.edges());

        s.append_show('after order adjusting:');
        s.append_show(
            tree._wt_children.map(function(node){
                return node.id;
            })
        );
    });

    sm1.refresh();

    forest = sm2.graph.getLayoutForest();

    forest.forEach(function(tree){

        tree = sm2.graph.nodes('n0'); 
        s.append_show('\nbefore travel through adjusting:');
        s.append_show(
            tree._wt_children.map(function(node){
                return node.id + ':' + ( node._wt_dy || 0 );
            })
        );

        sigma.utils.avoidChildrenTravelThrough(tree, sm2.graph.edges());

        s.append_show('after travel through adjusting:');
        s.append_show(
            tree._wt_children.map(function(node){
                return node.id + ':' + ( node._wt_dy || 0 );
            })
        );
    });

    sm2.refresh();

})(); </code></pre>
</div>
<div class="test-panel"></div>
</div>



<h3> 4.3 矩阵布局</h3>

<h4> 4.3.1 算法描述</h4>
<p>将节点按<code>方阵</code>排列。</p>
<p>todo:</p>
<ol><li><code>部分</code>节点按方阵排列</li>
<li>对于<code>新加入</code>的节点按方阵排列</li></ol>
<h4> 4.3.2 算法实现</h4>
<p><code>矩阵布局</code>算法：</p>
<pre data-script="javascript"><code>sigma.utils.getGridLayout
    = function(nodes, options){

    if(!nodes || !nodes.length){
        return;
    }

    var opt = options || {}
        , r = Math.ceil(Math.sqrt(nodes.length))
        , i = 0
        , j = 0
        , nodeSize = nodes[0].size || 1
        , step = opt.space || nodeSize  * 3 
        , center = opt.center
        , rect
        , ltPoint
        ;

    if(!center){
        rect = sigma.utils.getNodesRect(nodes, opt);
        center = {
            x: rect.x + rect.w / 2
            , y: rect.y + rect.h / 2
        };
    }

    ltPoint = {
        x: center.x - step * ( r - 1 ) / 2
        , y: center.y - step * ( r - 1 ) / 2
    };

    nodes.forEach(function(node){
        node.grid_x = j * step + ltPoint.x;
        node.grid_y = i * step + ltPoint.y; 
        j++;
        if(j >= r) {
            j = 0;
            i++;
        }
    });

    return nodes;
};

sigma.prototype.layoutGrid = function(options){
    sigma.utils.getGridLayout(this.graph.nodes(), options);
    return this;
}  </code></pre>
<div id="test_39" class="test">
<div class="test-console"></div>
<div class="test-container">
<pre data-script="javascript editable"><code>(function(){

    var s = fly.createShow('#test_39');
    var g = getRandomGraph(4, 0, 1);
    // var g = networkGraph_forest_0527;
    var sm = getUniqueSigmaInstance('test_39');
    sm.graph
        .clear()
        .read(g)
        ;
    sm
        .layoutGrid({
            center: {x:100, y:100}
            , space: 10
        })
        ;
    s.show(sm.graph.nodes());

})(); </code></pre>
</div>
<div class="test-panel">
</div>
</div>


<h4> 4.3.3 算法演示</h4>
<p>以下为演示区：</p>

<div id="test_40" class="test">
<div class="test-container">
<div id="test_40_graph" class="test-graph">
<div class="test-graph-left"></div>
<div class="test-graph-right"></div>
</div>
<div class="test-console"></div>
<pre data-script="javascript editable"><code>
(function(){

    var s = fly.createShow('#test_40');
    // var g1 = getRandomGraph(49, 100, 1);
    // var g1 = networkGraph_FR;
    // var g1 = networkGraph_ForceAtlas2;
    var g1 = networkGraph_grid_0521; 
    var g1 = networkGraph_tree_0521;
    var g1 = networkGraph_2circles_0523;
    var g1 = networkGraph_edges_between_the_same_level_nodes;
    var g1 = networkGraph_edges_between_the_same_level_nodes_2;
    var g1 = networkGraph_many_children_0526;
    // var g1 = networkGraph_forest_0527;
    var g2 = {
            nodes: g1.nodes.slice()
            , edges: g1.edges.slice() 
        };
    var containerId = 'test_40_graph';
    var rendererSettings = {
            // captors settings
            doubleClickEnabled: true
            , mouseWheelEnabled: false

            // rescale settings
            , minEdgeSize: 0.5
            , maxEdgeSize: 1
            , minNodeSize: 1 
            , maxNodeSize: 5

            // renderer settings
            , edgeHoverColor: fly.randomColor() 
            , edgeHoverSizeRatio: 1
            , edgeHoverExtremities: true
            , drawLabels: false
        };
    var sigmaSettings = {
            // rescale settings 
            sideMargin: 10 

            // instance global settings
            , enableEdgeHovering: true
            , edgeHoverPrecision: 5
        };

    var sm1, sm2;

    if((sm1 = isSigmaInstanceExisted('test_40_left'))
        &amp;&amp; (sm2 = isSigmaInstanceExisted('test_40_right'))){
        sm1.kill();
        sm2.kill();
    };

    sm1 = getUniqueSigmaInstance(
                'test_40_left'
                , {
                    settings: sigmaSettings 
                    , graph: g1
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-left')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm2 = getUniqueSigmaInstance(
                'test_40_right'
                , {
                    settings: sigmaSettings 
                    , graph: g2
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-right')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm1.refresh();
    sm2.layoutGrid();
    sm2.refresh();

    setTimeout(function(){
        sigma.plugins.animate(
            sm2
            , {
                x: 'grid_x'
                , y: 'grid_y'
            }
            , {
                duration: 1000
            }
        );

    }, 500);

})(); </code></pre>
</div>
<div class="test-panel"></div>
</div>



<h3> 4.4 层次布局</h3>

<h4> 4.4.1 算法描述</h4>
<p><code>相关概念</code>：</p>
<ol><li>选定一个<code>中心</code>节点，对图进行<code>广度遍历</code>，形成一片<code>遍历森林</code>（或者叫做<code>布局森林</code>）</li>
<li><code>布局森林</code>中每个节点在以它为根的子树上拥有的<code>叶子节点数</code>(<code>node._wt_leaves</code>)，决定其在层次布局中的<code>宽度</code>；每个节点在遍历树中的<code>层级</code>(<code>node._wt_level</code>)，决定其在层次布局中的<code>层次</code>。</li>
<li><code>布局森林</code>包含一到多棵<code>布局树</code>，对于每棵<code>布局树</code>，其<code>根节点</code>的<code>叶子节点数</code>为<code>leaves</code>，其节点的<code>最大层级</code>为<code>level</code>，在布局的时候将该布局树在尺寸为<code>leaves*level</code>的<code>网格</code>上进行<code>均衡</code>分布。 </li></ol>
<p><code>优化策略</code>：</p>
<ol><li><code>同层</code>兄弟节点有边，通过调整让<code>有边</code>的兄弟节点<code>靠近</code></li>
<li>避免<code>同层</code>其他边<code>穿过</code>节点<code>中心</code></li>
<li>两个<code>上层</code>节点同时与一个<code>下层</code>节点<code>有边</code>，通过调整让有边的兄弟节点<code>靠近</code></li>
<li><code>大量</code>同层<code>叶子型</code>节点，形成矩阵</li></ol>
<p><code>适用场景</code>：</p>
<ol><li>边数<code>不大于</code>点数的图形。</li></ol>
<h4> 4.4.2 算法实现</h4>
<p><code>层次布局算法</code>(<code>无优化</code>)：</p>
<pre data-script="javascript"><code>sigma.prototype.layoutHierarchy
    = function(options){

    var opt = options || {} 
        , forest = this.graph.getLayoutForest(opt)
        , treeOffsetX = 0
        , unit = opt.unit || 1
        ;

    sigma.utils.computeLeaves(forest);

    forest.forEach(function(tree){

        depthTravel(tree, treeOffsetX);
        treeOffsetX += unit * tree._wt_leaves;

        function depthTravel(node, parentX){
            var children = node._wt_children
                , leaves = node._wt_leaves
                , level = node._wt_level - 1
                , parentX = parentX || 0
                , currentX = 0
                ;

            node.hier_x = parentX + unit * leaves / 2;
            node.hier_y = unit * level;

            if(children.length > 0){
                children.forEach(function(child){
                    depthTravel(child, parentX + currentX);
                    currentX += unit * child._wt_leaves;
                }); 
            }
            delete node._wt_children;
        }

    });

    return this;
};   </code></pre>
<p><code>层次布局算法</code>(<code>使用均衡优化</code>、<code>优化策略1</code>、<code>优化策略2</code>)：</p>

<pre data-script="javascript"><code>sigma.prototype.layoutHierarchy2
    = function(options){

    var opt = options || {} 
        , me = this
        , forest = me.graph.getLayoutForest(opt)
        , treeOffsetX = 0
        , unit = opt.unit || 1
        , edges = me.graph.edges()
        ;

    sigma.utils.computeLeaves(forest);

    forest.forEach(function(tree){

        var maxLevel = 1
            , nodesOfSameLevel = {}
            , avoidSameLevelTravelThrough = opt.avoidSameLevelTravelThrough
            , delta = opt.avoidSameLevelTravelThroughDelta || 0.2
            ;

        depthTravel(tree, treeOffsetX * unit);
        tree._wt_maxlevel = maxLevel;
        tree._hier_offsetx = treeOffsetX;
        treeOffsetX += tree._wt_leaves;
        if(avoidSameLevelTravelThrough){
            for(var i in nodesOfSameLevel){
                sigma.utils.avoidSameLevelTravelThrough(
                    nodesOfSameLevel[i]
                    , edges
                );
                nodesOfSameLevel[i].forEach(function(node){
                    node.hier_y += 
                        ( node._wt_dy || 0 ) * ( delta || 0.2 ) * unit;
                    delete node._wt_dy;
                });
            }
        }

        function depthTravel(node, parentX){
            var children = node._wt_children
                , leaves = node._wt_leaves
                , level = node._wt_level
                , parentX = parentX || 0
                , currentX = 0
                ;

            if(opt.adjustSiblingsOrder){
                sigma.utils.adjustSiblingsOrder(node, edges);
            }

            if(avoidSameLevelTravelThrough){
                ( nodesOfSameLevel[level] 
                    = nodesOfSameLevel[level] || [] )
                    .push(node);
            }

            if(level > maxLevel) {
                maxLevel = level;
            }

            node.hier_x = parentX + unit * leaves / 2;
            node.hier_y = unit * ( level - 1 ); 

            if(children.length > 0){
                children.forEach(function(child){
                    depthTravel(child, parentX + currentX);
                    currentX += unit * child._wt_leaves;
                }); 
            }
        }

    });

    var grid = new Grid(40, 40)
        , debug = 0
        ;

    forest.sort(function(a, b){
        return Math.max(b._wt_leaves, b._wt_maxlevel)
            - Math.max(a._wt_leaves, a._wt_maxlevel);
    });

    forest.forEach(function(tree){
        var spaceBlock = sigma.utils.computeHierarchyTreeRect(
                tree
                , tree._hier_offsetx
            )
            ;

        grid.placeBlock(tree.id, spaceBlock, debug);
    });

    var output = grid.grid.map(
            function(row){
                return row.join('  ');
            }
        ).join('\n');

    debug &amp;&amp; console.log(output);

    forest.forEach(function(tree){
        var spaceBlock = grid.getBlockRect(tree.id)
            , dx = ( spaceBlock.gridPos.x - spaceBlock.x ) * unit
            , dy = ( spaceBlock.gridPos.y - spaceBlock.y ) * unit
            ;

        _depthTravel(tree);

        function _depthTravel(node){
            var children = node._wt_children
                ;

            node.hier_x += dx;
            node.hier_y += dy;

            if(children.length > 0){
                children.forEach(function(child){
                    _depthTravel(child);
                });
                delete node._wt_children;
            }
        }
    });

    return this;
};    </code></pre>
<h4> 4.4.3 算法演示</h4>

<p>以下示例展示树状<code>层次</code>布局算法：</p>

<div id="test_50" class="test">
<div class="test-container">
<div id="test_50_graph" class="test-graph">
<div class="test-graph-left"></div>
<div class="test-graph-right"></div>
</div>
<div class="test-console"></div>
<pre data-script="javascript editable"><code>
(function(){

    var s = fly.createShow('#test_50');
    // var g1 = getRandomGraph(20, 18, 8);
    // var g1 = networkGraph_FR;
    // var g1 = networkGraph_ForceAtlas2;
    var g1 = networkGraph_grid_0521; 
    var g1 = networkGraph_tree_0521;
    var g1 = networkGraph_2circles_0523;
    var g1 = networkGraph_edges_between_the_same_level_nodes;
    var g1 = networkGraph_edges_between_the_same_level_nodes_2;
    var g1 = networkGraph_tree_0524;
    var g1 = networkGraph_many_children_0526;
    var g1 = networkGraph_edges_between_the_same_level_nodes_3;
    var g2 = {
            nodes: g1.nodes.slice()
            , edges: g1.edges.slice()
        }
        , g3 = {
            nodes: g1.nodes.slice()
            , edges: [] 
        }
        ;
    var containerId = 'test_50_graph';
    var rendererSettings = {
            // captors settings
            doubleClickEnabled: true
            , mouseWheelEnabled: false

            // rescale settings
            , minEdgeSize: 0.5
            , maxEdgeSize: 1
            , minNodeSize: 1 
            , maxNodeSize: 5

            // renderer settings
            , edgeHoverColor: fly.randomColor() 
            , edgeHoverSizeRatio: 1
            , edgeHoverExtremities: true
        };
    var sigmaSettings = {
            // rescale settings 
            sideMargin: 0.1 

            // instance global settings
            , enableEdgeHovering: true
            , edgeHoverPrecision: 5
            , autoRescale: 0
        };

    var sm1, sm2;

    if((sm1 = isSigmaInstanceExisted('test_50_left'))
        &amp;&amp; (sm2 = isSigmaInstanceExisted('test_50_right'))){
        sm1.kill();
        sm2.kill();
    };

    sm1 = getUniqueSigmaInstance(
                'test_50_left'
                , {
                    settings: sigmaSettings 
                    , graph: g1
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-left')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm2 = getUniqueSigmaInstance(
                'test_50_right'
                , {
                    settings: sigmaSettings 
                    , graph: g2
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-right')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm1
        .normalizeSophonNodes()
        .alignCenter({rescaleToViewport: 1})
        .refresh()
        ;

    sm2
        .normalizeSophonNodes()
        .alignCenter({rescaleToViewport:1})
        .refresh() // note: must invoke `refresh()` to update coordinates

        .layoutHierarchy2({
            unit: 50
            , adjustSiblingsOrder: 1
            , avoidSameLevelTravelThrough: 1
            , avoidSameLevelTravelThroughDelta: 0.2
        })
        .normalizeSophonNodes({
            readPrefix: 'hier_'
        })
        .alignCenter({
            wholeView: 1
            , readPrefix: 'hier_'
            , writePrefix: 'hier_'
        })
        ;

    setTimeout(function(){
        sigma.plugins.animate(
            sm2
            , {
                x: 'hier_x'
                , y: 'hier_y'
            }
            , {
                duration: 1000
            }
        );

    }, 500);

})(); </code></pre>
</div>
<div class="test-panel"></div>
</div>





<h3> 4.5 块布局</h3>
<p>todo</p>

<h3> 4.6 环形布局</h3>

<h4> 4.6.1 算法描述</h4>
<p><code>环形布局算法</code>：</p>
<p>从<code>中心点</code>root开始，对图进行<code>环形</code>布局。</p>
<ol><li>从<code>中心点</code>开始，获取图的<code>环形广度遍历森林</code>。可能包含<code>多棵</code>遍历树。</li>
<li>针对每棵遍历树<code>tree</code>，计算中心点的<code>回路</code>，若<code>有回路</code>，<code>goto 3</code>，<code>无回路</code>，<code>goto 4</code></li>
<li>若<code>中心点</code>在一个<code>回路</code>中，则选取包含中心点的<code>最长回路</code>，将该回路的所有节点分布在<code>第一层</code>圆环上，然后将以每个节点为根的<code>布局树</code><code>按层次</code>排布在<code>外面</code>的<code>圆环</code>上</li>
<li>若中心点<code>不在</code>任何回路中，则中心点放置在图形<code>中点</code>，然后将以中心点为根的<code>布局树</code>按<code>层次</code>排布在<code>外面</code>的<code>圆环</code>上</li></ol>
<p><code>参数</code>：</p>
<ul><li><code>angleStep</code>，在圆环上排布节点时的角度增量，该值对于不同层次的圆环不能一致，一般与半径成反比</li></ul>
<p><code>优化</code>：</p>
<ul><li><code>root</code>选取，以<code>最大度数</code>节点作为获取遍历森林时的起点，可以一定程度上避免<code>边交叉</code>以及<code>树状</code>布局</li>
<li><code>无回路</code>情况的tree，将根节点放置在<code>圆环中心</code></li></ul>
<h4> 4.6.2 算法实现</h4>
<p><code>环形布局</code>简版算法如下，<code>未做</code><code>均衡</code>算法，多棵<code>树</code>之间会产生<code>重叠</code>：</p>
<pre data-script="javascript"><code>sigma.classes.graph.addMethod(
    'layoutCircleSimple'
    , function(){

    var forest = this.getCircleForest()
        , treeOffsetX = 0
        , PI = Math.PI
        , radius = 0.5 
        , radiusStep = radius 
        , initialAngleStep = 20 * PI / 180
        , angleStep = initialAngleStep
        ;

    sigma.utils.computeLeaves(forest);

    forest.forEach(function(tree){
        var circuit
            , angle = 0
            , maxLevel = 1
            ; 

        // if there is a circuit, layout it with a circle
        if(tree._circuit){
            circuit = tree._circuit;     
            angleStep = 2 * PI / circuit.length;
            circuit.forEach(function(node){
                depthTravel(node, angle, radius);
                angle += angleStep; 
            });
        }
        else {
            depthTravel(tree, angle, 0);
        }
        tree._wt_maxlevel = maxLevel;

        // depthTravel(tree, treeOffsetX);
        // treeOffsetX += tree._wt_leaves;

        function depthTravel(node, angle, radius){
            var children = node._wt_children
                , leaves = node._wt_leaves
                , level = node._wt_level
                , len = children.length
                , circleX
                , circleY
                , angleStep = initialAngleStep / level
                , angleStart = angle - len * angleStep / 2
                , _angle = angleStart + angleStep / 2
                ;

            if(level > maxLevel) {
                maxLevel = level;
            }

            circleX = radius * Math.cos(angle);
            circleY = radius * Math.sin(angle); 

            node.circle_x = circleX;
            node.circle_y = circleY;

            // console.log(radius, angle, circleX, circleY, angleStep);

            if(len > 0){
                children.forEach(function(child){
                    depthTravel(child, _angle, radius + radiusStep);
                    _angle += angleStep;
                }); 
            }
        }

    });

    // console.log(forest);

    return this;
});  </code></pre>
<p>使用<code>均衡布局</code>优化的<code>环形布局</code>算法如下：</p>
<pre data-script="javascript"><code>sigma.prototype.layoutCircle
    = function(options){

    var opt = options || {}
        , forest = this.graph.getCircleForest(opt)
        , treeOffsetX = 0
        , PI = Math.PI
        , radius = opt.radius || 1 
        , radiusStep = radius 
        , initialAngleStep = 15 * PI / 180
        , angleStep = initialAngleStep
        // for tendency
        , angleOffset = 20 * PI / 180
        ;

    sigma.utils.computeLeaves(forest);

    var a = forest.map(function(tree){
        return tree.id 
    }).join(', ');
    // console.log(a);

    forest.forEach(function(tree){
        var circuit
            , angle = PI / 2 
            , maxLevel = 1
            , hasCircuit = tree._circuit ? 1 : 0
            ; 

        // if there is a circuit, layout it with a circle
        if(hasCircuit){
            circuit = tree._circuit;     
            angleStep = 2 * PI / circuit.length;
            circuit.forEach(function(node){
                depthTravel(node, angle, radius);
                angle += angleStep; 
            });
        }
        else {
            depthTravel(tree, angle, 0);
        }
        tree._wt_maxlevel = maxLevel;

        // depthTravel(tree, treeOffsetX);
        // treeOffsetX += tree._wt_leaves;

        function depthTravel(node, angle, radius, tendency){
            var children = node._wt_children
                , leaves = node._wt_leaves
                , level = node._wt_level
                , len = children.length
                , circleX
                , circleY
                , angleStep = initialAngleStep / level
                , angleStart = angle - len * angleStep / 2
                , _angle = angleStart + angleStep / 2
                , tendency = tendency || 1
                ;

            if(level > maxLevel) {
                maxLevel = level;
            }

            circleX = radius * Math.cos(angle);
            circleY = radius * Math.sin(angle); 

            node.circle_x = circleX;
            node.circle_y = circleY;

            // console.log(radius, angle, circleX, circleY, angleStep);

            if(len > 0){

                if(!hasCircuit &amp;&amp; level == 1 &amp;&amp; opt.makeRootCenter){
                    angleStep = 2 * PI / len;  
                }

                if(len == 1) {
                    // _angle = angleStart + ( tendency ? 1 : -1 ) * level * angleOffset;
                }
                children.forEach(function(child){
                    depthTravel(child, _angle, radius + radiusStep, 1 - tendency);
                    _angle += angleStep;
                }); 
            }
        }

    });


    var grid = new Grid(40, 40)
        , debug = 0
        , id = 2
        ;

    forest.sort(function(a, b){
        return b._wt_maxlevel - a._wt_maxlevel;
    });

    forest.forEach(function(tree){
        var spaceBlock = sigma.utils.computeCircleTreeRect(tree)
            ;

        grid.placeBlock(tree.id, spaceBlock, debug);
    });

    var output = grid.grid.map(
            function(row){
                return row.join('  ');
            }
        ).join('\n');

    // console.log(output);

    forest.forEach(function(tree){
        var spaceBlock = grid.getBlockRect(tree.id) 
            , hasCircuit = tree._circuit ? 1 : 0
            , dx = ( 
                    spaceBlock.gridPos.x 
                    + ( hasCircuit ? spaceBlock.w / 2 : 0 ) 
                ) * radius
            , dy = ( 
                    spaceBlock.gridPos.y 
                    + ( hasCircuit ? spaceBlock.h / 2 : 0 ) 
                ) * radius
            ;

        // if there is a circuit
        if(tree._circuit){
            tree._circuit.forEach(function(node){
                depthTravel(node);
            });
            delete tree._circuit;
        }
        else {
            depthTravel(tree);
        }

        function depthTravel(node){
            var children = node._wt_children
                ;

            node.circle_x += dx;
            node.circle_y += dy;

            if(children.length > 0){
                children.forEach(function(child){
                    depthTravel(child);
                }); 
                delete node._wt_children;
            }
        }
    });

    return this;
};   </code></pre>
<p>使用<code>均衡布局</code>、<code>自适应半径</code>优化的<code>环形布局</code>算法：</p>
<ul><li>options.nodeSize，与</li>
<li>options.radiusStep</li>
<li>options.initialAngleRange</li></ul>
<p>算法实现如下：</p>
<pre data-script="javascript"><code>sigma.prototype.layoutCircle2
    = function(options){

    var opt = options || {}
        , forest = this.graph.getCircleForest(opt)
        , treeOffsetX = 0
        , PI = Math.PI
        // `nodeSize` is not exactly `node.size`
        , nodeSize = opt.nodeSize || 0.2
        , radiusStep = opt.radiusStep || 2 
        , initialAngleRange = opt.initialAngleRange || PI 
        , radius
        ;

    sigma.utils.computeLeaves(forest);

    var a = forest.map(function(tree){
        return tree.id 
    }).join(', ');
    // console.log(a);

    forest.forEach(function(tree){
        var circuit
            , angle = PI / 2 
            , maxLevel = 1
            , hasCircuit = tree._circuit ? 1 : 0
            , angleStep
            , config
            ; 

        // if there is a circuit, layout it with a circle
        if(hasCircuit){
            circuit = tree._circuit;     
            config = _getAngleStepAndRadius(
                2 * PI // layout the circuit with a circle
                , nodeSize
                , circuit.length 
                , radiusStep
                , 0
            );
            angleStep = config.angleStep;
            radius = config.radius; 
            circuit.forEach(function(node){
                depthTravel(node, angle, radius);
                angle += angleStep; 
            });
        }
        else {
            depthTravel(tree, angle, 0);
        }
        tree._wt_maxlevel = maxLevel;

        function depthTravel(node, angle, radius){
            var children = node._wt_children
                , leaves = node._wt_leaves
                , level = node._wt_level
                , len = children.length
                , circleX
                , circleY
                , angleRange = initialAngleRange / level
                , config = _getAngleStepAndRadius(
                    angleRange
                    , nodeSize
                    , len || 1
                    , radiusStep
                    , radius
                )
                , _angleStep = config.angleStep 
                , _radius = config.radius
                , angleStart = angle - angleRange / 2
                , _angle = angleStart + _angleStep / 2
                ;

            if(level > maxLevel) {
                maxLevel = level;
            }

            circleX = radius * Math.cos(angle);
            circleY = radius * Math.sin(angle); 

            node.circle_x = circleX;
            node.circle_y = circleY;

            // console.log(radius, angle, circleX, circleY, _angleStep);

            if(len > 0){

                if(!hasCircuit &amp;&amp; level == 1 &amp;&amp; opt.makeRootCenter){
                    _angleStep = 2 * PI / len;  
                }

                children.forEach(function(child){
                    depthTravel(child, _angle, _radius);
                    _angle += _angleStep;
                }); 
            }
        }

    });

    function _getAngleStepAndRadius(
        angleRange, nodeSize, nodeCount, radiusStep, radiusStart){

        var radius
            , angleStep
            , i = 0
            ;

        while(1){
            i++;
            radius = radiusStart + i * radiusStep;
            if(radius * angleRange / ( nodeSize * 3 ) >= nodeCount){
                break;
            } 
        }
        angleStep = angleRange / nodeCount;
        return {
            radius: radius
            , angleStep: angleStep
        };
    }



    var grid = new Grid(40, 40)
        , debug = 0
        , id = 2
        ;

    function _computeTreeRect(tree){
        var nodes = []
            , circuit = tree._circuit
            , rect
            ; 

        if(circuit){
            circuit.forEach(function(node){
                __depthTravel(node);
            });
        }
        else {
            __depthTravel(tree);
        }

        rect = sigma.utils.getNodesRect(
            nodes
            , {
                readPrefix: 'circle_'
                , ignoreNodeSize: 0
            }
        );
        nodes.length = 0;
        tree._tmp_rect = rect; 
        // debug &amp;&amp; console.log(rect);
        return rect;

        function __depthTravel(node){
            var children = node._wt_children
                , len = children.length
                ;

            nodes.push(node);
            if(len > 0){
                children.forEach(function(child){
                    __depthTravel(child); 
                });
            }
        }
    }

    function _normalizeTreeRect(tree, unit){
        var rect = tree._tmp_rect
            , spaceBlock = {}
            ;

        spaceBlock.x = rect.x;
        spaceBlock.y = rect.y;
        // `* 1.1` is reserved space for node-collision on boundaris
        spaceBlock.w = Math.ceil(rect.w * 1.1 / unit);
        spaceBlock.h = Math.ceil(rect.h * 1.1 / unit);
        return spaceBlock;
    }

    forest.forEach(function(tree){
        _computeTreeRect(tree);
    });

    forest.sort(function(a, b){
        return b._tmp_rect.w * b._tmp_rect.h
            - a._tmp_rect.w * a._tmp_rect.h
            ;
    });

    forest.forEach(function(tree){
        var spaceBlock = _normalizeTreeRect(tree, radiusStep) 
            ;

        grid.placeBlock(tree.id, spaceBlock, debug);
    });

    var output = grid.grid.map(
            function(row){
                return row.join('  ');
            }
        ).join('\n');

    debug &amp;&amp; console.log(output);

    forest.forEach(function(tree){
        var spaceBlock = grid.getBlockRect(tree.id) 
            , hasCircuit = tree._circuit ? 1 : 0
            , dx = spaceBlock.gridPos.x * radiusStep - spaceBlock.x
            , dy = spaceBlock.gridPos.y * radiusStep - spaceBlock.y
            ;

        debug &amp;&amp; console.log(tree.id, spaceBlock);

        // clear temporary attribures
        if(tree._tmp_rect){
            delete tree._tmp_rect;
        }

        // if there is a circuit
        if(tree._circuit){
            tree._circuit.forEach(function(node){
                depthTravel(node);
            });
            delete tree._circuit;
        }
        else {
            depthTravel(tree);
        }

        function depthTravel(node){
            var children = node._wt_children
                ;

            node.circle_x += dx;
            node.circle_y += dy;

            if(children.length > 0){
                children.forEach(function(child){
                    depthTravel(child);
                }); 
                delete node._wt_children;
            }
        }
    });

    return this;
};    </code></pre>
<h4> 4.6.3 算法演示</h4>
<p>以下示例展示<code>环形</code>布局算法：</p>

<div id="test_60" class="test">
<div class="test-container">
<div id="test_60_graph" class="test-graph" style="height: 800px">
<div class="test-graph-left-top"></div>
<div class="test-graph-right-top"></div>
<div class="test-graph-left-bottom"></div>
<div class="test-graph-right-bottom"></div>
</div>
<div class="test-console"></div>
<pre data-script="javascript editable"><code>
(function(){

    var s = fly.createShow('#test_60');
    var g1 = getRandomGraph(16, 20, 8);
    // var g1 = networkGraph_FR;
    // var g1 = networkGraph_ForceAtlas2;
    // var g1 = networkGraph0520;
    var g1 = networkGraph_grid_0521; 
    var g1 = networkGraph_tree_0521;
    var g1 = networkGraph_2circles_0523;
    var g1 = networkGraph_edges_between_the_same_level_nodes;
    var g1 = networkGraph_edges_between_the_same_level_nodes_2;
    var g1 = networkGraph_tree_0524;
    var g1 = networkGraph_many_children_0526;

    var g2 = {
            nodes: g1.nodes.slice()
            , edges: g1.edges.slice()
        }
        , g3 = {
            nodes: g1.nodes.slice()
            , edges: g1.edges.slice()
        }
        , g4 = {
            nodes: g1.nodes.slice()
            , edges: g1.edges.slice()
        }
        ;
    var containerId = 'test_60_graph';
    var rendererSettings = {
            // captors settings
            doubleClickEnabled: true
            , mouseWheelEnabled: false

            // rescale settings
            , minEdgeSize: 0.5
            , maxEdgeSize: 1
            , minNodeSize: 1 
            , maxNodeSize: 5

            // renderer settings
            , edgeHoverColor: fly.randomColor() 
            , edgeHoverSizeRatio: 1
            , edgeHoverExtremities: true
            , drawLabels: false
        };
    var sigmaSettings = {
            // rescale settings 
            sideMargin: 0.1 

            // instance global settings
            , enableEdgeHovering: true
            , edgeHoverPrecision: 5
            , autoRescale: false
            , zoomMin: 0.01
            , zoomMax: 100
        };

    var sm1, sm2, sm3, sm4;

    if((sm1 = isSigmaInstanceExisted('test_60_left_top'))
        &amp;&amp; (sm2 = isSigmaInstanceExisted('test_60_right_top'))
        &amp;&amp; (sm3 = isSigmaInstanceExisted('test_60_left_bottom'))
        &amp;&amp; (sm4 = isSigmaInstanceExisted('test_60_right_bottom'))){
        sm1.kill();
        sm2.kill();
        sm3.kill();
        sm4.kill();
    };

    sm1 = getUniqueSigmaInstance(
                'test_60_left_top'
                , {
                    settings: sigmaSettings 
                    , graph: g1
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-left-top')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm2 = getUniqueSigmaInstance(
                'test_60_right_top'
                , {
                    settings: sigmaSettings 
                    , graph: g2
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-right-top')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm3 = getUniqueSigmaInstance(
                'test_60_left_bottom'
                , {
                    settings: sigmaSettings 
                    , graph: g3
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-left-bottom')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 

    sm4 = getUniqueSigmaInstance(
                'test_60_right_bottom'
                , {
                    settings: sigmaSettings 
                    , graph: g4
                    , renderers: [
                        {
                            type: 'canvas' 
                            , container: $('#' + containerId + ' .test-graph-right-bottom')[0]
                            , settings: rendererSettings
                        }
                    ]
                }
            ); 



    sm1
        .normalizeSophonNodes()
        .alignCenter({rescaleToViewport: 1})
        .refresh()
        ;

    sm2
        .normalizeSophonNodes()
        .alignCenter({
            rescaleToViewport: 1
        })
        .refresh()
        .layoutCircle()
        .normalizeSophonNodes({
            readPrefix: 'circle_'
        })
        .alignCenter({
            rescaleToViewport: 1
            , readPrefix: 'circle_'
            , writePrefix: 'circle_'
        })
        ;


    var useNoverlap = 0;
    setTimeout(function(){
        sigma.plugins.animate(
            sm2
            , {
                x: 'circle_x'
                , y: 'circle_y'
            }
            , {
                duration: 1000
                , onComplete: function(){
                    if(!useNoverlap) return;
                    var noverlapListener = sm2.configNoverlap({
                            nodeMargin: 0.1,
                            scaleNodes: 1.05,
                            gridSize: 20,
                            easing: 'quadraticInOut',
                            duration: 5000
                        });
                    sm2.startNoverlap();
                }
            }
        );

    }, 500);

    sm3
        .normalizeSophonNodes()
        .alignCenter({
            rescaleToViewport: 1
        })
        .refresh()
        .layoutCircle({
            makeRootCenter: 1
            , makeMaxDegreeNodeRoot: 1
        })
        .normalizeSophonNodes({
            readPrefix: 'circle_'
        })
        .alignCenter({
            rescaleToViewport: 1
            , readPrefix: 'circle_'
            , writePrefix: 'circle_'
        })
        ;

    setTimeout(function(){
        sigma.plugins.animate(
            sm3
            , {
                x: 'circle_x'
                , y: 'circle_y'
            }
            , {
                duration: 1000
            }
        );

    }, 500);


    /*
    sm4
        .normalizeSophonNodes()
        .alignCenter({
            rescaleToViewport: 1
        })
        .refresh()
        .layoutCircle({
            makeRootCenter: 1
            , makeMaxDegreeNodeRoot: 1
        })
        .normalizeSophonNodes({
            readPrefix: 'circle_'
        })
        .alignCenter({
            rescaleToViewport: 1
            , readPrefix: 'circle_'
            , writePrefix: 'circle_'
        })
        ;
    */

    sm4
        .normalizeSophonNodes()
        .alignCenter({
            rescaleToViewport: 1
        })
        .refresh()
        .layoutCircle2({
            makeRootCenter: 1
            , makeMaxDegreeNodeRoot: 1
            // 设置该值来影响布局，不一定等同于node.size
            , nodeSize: 30
            , radiusStep: 180
            , initialAngleRange: Math.PI / 3
        })
        .normalizeSophonNodes({
            readPrefix: 'circle_'
        })
        .alignCenter({
            wholeView: 1
            , readPrefix: 'circle_'
            , writePrefix: 'circle_'
        })
        ;

    var useLayoutHierarchy = 0;
    setTimeout(function(){
        sigma.plugins.animate(
            sm4
            , {
                x: 'circle_x'
                , y: 'circle_y'
            }
            , {
                duration: 1000
                , onComplete: function(){
                    if(!useLayoutHierarchy) return;
                    setTimeout(function(){
                        sm4
                            .layoutHierarchy()
                            .normalizeSophonNodes({readPrefix: 'hier_'})
                            .alignCenter({
                                rescaleToViewport: 1
                                , readPrefix: 'hier_'
                                , writePrefix: 'hier_'
                            })
                            .refresh()
                            ;

                        sigma.plugins.animate(
                            sm4
                            , {
                                x: 'hier_x'
                                , y: 'hier_y'
                            }
                           , {duration: 1000}
                        ); 
                    }, 1000);
                }

            }
        );

    }, 500);

})(); </code></pre>
</div>
<div class="test-panel"></div>
</div>



<h2> 五、增量布局</h2>
<p>见<code>graph layout2</code></p>





</body>
</html>
<script type="text/javascript" src="/docs/markdown_res/js/footer.js"></script>
<script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
