<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap-theme.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/github-markdown.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/page.css" />
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.min.js"></script>
    <style type="text/css">

    </style>

</head>
<body class="markdown-body">
    <div id="nav" class="row">
<a class="text-info pull-right" href="javascript:history.back()">Back</a>
    </div>

<h1> Koa Memo</h1>

<p>http://koa.bootcss.com</p>
<p>https://github.com/koajs/koa</p>
<p>https://github.com/koajs/koa/wiki</p>
<p>中间件级联：Connect 简单地将控制权交给一系列函数来处理，直到函数返回。 与之不同，当执行到 yield next 语句时，Koa 暂停了该中间件，继续执行下一个符合请求的中间件(<code>downstrem</code>)，然后控制权再逐级返回给上层中间件(<code>upstream</code>)。</p>


<pre><code>var koa = require('koa');
var app = koa();

// x-response-time

app.use(function *(next){
  var start = new Date;
  yield next;
  var ms = new Date - start;
  this.set('X-Response-Time', ms + 'ms');
});

// logger

app.use(function *(next){
  var start = new Date;
  yield next;
  var ms = new Date - start;
  console.log('%s %s - %s', this.method, this.url, ms);
});

// response

app.use(function *(){
  this.body = 'Hello World';
});

app.listen(3000);

console.log('Listening on port 3000');  </code></pre>
<p>Generator函数运行在app上下文中，可以通过<code>this.xxx</code>为上下文添加属性。</p>

<blockquote><p> TypeError: You may only yield a function, promise, generator, array, or object, but the following object was passed: "[object Object]"</p></blockquote><pre><code>router.get('/hello', function *(next) {
    yield * next;
    this.body = yield this.mongo.db('myproject')
        .collection('documents')
        // .find().limit(10);
        .find().limit(10).toArray();
}); </code></pre>
<p>yield后面只允许跟的类型为： function, promise, generator, array 或者 object。
所以以上例子中，<code>limit(10)</code>后面需要使用游标函数<code>toArray()</code>，否则会出现以上错误。</p>




</body>
</html>
<script type="text/javascript" src="/docs/markdown_res/js/footer.js"></script>
<script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
