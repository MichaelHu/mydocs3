<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap-theme.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/github-markdown.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/page.css" />
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.min.js"></script>
    <style type="text/css">

    </style>

</head>
<body class="markdown-body">
    <div id="nav" class="row">
<a class="text-info pull-right" href="javascript:history.back()">Back</a>
    </div>

<h1> Promisejs Memo</h1>

<blockquote><p> 新型异步编程模型</p></blockquote><p>在ES6中已经作为语言的原生支持的特性</p>
<p><code>node 4.0+</code>版本，已经默认支持ES6新特性</p>
<p>co</p>

<h2> Promise的一些理解</h2>

<ul><li>通过<code>.then</code>方法，自动生成新的Promise对象，形成链式调用</li>
<li><code>resolve</code>和<code>reject</code>方法分别作为成功调用和发生错误情况时的处理函数，<p>这两个回调函数可以通过<code>.then</code>方法传递进去，如果不传，则使用默认处理函数。
resolve会将Promise对象的状态从pending设置为resolved，
reject则将Promise对象的状态从pending设置为rejected。
成功或者失败由用户代码决定，也即什么情况下调用resolve和reject是由用户决定的，
比如AJAX请求成功则调用resolve，失败则调用reject。</p>
</li>
<li>如果<code>resolve</code>和<code>reject</code>方法的返回值仍然是一个<code>Promise对象</code>，则该对象会取代<code>.then</code>方法自动生成的Promise对象</li>
<li>默认情况：如果用户没有提供调用reject或者resolve的条件，<code>默认会调用resolve</code>。 </li>
<li>参数传递：默认情况下，上一个Promise对象的resolve方法的返回值，会作为下一个Promise对象的resolve方法的传入值。</li>
<li>错误处理：<code>.catch</code>方法可以捕获error，并且冒泡，通过then链传递往后面传</li></ul>
<h2> Promise.resolve方法</h2>
<p><code>Promise.resolve</code>可将现有对象转换成Promise对象，比如将jQuery的deferred对象转换成Promise对象：</p>
<pre><code>var jsPromise = Promise.resolve($.ajax('/whatever.json')); </code></pre>
<p>如果该方法的参数不是具有then方法的对象，则返回一个新Promise对象，且它的状态为resolved。</p>
<pre><code>Promise.resolve('Hello')
    .then(function(s){
        console.log(s);
    }); </code></pre>
<p>上面代码会生成一个新的Promise对象，它的状态为fulfilled，所以回调函数会立即执行，Promise.resolve方法的
参数就是回调函数的参数。</p>



<h2> async, await</h2>
<p>ES7将会实现</p>

</body>
</html>
<script type="text/javascript" src="/docs/markdown_res/js/footer.js"></script>
<script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
