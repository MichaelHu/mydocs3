<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap-theme.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/markdown-7.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <style type="text/css">
        body {padding: 15px;}
        img {max-width: 100%; border: 1px solid #eee; }
        pre, code {color: #048ebd; }
        li>p {display: block;}
        p>code, li>code {padding:0; font-size: 13px; color: red;}
    </style>
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.js"></script>
</head>
<body>
    <div id="nav" class="row">
<a class="text-info pull-right" href="javascript:history.back()">Back</a>
    </div>

<h1> Backbone解析</h1>
<p>2014-09-29</p>
<h2> AMD、CMD支持</h2>
<pre><code>(function(root, factory){
    // AMD first
    if(typeof define === 'function' &amp;&amp; define.amd){
        define(['underscore', 'jquery', 'exports'], function(_, $, exports){
            root.Backbone = factory(root, exports, _, $);
        });
    } 
    // then Node.js or CommonJS
    else if(typeof exports !== 'undefined'){
        var _ = require('underscore');
        factory(root, exports, _);
    }
    // last global Backbone
    else {
        root.Backbone = factory(root
            , {}, root._
            // $ can be jQuery, Zepto, ender
            , ( root.jQuery || root.Zepto || root.ender || root.$ )
        );
    }
})(this, function(root, Backbone, _, $){
    ...
}); </code></pre>
<h2> Events，可以mixin到任何一个对象，提供自定义事件的功能。</h2>
<ol><li><code>on/bind</code>: function(name, callback, context)</li>
<li><code>once</code>: function(name, callback, context)</li>
<li><code>off/unbind</code>: function(name, callback, context)</li>
<li><code>trigger</code>: function(name)</li>
<li><code>stopListening</code>: function(obj, name, callback)</li>
<li><code>listenTo</code>: function(obj, name, callback)</li>
<li><code>listenToOnce</code>: function(obj, name, callback)</li></ol>
<h2> Model，通常表示数据表的一行</h2>
<h3> 1. 说明</h3>
<ol><li><code>validate</code>对attributes进行验证，返回值error，如果<code>!error == true</code>，则通过验证；<p>否则，属性不会变化，也不会触发change事件。</p>
<p>仅当<code>options.validate标志被设置且model.validate方法存在</code>，才进行属性验证。</p>
<p>只设置options.validate标志或者model.validate方法存在，都不足以促使进行属性验证。</p>
</li>
<li>事件按序触发</li>
<li><code>unset</code>不存在的属性，不会触发<code>change</code>事件</li>
<li><code>this.id</code>代表Model的唯一服务端标识，它的值由以下代码决定：<pre><code>if(this.idAttribute in attrs) this.id = attrs[this.idAttribute]; </code></pre>
<p>也就是说，即使idAttribute并不是<code>id</code>，而是比如说<code>_id</code>，也会生成<code>this.id</code>。</p>
<pre><code>model.unset('_id') </code></pre>
<p>将会重置<code>this.id</code>为<code>undefined</code>，使得其称为一个New Model，即<code>model.isNew()</code>为true</p>
</li>
<li><code>model.sync</code>函数，其error事件在封装的<code>options.error</code>方法中触发</li>
<li><code>save, fetch, destroy</code>都会调用<code>model.sync</code>和服务器进行同步</li>
<li><code>patch</code>方式，若<code>options.attrs不存在</code>，会在options下添加<code>attrs</code>属性</li>
<li>事件触发：<ul><li><code>request</code>：每次发起服务端请求时都会触发，参数为<code>model, xhr, options</code></li>
<li><code>sync</code>：请求成功返回以后触发，参数<code>model, resp, options</code></li>
<li><code>error</code>：请求失败以后触发，参数<code>model, resp, options</code>，同时会设置<code>model.validationError</code></li>
<li><code>change</code>：模型属性发生变化触发，参数<code>model, options</code></li>
<li><code>change:name</code>：模型属性发生变化触发，参数<code>model, attr, options</code></li>
<li><code>invalid</code>：模型验证失败时触发，参数<code>model, error, options</code></li>
<li><code>destroy</code>：发送同步请求前触发，或者同步请求成功返回后触发，参数<code>model, model.collection, options</code></li></ul>
</li>
<li><code>success</code>与<code>error</code>函数参数：<code>model, resp, options</code></li>
<li><code>model.isNew() == true</code>情况下，destroy无需与服务器进行同步</li>
<li>默认情况下，不会进行属性验证，除非传入<code>{validate: true}</code>。model.validate函数接收参数<code>attrs, options</code></li>
<li>嵌套change事件<code>不会改变model._previousAttributes</code></li>
<li><code>change:name</code>事件在所有属性都变化以后才触发</li>
<li>set同样的值，<code>不会触发change和change:name事件</code></li>
<li>unset一个undefined的属性，不会触发change和change:name事件</li>
<li><code>{wait: true}</code>的save方法，如果服务器请求失败，本地属性不会更新</li>
<li><code>Utils.results(model, 'url')</code>必须有返回值，否则无法进行<code>model.sync</code>操作，程序异常</li>
<li><code>{wait: true}</code>的save方法，即使服务器请求失败，本地属性也会进行validate</li>
<li><code>save</code>与<code>fetch</code>都会设置<code>options.parse</code>标志位</li>
<li>嵌套change事件只触发一次<pre><code>var times = 0;
model.on('change:x', function(){
    times++;
    model.set({x: true});
});
model.set({x: true}); </code></pre>
<p>以上代码，<code>times == 1</code></p>
</li>
<li><code>new Model(attrs, options)</code>，其中的attrs和options会<code>原封不动</code>的传入initialize方法，即使它们是<code>undefined</code></li></ol>
<h3> 2. 代码结构</h3>
<ol><li>constructor:<ol><li>cid: _.uniqueId('c')</li>
<li>attributes: {...}</li>
<li>collection: Backbone.Collection</li>
<li>changed: {...}</li></ol>
</li>
<li>prototype:<ol><li>changed: null</li>
<li>validationError: null</li>
<li>idAttribute: 'id'</li>
<li>initialize: function(){}</li>
<li>toJSON: funciton(options)</li>
<li>sync: function(method, model, options)</li>
<li>get: function(attr)</li>
<li>escape: function(attr)</li>
<li>has: function(attr)</li>
<li>set: function(key, val, options)<ul><li>trigger('change:KEYNAME', this, value, options)</li></ul>
</li>
<li>unset: function(attr, options)</li>
<li>clear: function(options)</li>
<li>hasChanged: function(attr)</li>
<li>changedAttributes: function(diff)</li>
<li>previous: function(attr)</li>
<li>previousAttributes: function()</li>
<li>fetch: function(options)<ul><li>trigger('read', this, options)</li>
<li>trigger('sync', model, resp, options)</li></ul>
</li>
<li>save: function(key, val, options)<ul><li>trigger('sync', model, resp, options)</li></ul>
</li>
<li>destroy: function(options)</li>
<li>url: function()</li>
<li>parse: function(resp, options)</li>
<li>clone: function()</li>
<li>isNew: function()</li>
<li>isValid: function(options)</li>
<li>_validate: function(attrs, options)</li>
<li>keys: function() </li>
<li>values: function()</li>
<li>pairs: function()</li>
<li>invert: function()</li>
<li>pick: function()</li>
<li>omit: function()</li>
<li>chain: function()</li>
<li>isEmpty: function()</li></ol>
</li></ol>
<h2> Collection: rows </h2>

<h2> View</h2>

<h3> 1. 说明</h3>
<ol><li><code>view.delegateEvents(events)</code>，会略过未定义的method</li>
<li><code>options.el</code>指定为一个不存在的元素，会导致<code>model.el</code>未定义</li>
<li><code>构造参数：</code><ul><li><code>View</code>: <code>options</code>，包含以下预定义选项：<pre><code>var viewOptions = [
        'model'
        , 'collection'
        , 'el'
        , 'id'
        , 'attributes'
        , 'className'
        , 'tagName'
        , 'events'
    ];             </code></pre>
</li>
<li><code>BaseView</code>: <code>options, parent</code> </li>
<li><code>PageView</code>: <code>options, action, router</code>，action为字符串，router为路由对象。PageView由Router创建，创建后PageView._router保存了对Router的引用。</li>
<li><code>SubView</code>: 同BaseView</li>
<li><code>SubPageView</code>: 同BaseView</li>
<li><code>GlobalView</code>：<code>options, router</code>，router为路由对象</li></ul>
</li></ol>
<h3> 2. 代码结构</h3>
<ol><li>constructor<ol><li>cid: _.unique('view')</li>
<li>attrs maybe:<ul><li>model</li>
<li>collection</li>
<li>el</li>
<li>id</li>
<li>attributes</li>
<li>className</li>
<li>tagName</li>
<li>events</li></ul>
</li>
<li>this._ensureElement()</li>
<li>this.initialize.apply(this, arguments)</li></ol>
</li>
<li>vars<pre><code>var delegateEventSplitter = /^(\S+)\s*(.*)$/; </code></pre>
</li>
<li>prototype<ol><li>tagName: 'div'</li>
<li>$: function(selector)</li>
<li>initialize: function()</li>
<li>render: function()</li>
<li>remove: function()</li>
<li>_removeElement: function()</li>
<li>setElement: function(element)</li>
<li>_setElement: function(el)</li>
<li>delegateEvents: function(events)</li>
<li>delegate: funciton(eventName, selector, listener) </li>
<li>undelegateEvents: function()</li>
<li>undelegate: funciton(eventName, selector, listener)</li>
<li>_createElement: function(tagName)</li>
<li>_ensureElement: function()</li>
<li>_setAttributes: function(attributes)</li></ol>
</li></ol>
<h2> Router</h2>
<h3> 1. 说明</h3>
<ol><li><code>getHash</code>，不包含<code>#</code>。比如：<pre><code>http://path#hash</code></pre>
<p>返回值为：</p>
<pre><code>hash</code></pre>
</li>
<li>路由参数：<pre><code>命名参数：      /[^/?]+/ 
splat参数：     /[^?]*?/
可选参数：      /(?:([^/?]+))?/
查询参数：      /(?:\?([\s\S]*))?$/ </code></pre>
<p><code>说明：</code></p>
<ol><li>命名参数<code>不包含/</code>，splat参数可以<code>包含/</code>，可选参数实际上是可选命名参数</li>
<li>命名参数<code>至少包含一个</code>字符，不能为空；splat参数<code>可以为空</code>，本身具有可选的特性 </li>
<li>查询参数在route尾部，<code>以?开头</code></li>
<li>查询参数解析时，<code>不进行decode</code></li></ol>
</li>
<li>route事件：参数<code>name, args</code> 或 <code>route:name, args</code><pre><code>routes: {
    /* router               route */
    'index/:type':          'index'
} </code></pre>
<p><code>route</code>对应<code>name参数</code>。</p>
</li>
<li>不管路由callback是否存在，<code>总会触发route事件</code></li>
<li><code>router.execute</code>方法如果返回<code>false</code>，则不会触发route事件</li>
<li><code>支持空路由模式</code>：<pre><code>routes: {
    /* router               route */
    '':                     'index'
} </code></pre>
</li>
<li><code>支持默认路由处理器</code>，该处理器自动获取<code>action</code>，以及将对应的<code>命名参数转换成JSON</code>，并传给<code>Router.doAction</code>:<pre><code>routes: {
    "index":                      "_defaultHandler:index",
    "index/:type":                "_defaultHandler:index",
    "index/:type/p:page":         "_defaultHandler:index"
} </code></pre>
<p><code>_defaultHandler</code>是默认实现的方法，<code>冒号(:)</code>后面的非空单词为<code>实际action</code></p>
</li></ol>
<h3> 2. 代码结构</h3>
<ol><li>constructor<ol><li>this.routes = options.routes</li>
<li>this._bindRoutes()</li>
<li>this.initialize.apply(this, arguments)</li></ol>
</li>
<li>vars:<pre><code>optionalParam = /\((.*?)\)/g 
namedParam = /(\(\?)?:\w+/g 
splatParam = /\*\w+/g 
escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g  </code></pre>
</li>
<li>prototype<ol><li>initialize: function() </li>
<li>route: funciton(route, name, callback)</li>
<li>execute: function(callback, args, name)</li>
<li>navigate: function(fragment, options)<p>如果是hash，fragment为hash值（不包含#），如果是pushState，fragment为path值（除去root部分）</p>
</li>
<li>_bindRoutes: function()</li>
<li>_routeToRegExp: function(route)</li>
<li>_extractParameters: function(route, fragment)</li></ol>
</li></ol>
<h2> History</h2>
<ol><li>constructor<ol><li>this.handlers = []</li>
<li>_.bindAll(this, 'checkUrl')</li>
<li>this.location = window.location</li>
<li>this.history = window.history</li></ol>
</li>
<li>vars<pre><code>routeStripper = /^[#\/]|\s+$/g
rootStripper = /^\/+|\/+$/g
pathStripper = /#.*$/ </code></pre>
</li>
<li>static<ol><li>History.started = false</li></ol>
</li>
<li>prototype<ol><li>interval: 50</li>
<li>atRoot: function()</li>
<li>getSearch: function()</li>
<li>getHash: function(window)</li>
<li>getPath: function()</li>
<li>getFragment: function(fragment)</li>
<li>start: function(options)<ul><li>this.options</li>
<li>this.root</li>
<li>this._wantsHashChange</li>
<li>this._hasHashChange</li>
<li>this._wantsPushState</li>
<li>this._hasPushState</li>
<li>this.fragment</li></ul>
</li>
<li>stop: function()</li>
<li>route: function(route, callback)</li>
<li>checkUrl: function(e)</li>
<li>loadUrl: function(fragment)</li>
<li>navigate: function(fragment, options)</li>
<li>_updateHash: function(location, fragment, replace)</li></ol>
</li></ol>
<h2> vars</h2>
<pre><code>var previousBackbone = root.Backbone
var slice = array.slice
var urlError = function()
var wrapError = function(model, options) </code></pre>
<p>比较特殊的<code>extend</code>方法，生成一个子类：</p>
<p>子类可以通过<code>__super__.xxx</code>调用父类原型链的对应方法。</p>
<pre><code>var extend = function(protoProps, staticProps){
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps &amp;&amp; _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
}; </code></pre>
<h2> static attrs and methods</h2>
<ol><li><code>Backbone.sync</code>: function(method, model, options)</li>
<li><code>Backbone.ajax</code>: function()</li>
<li><code>Backbone.history</code> = new History</li>
<li><code>Backbone.VERSION</code> = '1.1.2';</li>
<li><code>Backbone.$</code> = $;</li>
<li><code>Backbone.noConflict</code> = function()</li>
<li><code>Backbone.emulateHTTP</code> = false</li>
<li><code>Backbone.emulateJSON</code> = false</li></ol>

    <script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.js"></script>
</body>
</html>
<script type="text/javascript" src="/docs/markdown_res/js/footer.js"></script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
<script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
