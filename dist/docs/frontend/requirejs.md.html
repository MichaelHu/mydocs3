<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap-theme.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/markdown-7.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/page.css" />
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.js"></script>
</head>
<body>
    <div id="nav" class="row">
<a class="text-info pull-right" href="javascript:history.back()">Back</a>
    </div>

<h1> requirejs相关资料</h1>
<p>2014-09-30</p>
<blockquote><p style="color:green;font-size:18px">RequireJS implements the  Asynchronous Module Definition (formerly Transport/C) proposal.</p></blockquote>




<h2> 使用方式</h2>


<h3> data-main</h3>
<pre><code>&lt;script data-main="scripts/main" src="scripts/require.js">&lt;/script> </code></pre>
<p>以上适用于页面只有一个入口脚本的情况。否则使用<code>内联require</code>的方式。</p>


<h3> 内联require</h3>
<pre><code>&lt;script src="scripts/require.js">&lt;/script>
&lt;script>
// use dependency list
require(['scripts/config']), function() {
    // Configuration loaded now, safe to do other require calls
    // that depend on that config.
    require(['foo'], function(foo) {

    });
});
&lt;/script>     </code></pre>
<h2> 关于baseUrl</h2>
<ul><li>所有的脚本都按相对于<code>baseUrl</code>的路径进行加载。通常同设置为<code>data-main</code>的脚本所在路径。</li>
<li>也可以通过<code>require.config</code>进行设置：<pre><code>require.config({
    baseUrl: "/another/path",
    paths: {
        "some": "some/v1.0"
    },
    waitSeconds: 15
}); </code></pre>
</li>
<li>例外情况，如果module id存在以下情况，则<code>baseUrl</code>不生效：<ul><li>以<code>.js</code>结束</li>
<li>以<code>/</code>开始</li>
<li>包含URL协议，比如<code>http:</code>或者<code>https:</code></li></ul>
<p>当然，推荐使用baseUrl</p>
</li></ul>
<h2> 定义模块</h2>
<ol><li>模块定义恰当处理了作用域，避免污染全局命名空间。</li>
<li>显式列出依赖模块，并且能获得依赖模块的引用，而不需要通过全局对象的方式。使用了<p><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">
模块模式（Module Pattern）</a></p>
</li>
<li>定义方式使得模块能尽可能快的加载，又能按依赖关系顺序执行。</li>
<li>需要了解的Module格式：<code>CommonJS module</code>，<code>RequireJS module</code></li></ol>
<h3> 有哪些方式？</h3>
<ol><li>简单key/value对象<pre><code>// Inside file my/shirt.js:
define({
    color: "black",
    size: "unisize"
}); </code></pre>
</li>
<li>定义函数<pre><code>// my/shirt.js now does setup work
// before returning its module definition.
define(function () {
    // Do setup work here

    return {
        color: "black",
        size: "unisize"
    }
}); </code></pre>
</li>
<li>带有依赖的定义函数<pre><code>// my/shirt.js now has some dependencies, a cart and inventory
// module in the same directory as shirt.js
define(["./cart", "./inventory"], function(cart, inventory) {
        // return an object to define the "my/shirt" module.
        return {
            color: "blue",
            size: "large",
            addToCart: function() {
                inventory.decrement(this);
                cart.add(this);
            }
        }
    }
); </code></pre>
<p><code>注意</code>：有依赖定义情况下，requirejs会认为所有的依赖已经写明在依赖列表中，不会再对
factory函数进行解析，获取其中require行所标示的依赖模块进行提前加载。所以有依赖列表
情况下，必须把所有依赖都写出来。有依赖列表的方式能省去factory函数的解析。</p>
</li>
<li>定义一个模块为函数<p>模块不一定必须返回一个对象，任何有效返回值都是可以的，比如函数。</p>
<pre><code>// A module definition inside foo/title.js. It uses
// my/cart and my/inventory modules from before,
// but since foo/title.js is in a different directory than
// the "my" modules, it uses the "my" in the module dependency
// name to find them. The "my" part of the name can be mapped
// to any directory, but by default, it is assumed to be a
// sibling to the "foo" directory.
define(["my/cart", "my/inventory"],
    function(cart, inventory) {
        // return a function to define "foo/title".
        // It gets or sets the window title.
        return function(title) {
            return title ? (window.title = title) :
                   inventory.storeName + ' ' + cart.name;
        }
    }
); </code></pre>
</li>
<li>用简单CommonJS封装定义一个模块<p>比如要复用<code>CommonJS</code>方式编写的模块，可以用这种方式封装。这种方式全依赖
<code>Function.prototype.toString()</code>，使得requirejs可以通过解析require语句，分析出
依赖关系。</p>
<pre><code>define(function(require, exports, module) {
        var a = require('a'),
            b = require('b');

        // Return the module value
        return function () {};
    }
); </code></pre>
</li>
<li>定义一个带名字的模块<pre><code>// Explicitly defines the "foo/title" module:
define("foo/title",
    ["my/cart", "my/inventory"],
    function(cart, inventory) {
        // Define foo/title object in here.
   }
);    </code></pre>
</li></ol>
<h3> 模块定义注意</h3>
<ol><li>一个文件只定义一个模块</li>
<li>相对模块名的定义，务必将require作为依赖<pre><code>define(["require", "./relative/name"], function(require) {
    var mod = require("./relative/name");
}); </code></pre>
<p>或者更好的方式，可以简写成这样：</p>
<pre><code>define(function(require) {
    var mod = require("./relative/name");
});  </code></pre>
</li>
<li>如何生成相对于模块的路径：<pre><code>define(["require"], function(require) {
    var cssUrl = require.toUrl("./style.css");
});   </code></pre>
</li>
<li>对于已经通过<code>require(['module/name'], function(){})</code>加载了的模块，可以通过以下方式调用其内部函数：<pre><code>require("module/name").callSomeFunction()       </code></pre>
</li></ol>
<h2> 多版本支持</h2>
<p>通过<code>require.config</code>实现：</p>
<pre><code>&lt;script src="../require.js">&lt;/script>
&lt;script>
var reqOne = require.config({
  context: "version1",
  baseUrl: "version1"
});

reqOne(["require", "alpha", "beta",],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 1
  log("beta version is: " + beta.version); //prints 1

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version1 omega loaded with version: " +
             omega.version); //prints 1
      }
    );
  }, 100);
});

var reqTwo = require.config({
      context: "version2",
      baseUrl: "version2"
    });

reqTwo(["require", "alpha", "beta"],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 2
  log("beta version is: " + beta.version); //prints 2

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version2 omega loaded with version: " +
            omega.version); //prints 2
      }
    );
  }, 100);
});
&lt;/script>        </code></pre>
<h2> 关于传统CommonJS模块</h2>
<p>传统CommonJS模块转成requirejs支持的格式：</p>
<pre><code>define(function(require, exports, module) {
    // Put traditional CommonJS module content here
});  </code></pre>
<p>另一种支持的格式，可以通过返回一个值作为module.exports：</p>
<pre><code>define(function (require) {
    var foo = require('foo');

    //Define this module as exporting a function
    return function () {
        foo.doSomething();
    };
}); </code></pre>
<p>还有一种格式，直接在define函数的参数中提供依赖数组，上一种方式可以改成：</p>
<pre><code>define(['foo'], function (foo) {
    return function () {
        foo.doSomething();
    };
});       </code></pre>
<h2> 关于r.js</h2>
<blockquote><p> Runs RequireJS in Node and Rhino, and used to run the RequireJS optimizer</p></blockquote><p><code>两个功能</code>：</p>
<ol><li>在Node或Rhino等环境下运行<code>AMD规范</code>的项目</li>
<li>优化器作用：<code>r.js</code>能对使用requirejs构建的前端项目进行部署优化，可将多个文件合并成单个文件，<p>并进行压缩，从而避免大量对小文件的请求。</p>
</li></ol>
<h3> 1. 作为优化器的使用方法</h3>
<ol><li>下载<code>r.js</code>至项目根目录，一般来说与源码目录和发布目录同级，其github地址为：<pre><code>https://github.com/jrburke/r.js </code></pre>
</li>
<li>可以有两种方法来调用<code>r.js</code>，第一种为纯命令行方式：<pre><code>node r.js -o baseUrl=. paths.jquey=some/other/jquery name=main out=main-build.js     </code></pre>
<p>第二种为使用配置文件的方式，例如build.js，与r.js同级目录：</p>
<pre><code>node r.js -o build.js </code></pre>
<p>使用<code>-o</code>开启优化模式。一般项目推荐使用第二种方式。</p>
</li></ol>
<h3> 2. build.js文件 </h3>

<p>举例如下：</p>

<ol><li>todo mvc的优化案例：<p>可以在这里
<code>
    http://www.webdeveasy.com/code/optimize-requirejs-projects/todo-mvc-optimized.zip
    </code>
下载项目查看。</p>
<pre><code>({
    appDir: './',
    baseUrl: './js',
    dir: './dist',
    modules: [
        {
            name: 'main'
        }
    ],
    fileExclusionRegExp: /^(r|build)\.js$/,
    optimizeCss: 'standard',
    optimize: 'none',
    removeCombined: true,
    paths: {
        jquery: 'lib/jquery',
        underscore: 'lib/underscore',
        backbone: 'lib/backbone/backbone',
        backboneLocalstorage: 'lib/backbone/backbone.localStorage',
        text: 'lib/require/text'
    },
    shim: {
        underscore: {
            exports: '_'
        },
        backbone: {
            deps: [
                'underscore',
                'jquery'
            ],
            exports: 'Backbone'
        },
        backboneLocalstorage: {
            deps: ['backbone'],
            exports: 'Store'
        }
    }
})   </code></pre>
</li>
<li>其他案例： <pre><code>{
    baseUrl: "../js",
    dir: "../dist",
    optimize: "uglify",
    optimizeCss: "standard.keepLines",
    mainConfigFile: "../js/main.js",
    removeCombined: true,
    fileExclusionRegExp: /^\./,
    modules: [
        {
            name: "app/dispatcher",
        },
        {
            name: "app/in-storage",
            exclude: [
                "jquery",
                "app/common",
                "pkg/DatePicker/app"
            ]
        }
    ]
}  </code></pre>
</li>
<li>优化选项说明</li></ol>
<ul><li>appDir<p>应用程序的最顶层目录。可选的，如果设置了的话，r.js 会认为脚本在这个路径的子目录中，应用程序的文件都会被拷贝到输出目录（dir 定义的路径）。如果不设置，则使用下面的 baseUrl 路径。</p>
</li>
<li>baseUrl<p>默认情况下，所有的模块都是相对于这个路径的。如果没有设置，则模块的加载是相对于 build 文件所在的目录。另外，如果设置了appDir，那么 baseUrl 应该定义为相对于 appDir 的路径。</p>
</li>
<li>dir<p>输出目录的路径。如果不设置，则默认为和 build 文件同级的 build 目录。</p>
</li>
<li>optimize<p>JavaScript 代码优化方式。可设置的值：</p>
<ul><li>"uglify：使用 UglifyJS 压缩代码，默认值；</li>
<li>"uglify2"：使用 2.1.2+ 版本进行压缩；</li>
<li>"closure"： 使用 Google's Closure Compiler 进行压缩合并，需要 Java 环境；</li>
<li>"closure.keepLines"：使用 Closure Compiler 进行压缩合并并保留换行；</li>
<li>"none"：不做压缩合并；</li></ul>
</li>
<li>optimizeCss<p>CSS 代码优化方式，可选的值有：</p>
<ul><li>"standard"：标准的压缩方式；</li>
<li>"standard.keepLines"：保留换行；</li>
<li>"standard.keepComments"：保留注释；</li>
<li>"standard.keepComments.keepLines"：保留换行；</li>
<li>"none"：不压缩；</li></ul>
</li>
<li>mainConfigFile<p>如果不想重复定义的话，可以使用这个参数配置 RequireJS 的配置文件路径。</p>
</li>
<li>removeCombined<p>删除之前压缩合并的文件，默认值 false。</p>
</li>
<li>fileExclusionRegExp<p>要排除的文件的正则匹配的表达式。</p>
</li>
<li>modules<p>定义要被优化的模块数组。每一项是模块优化的配置，常用的几个参数如下：</p>
<ul><li>name：模块名；</li>
<li>create：如果不存在，是否创建。默认 false；</li>
<li>include：额外引入的模块，和 name 定义的模块一起压缩合并；</li>
<li>exclude：要排除的模块。有些模块有公共的依赖模块，在合并的时候每个都会压缩进去，<p>例如一些基础库。使用 exclude 就可以把这些模块在压缩在一个更早之前加载的模块中，
其它模块不用重复引入。    </p>
</li></ul>
</li></ul>
<h3> 3. 优化原理</h3>
<p>多个文件合并成一个文件，文件内由多个define方法构成，使用模块ID的方式：</p>

<pre><code>define('ID', [...], function(){});   </code></pre>
<p>比如合并好的文件如下：</p>
<pre><code>...
// 第一部分
define("backboneLocalstorage", ["backbone"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Store;
    };    
}(this)));

// 第二部分
define('models/todo',['require','underscore','backbone'],function(require) {

    var _ = require('underscore');
    var Backbone = require('backbone');
...

// 第三部分
define('collections/todos',[
    'underscore',
    'backbone',
    'backboneLocalstorage',
    'models/todo'
], function( _, Backbone, Store, Todo ) {

    var TodosCollection = Backbone.Collection.extend({
        // Reference to this collection's model.
        model: Todo, 
...  </code></pre>
<p>其中，第二部分的代码在合并前为：</p>
<pre><code>define(function(require) {          

    var _ = require('underscore');  
    var Backbone = require('backbone');  

    ...  </code></pre>
<p>第三部分代码在合并前为：</p>
<pre><code>define([
    'underscore',
    'backbone',
    'backboneLocalstorage',
    'models/todo'
], function( _, Backbone, Store, Todo ) { 

    var TodosCollection = Backbone.Collection.extend({
        // Reference to this collection's model.
        model: Todo,
... </code></pre>
<p>第一部分代码是新生成的，由于backbone.Localstorage.js没有使用AMD方式编写，所以使用shim（垫片）方式。</p>




<h3> 4. 参考资料</h3>
<ol><li><code>前端优化：RequireJS Optimizer 的使用和配置方法</code>：<p>http://www.cnblogs.com/lhb25/p/requirejs-ptimizer-using.html </p>
</li>
<li>翻译版：http://blog.jobbole.com/39205/<p>原版： http://www.webdeveasy.com/optimize-requirejs-projects/</p>
</li></ol>

    <script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.js"></script>
</body>
</html>
<script type="text/javascript" src="/docs/markdown_res/js/footer.js"></script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
<script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
