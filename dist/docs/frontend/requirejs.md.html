<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/markdown-7.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <style type="text/css">
        img {max-width: 100%; border: 1px solid #eee; }
        pre, code {color: #048ebd; }
        li>p {display: block;}
        p>code, li>code {padding:0; font-size: 13px; color: red;}
    </style>
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.js"></script>
</head>
<body>
    <div id="nav">
<a href="javascript:history.back()">返回 [ or Backspace ]</a>
    </div>

<h1> requirejs相关资料</h1>
<p>2014-09-30</p>
<blockquote><p style="color:green;font-size:18px">RequireJS implements the  Asynchronous Module Definition (formerly Transport/C) proposal.</p></blockquote><h2> 使用方式</h2>
<h3> data-main</h3>
<pre><code>&lt;script data-main="scripts/main" src="scripts/require.js">&lt;/script> </code></pre>
<p>以上适用于页面只有一个入口脚本的情况。否则使用<code>内联require</code>的方式。</p>
<h3> 内联require</h3>
<pre><code>&lt;script src="scripts/require.js">&lt;/script>
&lt;script>
require(['scripts/config']), function() {
    // Configuration loaded now, safe to do other require calls
    // that depend on that config.
    require(['foo'], function(foo) {

    });
});
&lt;/script> </code></pre>
<h2> 关于baseUrl</h2>
<ul><li>所有的脚本都按相对于<code>baseUrl</code>的路径进行加载。通常同设置为<code>data-main</code>的脚本所在路径。</li>
<li>也可以通过<code>require.config</code>进行设置：<pre><code>require.config({
    baseUrl: "/another/path",
    paths: {
        "some": "some/v1.0"
    },
    waitSeconds: 15
}); </code></pre>
</li>
<li>例外情况，如果module id存在以下情况，则<code>baseUrl</code>不生效：<ul><li>以<code>.js</code>结束</li>
<li>以<code>/</code>开始</li>
<li>包含URL协议，比如<code>http:</code>或者<code>https:</code></li></ul>
<p>当然，推荐使用baseUrl</p>
</li></ul>
<h2> 定义模块</h2>
<ol><li>模块定义恰当处理了作用域，避免污染全局命名空间。</li>
<li>显式列出依赖模块，并且能获得依赖模块的引用，而不需要通过全局对象的方式。使用了<p><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">
模块模式（Module Pattern）</a></p>
</li>
<li>定义方式使得模块能尽可能快的加载，又能按依赖关系顺序执行。</li>
<li>需要了解的Module格式：<code>CommonJS module</code>，<code>RequireJS module</code></li></ol>
<h3> 有哪些方式？</h3>
<ol><li>简单key/value对象<pre><code>// Inside file my/shirt.js:
define({
    color: "black",
    size: "unisize"
}); </code></pre>
</li>
<li>定义函数<pre><code>// my/shirt.js now does setup work
// before returning its module definition.
define(function () {
    // Do setup work here

    return {
        color: "black",
        size: "unisize"
    }
}); </code></pre>
</li>
<li>带有依赖的定义函数<pre><code>// my/shirt.js now has some dependencies, a cart and inventory
// module in the same directory as shirt.js
define(["./cart", "./inventory"], function(cart, inventory) {
        // return an object to define the "my/shirt" module.
        return {
            color: "blue",
            size: "large",
            addToCart: function() {
                inventory.decrement(this);
                cart.add(this);
            }
        }
    }
); </code></pre>
</li>
<li>定义一个模块为函数<p>模块不一定必须返回一个对象，任何有效返回值都是可以的，比如函数。</p>
<pre><code>// A module definition inside foo/title.js. It uses
// my/cart and my/inventory modules from before,
// but since foo/title.js is in a different directory than
// the "my" modules, it uses the "my" in the module dependency
// name to find them. The "my" part of the name can be mapped
// to any directory, but by default, it is assumed to be a
// sibling to the "foo" directory.
define(["my/cart", "my/inventory"],
    function(cart, inventory) {
        // return a function to define "foo/title".
        // It gets or sets the window title.
        return function(title) {
            return title ? (window.title = title) :
                   inventory.storeName + ' ' + cart.name;
        }
    }
); </code></pre>
</li>
<li>用简单CommonJS封装定义一个模块<p>比如要复用<code>CommonJS</code>方式编写的模块，可以用这种方式封装。这种方式全依赖
<code>Function.prototype.toString()</code>，使得requirejs可以通过解析require语句，分析出
依赖关系。</p>
<pre><code>define(function(require, exports, module) {
        var a = require('a'),
            b = require('b');

        // Return the module value
        return function () {};
    }
); </code></pre>
</li>
<li>定义一个带名字的模块<pre><code>// Explicitly defines the "foo/title" module:
define("foo/title",
    ["my/cart", "my/inventory"],
    function(cart, inventory) {
        // Define foo/title object in here.
   }
); </code></pre>
</li></ol>
<h3> 模块定义注意</h3>
<ol><li>一个文件只定义一个模块</li>
<li>相对模块名的定义，务必将require作为依赖<pre><code>define(["require", "./relative/name"], function(require) {
    var mod = require("./relative/name");
}); </code></pre>
<p>或者更好的方式，可以简写成这样：</p>
<pre><code>define(function(require) {
    var mod = require("./relative/name");
}); </code></pre>
</li>
<li>如何生成相对于模块的路径：<pre><code>define(["require"], function(require) {
    var cssUrl = require.toUrl("./style.css");
}); </code></pre>
</li>
<li>对于已经通过<code>require(['module/name'], function(){})</code>加载了的模块，可以通过以下方式调用其内部函数：<pre><code>require("module/name").callSomeFunction() </code></pre>
</li></ol>
<h2> 多版本支持</h2>
<p>通过<code>require.config</code>实现：</p>
<pre><code>&lt;script src="../require.js">&lt;/script>
&lt;script>
var reqOne = require.config({
  context: "version1",
  baseUrl: "version1"
});

reqOne(["require", "alpha", "beta",],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 1
  log("beta version is: " + beta.version); //prints 1

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version1 omega loaded with version: " +
             omega.version); //prints 1
      }
    );
  }, 100);
});

var reqTwo = require.config({
      context: "version2",
      baseUrl: "version2"
    });

reqTwo(["require", "alpha", "beta"],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 2
  log("beta version is: " + beta.version); //prints 2

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version2 omega loaded with version: " +
            omega.version); //prints 2
      }
    );
  }, 100);
});
&lt;/script>  </code></pre>
<h2> 关于传统CommonJS模块</h2>
<p>传统CommonJS模块转成requirejs支持的格式：</p>
<pre><code>define(function(require, exports, module) {
    // Put traditional CommonJS module content here
});  </code></pre>
<p>另一种支持的格式，可以通过返回一个值作为module.exports：</p>
<pre><code>define(function (require) {
    var foo = require('foo');

    //Define this module as exporting a function
    return function () {
        foo.doSomething();
    };
}); </code></pre>
<p>还有一种格式，直接在define函数的参数中提供依赖数组，上一种方式可以改成：</p>
<pre><code>define(['foo'], function (foo) {
    return function () {
        foo.doSomething();
    };
}); </code></pre>
<h2> todo</h2>

    <script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.js"></script>
</body>
</html>
<script type="text/javascript">
(function(){

document.title = $('h1').html() || '技术文档－258i.com';    

$(document).on('keydown', function(e){
    var BACKSPACE = 8;

    if(BACKSPACE == e.keyCode
        || BACKSPACE == e.which){
        history.back();
    }
});

})();
</script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
