<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap-theme.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/markdown-7.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/page.css" />
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.js"></script>
</head>
<body>
    <div id="nav" class="row">
<a class="text-info pull-right" href="javascript:history.back()">Back</a>
    </div>

<h1> box2dweb</h1>
<blockquote><p> 大名鼎鼎的物理引擎box2d基本上大家都听说过，网上有两个javascript版本的box2d库， 一个是<code>box2djs</code>，已经停止维护，一个是<code>box2dweb</code>。 </p></blockquote><p>在Google Code上维护：
<code>Source URL:</code> <a href="https://code.google.com/p/box2dweb/">box2dweb</a></p>
<p><code>Slide URL:</code> <a href="http://www.slideshare.net/szafranek/slides-en">Box2D</a></p>
<p><code>box2dflash实现的游戏：</code><a href="http://www.gibbetsgame.com">Gibbets</a></p>
<h2> box2d</h2>
<blockquote><p> 多平台支持的2d物理引擎</p></blockquote><ol><li>multiplatform：c++, c#, ActionScript, Java</li>
<li>2D: x, y</li>
<li>physics engine: gravity, friction, collision detection, motion simulation</li></ol>
<blockquote><p> Box2D library is agnostic about rendering.</p></blockquote><p>Box2D库独立于渲染，只做计算。</p>

<h2> 关键字</h2>
<ul><li>rigid body - 刚体</li>
<li>shape - 形状</li>
<li>fixture</li>
<li>constraint - 约束</li>
<li>contact constraint - 接触约束</li>
<li>joint - 关节</li>
<li>joint limit - 关节限制</li>
<li>joint motor - 关节马达</li>
<li>world - 世界</li>
<li>friction - 摩擦</li>
<li>restitution - 恢复</li>
<li>body - 物体</li>
<li>collision geometry - 碰撞几何结构</li>
<li>damping - 阻尼</li>
<li>body definition - 物体定义</li>
<li>solver</li>
<li>kinematic - 运动学的</li>
<li>torque - 扭力，扭矩</li>
<li>inertia - 惯性</li>
<li>discrete simulation - 分立式模拟 </li>
<li>tunneling - 穿透</li>
<li>CCD - continuous collision detection </li>
<li>oscillations - 震动</li>
<li>Nyquist frequency - 奈奎斯特频率</li>
<li>hinge point - 铰链点</li>
<li>eternal - 永恒的，没完没了的</li>
<li>axis - 轴，轴线</li>
<li>pulley - 滑轮</li>
<li>contraption - 新发明，奇妙的装置</li>
<li>AABBs (axis-aligned bounding boxes)</li>
<li>tolerance - 限度，公差，容忍</li></ul>
<h2> 概览</h2>

<h3> 1. 模块</h3>
<p>三个模块:</p>
<ul><li>Common<ul><li>code for allocation, math and settings</li></ul>
</li>
<li>Collision<ul><li>define shapes, a broad-phase, andcollision functions/queries</li></ul>
</li>
<li>Dynamics<ul><li>provides the simulation world, bodies, fixtures, and joints</li></ul>
</li></ul>
<p><code>Module Hierarchy：</code></p>

<img src="./img/module-hierarchy.png">


<h3> 2. Units</h3>
<ol><li>长度使用<code>MKS (meters-kilogram-second) units</code><p>Box2D适宜与<code>0.1m - 10m</code>大小的形状，也就是说对象如小至肥皂盒大到公共汽车都可以。
静态形状则可以达到<code>50m</code>也没问题。</p>
<p>作为物理引擎，我们可能趋向于用像素作为单位，不幸的是，这样会导致很差的模拟效果，一个200像素的对象，
对于Box2D来说就像一个45层的摩天大楼。</p>
<p>所以，<code>不要使用像素单位</code>，m可以通过scale系数转换成像素单位，通过像素单位放置装置于物体上。</p>
</li>
<li>角度使用<code>弧度</code>，而不是度数。</li></ol>
<h3> 3. 工厂和定义</h3>
<p>为C++实现方案提供更快速的内存管理。</p>
<p>比如创建b2Body或者b2Joint，你需要调用b2World的工厂方法。</p>
<p><code>创建函数：</code></p>
<pre><code>b2Body* b2World::CreateBody(const b2BodyDef *def)
b2Joint* b2World::CreateJoint(const b2JointDef *def) </code></pre>
<p><code>销毁函数：</code></p>
<pre><code>void b2World::DestroyBody(b2Body* body)
void b2World::DestroyJoint(b2Joint* joint) </code></pre>
<p>而装备(shapes)必须以body为父节点，所以b2Body则提供了创建和销毁的工厂方法：</p>
<pre><code>b2Fixture* b2Body::CreateFixture(const b2FixtureDef *def)
void b2Body::DestroyFixture(b2Fixture *fixture) </code></pre>
<p>还有一个快捷方式创建装备的：</p>
<pre><code>b2Fixture *b2Body::CreateFixture(const b2Shape *shape, float32 density)    </code></pre>
<h3> 4. Hello Box2D</h3>
<p><code>1. 创建world对象</code></p>
<p>总是从创建b2World对象开始。world对象是管理内存、对象和模拟的物理桩。</p>
<p>创建前，<code>先定义重力向量</code>：</p>
<pre><code>b2Vec2 gravity(0.0f, -10.0f); </code></pre>
<p>然后创建world对象：</p>
<pre><code>b2World world(gravity); </code></pre>
<p>这时，我们拥有了一个物理世界，可以开始添加东西进去了。</p>

<p><code>2. 创建地面物体</code></p>
<p>创建物体的四步骤：</p>
<ol><li>定义物体，使用位置position，阻尼damping等</li>
<li>使用world对象创建物体</li>
<li>定义装备，使用形状、摩擦、密度等</li>
<li>在物体上创建装备</li></ol>
<p>创建过程如下：</p>
<pre><code>b2BodyDef groundBodyDef;
groundBodyDef.position.Set(0.0f, -10.0f);

b2Body *groundBody = world.CreateBody(groundBodyDef);

b2PolygonShape groundBox;
groundBox.SetAsBox(50.0f, 10.0f);

groundBody->CreateFixture(&amp;groundBox, 0.0f); </code></pre>
<p>当使用装备将形状添加到物体上以后，形状的坐标就属于物体的内部坐标，物体怎么动，形状就
跟着怎么动，形状在物体上不能移动，这也是Box2D所定义的<code>刚体引擎</code>所要求的。</p>

<p><code>3. 创建动态物体</code></p>
<p>有了地面物体以后，我们可以用同样的方法创建动态物体。创建的主要不同之处在于：</p>
<p>除了<code>尺寸dimension</code>之外，我们还必须提供物体的<code>质量mass</code>属性。</p>
<pre><code>b2BodyDef bodyDef;
bodyDef.type = b2_dynamicBody;
bodyDef.position.Set(0.0f, 4.0f);
b2Body *body = world.CreateBody(&amp;bodyDef); </code></pre>
<blockquote><p> 如果希望物体随着力而移动，我们必须将物体的类型设置成<code>b2_dynamicBody</code></p></blockquote><p>接下来我们创建并添加一个多边形到物体上：</p>
<pre><code>b2PolygonShape dynamicBox;
dynamitBox.SetAsBox(1.0f, 1.0f); </code></pre>
<p>默认密度是0，我们设置为1：</p>
<pre><code>b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;dynamicBox;
fixtureDef.density = 1.0f;
fixtureDef.friction = 0.3f; </code></pre>
<blockquote><p> 动态物体必须拥有<code>至少一个密度不为0</code>的装备，否则该物体的行为将会很诡异。</p></blockquote><pre><code>body->CreateFixture(&amp;fixtrueDef);  </code></pre>
<p><code>4. 模拟世界</code></p>
<p>创建好世界，地面物体和动态物体后，我们就可以开始模拟世界了，让牛顿定律产生作用。</p>
<p>真正开始模拟前，我们还需要考虑几个问题：</p>
<ol><li>时间步长( time step )或者帧率: <code>至少60Hz， 或者1/60s</code><pre><code>float32 timeStep = 1.0f / 60.0f; </code></pre>
<p>每帧的计算由integrator来进行。</p>
</li>
<li>除了综合器，还有一个<code>限制求解器（Constraint Solver）</code>，包含两个阶段：速度阶段和位置阶段。<p><code>速度阶段保证物体移动正确，位置阶段避免物体重叠和关节脱落</code>。</p>
<p>每个阶段都有自己的循环次数，速度阶段8次，位置阶段3次。也可以自行调整。</p>
<pre><code>int32 velocityIterations = 6;
int32 positionIterations = 2; </code></pre>
<p>时间步长与循环次数完全没有关系。</p>
</li></ol>
<p>考虑完时间步长与两个求解器循环次数外，就可以开始模拟循环了。</p>
<p>模拟循环可以和游戏循环结合起来，只需在游戏循环里面调用<code>b2World::Step</code></p>
<p>简单的循环如下实现：</p>

<pre><code>for( int32 i=0; i&lt;60; i++){
    world.Step(timeStep, velocityIterations, positionIterations);
    b2Vec position = body->GetPosition();
    float32 angle = body->GetAngle();
    printf("%4.2f %4.2f %4.2f\n", position.x, position.y, angle);
}    </code></pre>
<h2> 一、Collision Module</h2>

<h3> b2Shape</h3>
<ul><li>测试点与shape是否重叠</li>
<li>处理灯光投射</li>
<li>计算AABB</li>
<li>计算质量属性</li></ul>
<p>Note: Keep in mind that a shape does not know about bodies and stand apart from the dynamics system.</p>
<ul><li>When a shape is not attached to a body, you can view it’s vertices as being expressed in world- space.</li>
<li>When a shape is attached to a body, you can view it’s vertices as being expressed in local coordinates.</li></ul>
<ol><li>Circle Shapes</li>
<li>Polygon Shapes<p>Convex and Concave</p>
<p><img src="./img/polygon.png"></p>
<p>多边形是Convex，而不是Concave。Convex的任意两个顶点的连线不会与任何一条边相交。</p>
<p>多边形的顶点必须以CCW(Counter Clockwise Winding)顺序给出，这与右手坐标系统相适应。</p>
<p><img src="./img/ccw.png"></p>
<p>Convex hull computation</p>
<p>默认最大顶点数为8，满足大部分需求，也保证了计算性能</p>
<p>从shape中继承了radius属性，形成polygon skin：</p>
<p><img src="./img/polygon-skin.png"></p>
</li>
<li>Edge Shapes<p>即线段。辅助创建静态环境，无体积，可以与circle或polygon碰撞，但不会与自身碰撞。</p>
<p>碰撞算法要求碰撞的两者至少有一个是有体积的，所以Edge－Edge都无体积，所以无法碰撞</p>
<pre><code>// This an edge shape. 
b2Vec2 v1(0.0f, 0.0f); 
b2Vec2 v2(1.0f, 0.0f);
b2EdgeShape edge;
edge.Set(v1, v2); </code></pre>
<p>注意<code>ghost collision</code>，可以使用chain shapes</p>
</li>
<li>Chain Shapes<p>多个Edge连接成。</p>
<p><img src="./img/chain-shape.png"></p>
<p>self-intersection不支持，顶点很接近也可能会出问题，Edge长于b2_linearSlop(5mm)</p>
<p><img src="./img/self-intersection.png"></p>
</li></ol>
<p><code>一元几何查询</code></p>
<ol><li>点测试，Shape Point Test<pre><code>b2Transfrom transform; 
transform.SetIdentity(); 
b2Vec2 point(5.0f, 2.0f);
bool hit = shape->TestPoint(transform, point); </code></pre>
<p>Edge和Chain总是返回false，即使chain是闭合的。</p>
</li>
<li>光测试<pre><code>b2Transfrom transform; 
transform.SetIdentity(); 
b2RayCastInput input; 
input.p1.Set(0.0f, 0.0f, 0.0f); 
input.p2.Set(1.0f, 0.0f, 0.0f); 
input.maxFraction = 1.0f; 
int32 childIndex = 0; 
b2RayCastOutput output;
bool hit = shape->RayCast(&amp;output, input, transform, childIndex); 
if (hit)
{
    b2Vec2 hitPoint = input.p1 + output.fraction * (input.p2 – input.p1);
    ... 
}    </code></pre>
</li></ol>
<p><code>二元函数</code></p>
<ol><li>Overlap<pre><code>b2Transform xfA = ..., xfB = ...;
bool overlap = b2TestOverlap(shapeA, indexA, shapeB, indexB, xfA, xfB); </code></pre>
</li>
<li>Contact Manifolds<p><img src="./img/contact-manifolds.png"></p>
</li>
<li>Distance<p><img src="./img/distance.png"></p>
</li>
<li>Time of Impact<p><code>b2TimeOfImpact</code>用于计算两个移动物体发生碰撞的时间，称为<code>TOI(time of impact)</code>，该函数的主要
目的就是穿透避免（tunnel prevention）</p>
<p><img src="./img/tunnel-prevention.png"></p>
</li></ol>
<p><code>动态树 Dynamic Tree</code></p>
<p>类b2DynamicTree用于有效组织大量shapes，其不关心也不知道shapes，</p>
<p>而是操作AABBs (axis-aligned bounding boxes)</p>


<p><code>广义碰撞检测－Broad-phase</code></p>
<p>碰撞处理有狭义和广义之分，狭义方式两两进行交点计算，N个Shape，需要执行N * N / 2次。</p>
<p><code>b2BroadPhase</code>类使用动态树，大大减少狭义方式的计算量</p>



<h2> 二、Dynamics Module</h2>
<p>最复杂的部分，包含以下类：</p>
<ul><li>fixture class</li>
<li>rigid body class</li>
<li>contact class</li>
<li>joint classes</li>
<li>world class</li>
<li>listener classes</li></ul>
<h3> 2.1 Bodies</h3>
<blockquote><p> Bodies have position and velocity. You can apply forces, torques, and impulses to bodies.  Bodies can be static, kinematic, or dynamic.</p></blockquote><p>位置和加速度，可应用力、扭力和脉冲于其上。</p>

<p><code>类型</code>：
b2_staticBody
b2_kinematicBody
b2_dynamicBody</p>
<blockquote><p> Box2D使用CCD碰撞检测，避免物体穿透。计算碰撞的第一次TOI，物体会被先移动到该TOI， 再行计算剩余sub step。一个step可能会分为多个sub step</p></blockquote><p>不过CCD耗损性能，dynamic物体的默认是不启用的。没有CCD，高速射击的子弹可能会穿透砖墙。</p>
<pre><code>bodyDef.bullet = true; </code></pre>
<p>以上开启dynamic body的CCD属性。只对dynamic body有效。</p>


<p><code>Position and Angle</code></p>

<p><code>Activation</code></p>
<pre><code>bodyDef.active = true; </code></pre>
<p>希望物体创建以后，但不参与碰撞。可以先创建一个inactive的物体，然后再激活之，用以上方法。</p>



<p><code>User Data</code></p>
<p>用户hook，可以自己设定数据。C++里面，它是一个void型指针。</p>
<pre><code>b2BodyDef bodyDef;
bodyDef.userData = &amp;myActor;  </code></pre>
<p><code>Body Factory - 工厂</code></p>
<p>物体的创建和销毁都有b2World来完成，如下：</p>
<pre><code>b2Body * dynamicBody = myWorld -> CreateBody(&amp;bodyDef);
... do stuff ...
myWorld -> Destroy(dynamicBody);
dynamicBody = NULL; </code></pre>
<p>避免使用new或者malloc创建body，那样不work</p>
<p>body销毁时，依附其上的fixtures和joints自动销毁。</p>


<p><code>使用物体</code></p>
<blockquote><p> After creating a body, there are many operations you can perform on the body. These include setting  mass properties, accessing position and velocity, applying forces, and transforming points and vectors.</p></blockquote><ol><li>mass properties:<p>mass ( scalar ), center of mass ( 2-vector ), rotational inertia ( scalar )</p>
<p>质量，中心，旋转惯性</p>
<p>静态物体，质量和转动惯性设置为0.</p>
<pre><code>void SetMassData(const b2MassData * data);

void ResetMassData();

float32 GetMass() const;
float32 GetInertia() const;
const b2Vec2&amp; GetLocalCenter() const; 
void GetMassData(b2MassData* data) const; </code></pre>
</li>
<li>状态信息<pre><code>void SetType(b2BodyType type);
b2BodyType GetType();

void SetBullet(bool flag); 
bool IsBullet() const;

void SetSleepingAllowed(bool flag); 
bool IsSleepingAllowed() const;

void SetAwake(bool flag); 
bool IsAwake() const;

void SetActive(bool flag); 
bool IsActive() const;

void SetFixedRotation(bool flag); 
bool IsFixedRotation() const; </code></pre>
</li>
<li>位置与速度<pre><code>bool SetTransform(const b2Vec2&amp; position, float32 angle);
const b2Transform&amp; GetTransform() const; 
const b2Vec2&amp; GetPosition() const; 
float32 GetAngle() const;

const b2Vec2&amp; GetWorldCenter() const; 
const b2Vec2&amp; GetLocalCenter() const;  </code></pre>
</li></ol>
<h3> 2.2 Fixtures</h3>
<blockquote><p> Box2D provides the b2Fixture class to attach shapes to bodies</p></blockquote><p>一个物体拥有零个或多个装置，拥有多个装置的物体叫做组合物体。</p>
<p>fixture包含以下内容：</p>
<ul><li>a single shape</li>
<li>broad-phase proxies</li>
<li>density, friction, and restitution</li>
<li>collision filtering flags</li>
<li>back pointer to the parent body</li>
<li>user data</li>
<li>sensor flag</li></ul>
<p><code>fixture创建：</code></p>
<pre><code>b2FixtureDef fixtureDef; 
fixtureDef.shape = &amp;myShape;
fixtureDef.density = 1.0f;
b2Fixture* myFixture = myBody->CreateFixture(&amp;fixtureDef); </code></pre>
<blockquote><p> the fixture will automatically be destroyed when the parent body is destroyed. You can destroy a fixture on the parent body. You may do this to model a breakable object. </p></blockquote><pre><code>myBody->DestroyFixture(myFixture);  </code></pre>
<p><code>Density－密度：</code></p>
<blockquote><p> The fixture density is used to <code>compute the mass properties</code> of the parent body.  The density can be zero or positive. You should generally use similar densities for  all your fixtures. This will improve stacking stability.</p></blockquote><pre><code>fixture->SetDensity(5.0f);
body->ResetMassData(); </code></pre>
<p>物体质量不会改变，必须调用ResetMassData()。 </p>



<p><code>Friction - 摩擦力：</code></p>
<p>模拟现实中的相对滑动，支持静摩擦和滑动摩擦。</p>
<blockquote><p> Friction is simulated accurately in Box2D and the friction strength is proportional  to the normal force (this is called Coulomb friction). </p></blockquote><p>Coulomb friction - 库仑摩擦</p>
<p>一般为<code>[0, 1]</code></p>
<p>计算两个shape之间的摩擦力时，Box2D会综合考虑两者的父fixture的摩擦系数，按以下方式计算：</p>
<pre><code>float32 friction;
friction = sqrtf( fixtureA->friction * fixtureB->friction ); </code></pre>
<p>如果一个表面的摩擦系数为0，则它们之间没有摩擦力。</p>
<p>可以覆盖该默认计算方式，通常在<code>b2ContactListener回调</code>中，使用<code>b2Contact::SetFriction</code>来改变。</p>



<p><code>Restitution</code></p>
<p>用于对象反弹。通常取值[0, 1]，取值0，为非弹性碰撞（inelastic collision），取值大于0，为弹性碰撞。</p>
<p>restitution使用以下公式计算：</p>
<pre><code>float32 restitution;
restitution = b2Max( fixtureA->restitution, fixtureB->restitution ); </code></pre>
<p>覆盖方式类似friction，使用<code>b2Contact::SetRestitution</code></p>
<p>当速度很小的情况，会进行非弹性碰撞，这个取决于<code>b2_velocityThreshold</code></p>



<p><code>Filtering</code></p>
<blockquote><p> Collision filtering allows you to prevent collision between fixtures.</p></blockquote><p>支持<code>16种碰撞类型</code>。</p>
<p>可以设置fixture属于哪种类型的碰撞，也可以设置fixture可以与哪些类型的对象产生碰撞。</p>
<p>比如多人游戏里，玩者之间，怪兽之间不会碰撞，玩者和怪兽之间会产生碰撞。</p>
<pre><code>playerFixtureDef.filter.categoryBits = 0x0002;
monsterFixtureDef.filter.categoryBits = 0x0004; 
playerFixtureDef.filter.maskBits = 0x0004; 
monsterFixtureDef.filter.maskBits = 0x0002;

uint16 catA = fixtureA.filter.categoryBits; 
uint16 maskA = fixtureA.filter.maskBits; 
uint16 catB = fixtureB.filter.categoryBits; 
uint16 maskB = fixtureB.filter.maskBits;

if ((catA &amp; maskB) != 0 &amp;&amp; (catB &amp; maskA) != 0) {
  // fixtures can collide
} </code></pre>
<p>碰撞组，正数组索引的fixture总是碰撞，负数组索引的总是不碰撞。
碰撞组索引用于一些相关的物体，比如自行车部件。</p>
<pre><code>fixture1Def.filter.groupIndex = 2; 
fixture2Def.filter.groupIndex = 2; 
fixture3Def.filter.groupIndex = -8; 
fixture4Def.filter.groupIndex = -8 </code></pre>
<p>以上例子，fixture1和fixture2碰撞，fixture3和fixture4不碰撞。</p>
<p>组索引不一致的对象间按照碰撞类型和mask bits进行碰撞。换句话说，组索引的优先级
高于碰撞类型和mask bits。</p>
<p>其他一些需要引起注意的碰撞过滤，列出如下：</p>
<ul><li>静态物体的fixture只能与动态物体碰撞</li>
<li>kinematic物体的fixture只能与动态物体碰撞</li>
<li>同一物体上的fixture不碰撞</li>
<li>可以选择开启／关闭关节点相连的物体之间的fixture的碰撞<p>b2Fixture::GetFilterData()
b2Fixture::SetFilterData()</p>
</li></ul>
<p><code>Sensors - 感应器</code></p>
<blockquote><p> A sensor is a fixture that detects collision but does not produce a response.</p></blockquote><p>比如有时我们需要知道两个不产生碰撞的fixture什么时候重叠。</p>
<p>可讲任何fixture标示为sensor，sensor可以是static, kinematic, or dynamic的。</p>
<p>和Contact(接触)有关，感应器仅当至少有一个动态物体才会生成contact，所以当kinematic-kinematic,
kinematic-static, static-static情况下，我们获取不到contact。</p>
<p>获取感应器状态的方法：</p>
<pre><code>b2Contact::IsTouching()
b2ContactListener::BeginContact()
b2ContactListener::EndContact()   </code></pre>
<h3> 2.3 Joints</h3>
<p><code>Joint Factory</code></p>
<p>使用world提供的方法创建和销毁，不要自己new或者malloc</p>
<pre><code>b2RevoluteJointDef jointDef; 
jointDef.bodyA = myBodyA; 
jointDef.bodyB = myBodyB;
jointDef.anchorPoint = myBodyA->GetCenterPosition();

b2RevoluteJoint* joint = (b2RevoluteJoint*)myWorld->CreateJoint(&amp;jointDef); 

... do stuff ...

myWorld->DestroyJoint(joint);
joint = NULL; </code></pre>
<blockquote><p> Caution: Joints are destroyed when an attached body is destroyed.</p></blockquote>
<p><code>使用Joint</code></p>
<p>模拟过程中可能joint创建以后，到被销毁，都不再被使用，但是其包含很多有用数据，帮助
完成更丰富的模拟过程。</p>
<p>首先，可以获取bodies， anchor points，以及user data</p>
<pre><code>b2Body* GetBodyA();
b2Body* GetBodyB();
b2Vec2 GetAnchorA();
b2Vec2 GetAnchorB();
void* GetUserData();  </code></pre>
<blockquote><p> You can use reaction forces to break joints or trigger other game events. </p></blockquote><pre><code>b2Vec2 GetReactionForce(); 
float32 GetReactionTorque(); </code></pre>
<p><code>Distance Joint</code></p>
<p>距离关节</p>
<blockquote><p> One of the simplest joint is a distance joint which says that the distance between  two points on two bodies must be constant. </p></blockquote><p>分别存在于两个物体上的两个点之间的距离是定值。</p>

<img src="./img/distance-joint.png">
<pre><code>b2DistanceJointDef jointDef;
jointDef.Initialize(myBodyA, myBodyB, worldAnchorOnBodyA, worldAnchorOnBodyB); 
jointDef.collideConnected = true; </code></pre>
<p>通过改变频率（frequency）和阻尼率（damping ratio），可以讲距离关节变成
软关节，就像<code>spring-damper(弹簧阻尼)</code></p>
<pre><code>jointDef.frequencyHz = 4.0f; 
jointDef.dampingRatio = 0.5f; </code></pre>
<p>注意：</p>
<ol><li>frequency < step frequency / 2，比如step frequency为60Hz，那么需要小于30Hz。<p>原因是Nyquist frequency，奈奎斯特频率</p>
</li>
<li>阻尼率一般取值[0,1]，当然可以大于1。当1的时候，是一个关键值，所有的震动都消失了(all oscillations<p>should vanish)。</p>
</li></ol>
<p><code>Revolute joint</code></p>
<p>旋转关节让两个物体共享一个锚点（anchor point），通常叫做hinge point</p>

<img src="./img/revolute-joint.png">
<p>两个物体只有单一的角度自由。</p>
<p>需要提供两个物体和一个锚点，初始化函数默认物体已经在正确的位置。</p>
<pre><code>b2RevoluteJointDef jointDef;
jointDef.Initialize(myBodyA, myBodyB, myBodyA->GetWorldCenter()); </code></pre>
<p>以上代码将两个物体用其中一个物体的重心作为铰链点连接起来。</p>
<p>如果bodyB按CCW旋转，那么关节角度（joint angle）就是正的，关节角度如果Box2D规定，都是按
弧度为单位，关节角度使用<code>Initialize()</code>创建时，默认为1，不管两个物体当前的旋转位置。</p>
<p>通过设置关节角度限制，来控制关节角度，限制范围应该包含0值，否则关节会lurch（摇晃）。</p>
<p>关节马达允许我们设置关节速度（角度的时间衍生品），可以正数也可以负数。马达可以有
无穷大力，但通常不取无穷大力，原因是：</p>
<blockquote><p> "What happens when an irresistible force meets an immovable object?"</p></blockquote><p>所以，可以提供一个最大扭力值。关节马达可以保持某个速度，除非需要的扭力超过马达的最大扭力。
如果超过了，那么关节会慢下来，甚至反转。</p>
<p>可以使用关节马达来模拟<code>关节摩擦力</code>，只需将关节速度设置为0，将最大扭力设置为一个有意义的较小的值。
看以下例子：</p>
<pre><code>b2RevoluteJointDef jointDef;

jointDef.Initialize(bodyA, bodyB, myBodyA->GetWorldCenter()); 
jointDef.lowerAngle = -0.5f * b2_pi; 
// -90 degrees jointDef.upperAngle = 0.25f * b2_pi; 
// 45 degrees jointDef.enableLimit = true;

jointDef.maxMotorTorque = 10.0f;
jointDef.motorSpeed = 0.0f;
jointDef.enableMotor = true; </code></pre>
<p>获取关节的角度、速度和马达扭力等参数：</p>
<pre><code>float32 GetJointAngle() const; 
float32 GetJointSpeed() const; 
float32 GetMotorTorque() const; </code></pre>
<p>更新关节马达参数：</p>
<pre><code>void SetMotorSpeed(float32 speed); 
void SetMaxMotorTorque(float32 torque); </code></pre>
<p>有趣的能力，让关节速度按正弦波变化，来回移动，或者任何你需要的函数改变其关节速度：</p>
<pre><code>... Game Loop Begin ... 
myJoint->SetMotorSpeed(cosf(0.5f * time));
... Game Loop End ... </code></pre>
<blockquote><p> You can also use joint motors to track a desired joint angle</p></blockquote><pre><code>... Game Loop Begin ...
float32 angleError = myJoint->GetJointAngle() - angleTarget; 
float32 gain = 0.1f;
myJoint->SetMotorSpeed(-gain * angleError);
... Game Loop End ...      </code></pre>
<p><code>Prismatic joint</code></p>
<p>移动关节允许两个物体沿着指定轴线(axis)相对移动，它不允许相对转动。</p>

<img src="./img/prismatic-joint.png">
<p>移动关节的定义与转动关节类似，只需用移动(translation)替换角度(angle)，
用力(force)替换扭力(torque)。</p>
<pre><code>b2PrismaticJointDef jointDef;
b2Vec2 worldAxis(1.0f, 0.0f);
jointDef.Initialize(myBodyA, myBodyB, myBodyA->GetWorldCenter(), worldAxis); 
jointDef.lowerTranslation = -5.0f;
jointDef.upperTranslation = 2.5f;
jointDef.enableLimit = true;
jointDef.maxMotorForce = 1.0f;
jointDef.motorSpeed = 0.0f;
jointDef.enableMotor = true; </code></pre>
<p>旋转关节的轴线从屏幕穿出，是隐式的；而移动关节的轴线需要显式给出，平行于屏幕，固定于两个
物体，沿着它们的移动方向。</p>
<p>与旋转关节类似，创建时，其translation为0，需要确保translation的范围包含0值。</p>
<p>以下是使用移动关节的一些方法：</p>
<pre><code>float32 GetJointTranslation() const;
float32 GetJointSpeed() const; 
float32 GetMotorForce() const; 
void SetMotorSpeed(float32 speed); 
void SetMotorForce(float32 force);   </code></pre>
<p><code>Pulley Joint</code></p>
<blockquote><p> 滑轮关节用于创建一个理想化滑轮。</p></blockquote>
<img src="./img/pulley-joint.png">
<p>滑轮关节将两个物体连接到ground，同时相互连接，一个上去，另一个下来。滑轮线长度保持初始设置，如：</p>
<pre><code>length1 + length2 == constant </code></pre>
<p>可以提供比率来模拟滑轮索具，这会使的一边的绳子比另一边伸展得快，同时一边的受力比另一边的受力小。
用这种方式，可以创建机械杠杆（mechanical leverage）。</p>
<pre><code>length1 + ratio * length2 == constant </code></pre>
<p>当一边的绳索<code>长度为0时</code>，绳长公式就出问题了，需要配置碰撞形状避免这种情况。</p>
<pre><code>b2Vec2 anchor1 = myBody1->GetWorldCenter(); 
b2Vec2 anchor2 = myBody2->GetWorldCenter(); 
b2Vec2 groundAnchor1(p1.x, p1.y + 10.0f); 
b2Vec2 groundAnchor2(p2.x, p2.y + 12.0f); 
float32 ratio = 1.0f;

b2PulleyJointDef jointDef;
jointDef.Initialize(myBody1, myBody2, groundAnchor1, groundAnchor2, anchor1,
anchor2, ratio); </code></pre>
<p>以下方法可获取状态：</p>
<pre><code>float32 GetLengthA() const; 
float32 GetLengthB() const;    </code></pre>
<p><code>Gear Joint</code></p>
<p>齿轮关节<code>只能</code>连接旋转和（或）移动关节。</p>

<img src="./img/gear-joint.png">
<p>同样有比率，但该比率可以为负数。</p>
<p>需要记住的是，</p>
<blockquote><p> Also keep in mind that when one joint is a revolute joint (angular) and the other joint   is prismatic (translation), and then the gear ratio will have units of length or one over length.</p></blockquote><pre><code>coordinate1 + ratio * coordinate2 == constant </code></pre>
<p>以下代码定义一个齿轮关节：</p>
<pre><code>b2GearJointDef jointDef;
jointDef.bodyA = myBodyA;
jointDef.bodyB = myBodyB; 
jointDef.joint1 = myRevoluteJoint; 
jointDef.joint2 = myPrismaticJoint; 
jointDef.ratio = 2.0f * b2_pi / myLength; </code></pre>
<p>另，必须在转动或移动关节销毁前将齿轮关节销毁，否则程序可能crash。</p>

<p><code>Mouse Joint</code></p>
<p>鼠标关节用于测试床上用鼠标操作物体。</p>
<p>有以下定义属性：</p>
<ul><li>a target point</li>
<li>maximum force: 用于避免多个动态物体互动时出现violent reactions</li>
<li>frequency</li>
<li>damping ratio</li></ul>
<p>后两者用于创建弹簧阻尼效果</p>
<p>在游戏中用鼠标控制物体的精确定位，比较困难，这时还是使用kinematic bodies比较好。</p>


<p><code>Wheel Joint</code></p>
<p>轮子关节将bodyB的一个点限制在bodyA的一条线上，常用于汽车轮子模拟。</p>

<img src="./img/wheel-joint.png">

<p><code>Weld Joint</code></p>
<p>...</p>

<p><code>Rope Joint</code></p>
<p>...</p>

<p><code>Friction Joint</code></p>
<p>...</p>

<p><code>Motor Joint</code></p>
<p>...</p>





<h3> 2.4 Contacts</h3>

<p>todo</p>


<h2> 三、Wrold Class</h2>
<p>大部分与Box2D的交互都是通过b2World类</p>
<pre><code>b2World* myWorld = new b2World(gravity, doSleep);
... do stuff ...
delete myWorld;  </code></pre>
<p><code>模拟</code></p>
<pre><code>float32 timeStep = 1.0f / 60.f;
int32 velocityIterations = 10;
int32 positionIterations = 8;
myWorld->Step(timeStep, velocityIterations, positionIterations); </code></pre>
<blockquote><p> The iteration count controls how many times the constraint solver sweeps over all the  contacts and joints in the world. More iteration always yields a better simulation.  But don't trade a small time step for a large iteration count. 60Hz and 10 iterations  is far better than 30Hz and 20 iterations.</p></blockquote>
<p><code>b2World::ClearForces()</code></p>
<pre><code>myWorld->ClearForces(); </code></pre>
<blockquote><p> This lets you take multiple sub-steps with the same force field</p></blockquote>
<p><code>Exploring the world</code></p>
<p>如何安全删除body：</p>
<pre><code>b2Body* node = myWorld->GetBodyList(); 
while (node)
{
    b2Body* b = node;
    node = node->GetNext();
    GameActor* myActor = (GameActor*)b->GetUserData(); 
    if (myActor->IsDead())
    {
        myWorld->DestroyBody(b);
    } 
} </code></pre>
<p>解决同时删除多个body的问题：</p>
<pre><code>b2Body* node = myWorld->GetBodyList(); 
while (node)
{
    b2Body* b = node;
    node = node->GetNext();
    GameActor* myActor = (GameActor*)b->GetUserData(); 
    if (myActor->IsDead())
    {
        bool otherBodiesDestroyed = GameCrazyBodyDestroyer(b); 
        if (otherBodiesDestroyed)
        {
            node = myWorld->GetBodyList(); 
        }
    } 
}   </code></pre>
<p><code>AABB Queries</code></p>
<p>以下代码找出会与指定AABB相交的所有fixtures，并唤醒与这些fixture关联的body：</p>
<pre><code>class MyQueryCallback : public b2QueryCallback
{ 
public:
    bool ReportFixture(b2Fixture* fixture)
    {
        b2Body* body = fixture->GetBody(); 
        body->SetAwake(true);

        // Return true to continue the query.
        return true;
    }
}; 

...

MyQueryCallback callback;
b2AABB aabb;
aabb.lowerBound.Set(-1.0f, -1.0f); 
aabb.upperBound.Set(1.0f, 1.0f); 
myWorld->Query(&amp;callback, aabb);  </code></pre>
<p><code>Ray Casts</code></p>
<blockquote><p> You control the continuation of the ray cast by returning a fraction. Returning a  fraction of zero indicates the ray cast should be terminated. A fraction of one indicates  the ray cast should continue as if no hit occurred. </p></blockquote><pre><code>// This class captures the closest hit shape.
class MyRayCastCallback : public b2RayCastCallback {

public:

    MyRayCastCallback()
    {
        m_fixture = NULL;
    }

    float32 ReportFixture(b2Fixture* fixture, const b2Vec2&amp; point,
        const b2Vec2&amp; normal, float32 fraction)
    {
        m_fixture = fixture;
        m_point = point; 
        m_normal = normal; 
        m_fraction = fraction; 
        return fraction;
    }

    b2Fixture* m_fixture;
    b2Vec2 m_point;
    b2Vec2 m_normal;
    float32 m_fraction;
};

MyRayCastCallback callback;

b2Vec2 point1(-1.0f, 0.0f);
b2Vec2 point2(3.0f, 1.0f); 
myWorld->RayCast(&amp;callback, point1, point2);  </code></pre>
<blockquote><p> You may also return of fraction of -1 to filter the fixture. Then the ray  cast will proceed as if the fixture does not exist.</p></blockquote>
<p>todo</p>

    <script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.js"></script>
</body>
</html>
<script type="text/javascript" src="/docs/markdown_res/js/footer.js"></script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
<script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
