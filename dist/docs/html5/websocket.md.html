<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap-theme.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/markdown-7.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/page.css" />
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.js"></script>
</head>
<body>
    <div id="nav" class="row">
<a class="text-info pull-right" href="javascript:history.back()">Back</a>
    </div>

<h1> WebSocket调研</h1>

<p>W3C信息：<code>Web Applications Working Group</code>的草案，2012-09-20版的<code>The WebSocket API</code>。</p>

<p>对HTTP协议的补充，支持全双工通信，减少HTTP请求Header的冗余信息。</p>

<h2> 1. interface IDL</h2>
<pre><code>[Constructor(DOMString url, optional (DOMString or DOMString[]) protocols)]
interface WebSocket : EventTarget {
    readonly attribute DOMString url;

    // ready state
    const unsigned short CONNECTING = 0;
    const unsigned short OPEN = 1;
    const unsigned short CLOSING = 2;
    const unsigned short CLOSED = 3;
    readonly attribute unsigned short readyState;
    readonly attribute unsigned long bufferedAmount;

    // networking
             attribute EventHandler onopen;
             attribute EventHandler onerror;
             attribute EventHandler onclose;
    readonly attribute DOMString extensions;
    readonly attribute DOMString protocol;
    void close([Clamp] optional unsigned short code, optional DOMString reason);

    // messaging
             attribute EventHandler onmessage;
             attribute DOMString binaryType;
    void send(DOMString data);
    void send(Blob data);
    void send(ArrayBuffer data);
    void send(ArrayBufferView data);
};   </code></pre>
<h2> 2. 应用</h2>

<p>网页聊天室，<code>socket.io</code>是比较知名的封装。基于<code>nodejs</code>，启动支持websocket协议的server，
通常与Express框架配合，当然也可以独立运行。</p>



<h3> 2.1 独立运行</h3>

<pre><code>var server = require('http').createServer();
var io = require('socket.io')(server);
io.on('connection', function(socket){
  socket.on('event', function(data){});
  socket.on('disconnect', function(){});
});
server.listen(3000);     </code></pre>
<h3> 2.2 与Express配合</h3>
<pre><code>var app = require('express')();
var server = require('http').createServer(app);
var io = require('socket.io')(server);
io.on('connection', function(){ /* … */ });
server.listen(3000);   </code></pre>
<h3> 2.3 快速使用example</h3>
<p>安装node和npm，然后：</p>
<pre><code>git clone git@github.com:Automattic/socket.io.git
cd socket.io
npm install
cd example/chat
npm install
node . </code></pre>
<p>启动成功node server，默认监听<code>3000</code>端口。可以用浏览器访问了。</p>




<h2> 3. 原生用法</h2>
<p>提供的API：</p>
<pre><code>var ws = new WebSocket("ws://localhost:8080");
ws.onopen = function() {
    console.log("open");
    ws.send("hello");
};
ws.onmessage = function(evt) {
    console.log(evt.data)
};
ws.onclose = function(evt) {
    console.log("WebSocketClosed!");
};
ws.onerror = function(evt) {
    console.log("WebSocketError!");
};   </code></pre>
<h2> 4. Ping and Pong frames</h2>
<p>用于<code>keep-alive</code>， <code>hear-beats</code>， <code>network status probing</code>等。检测网络连接是否正常，显示连接延迟信息等。</p>






    <script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.js"></script>
</body>
</html>
<script type="text/javascript" src="/docs/markdown_res/js/footer.js"></script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
<script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
