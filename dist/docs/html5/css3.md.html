<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/markdown-7.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <style type="text/css">
        img {max-width: 100%; border: 1px solid #eee; }
        pre, code {color: #048ebd; }
        li>p {display: block;}
        p>code, li>code {padding:0; font-size: 13px; color: red;}
    </style>
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.js"></script>
</head>
<body>
    <div id="nav">
<a href="javascript:history.back()">返回 [ or Backspace ]</a>
    </div>

<h1> CSS3 Memo</h1>
<h2> 3D CSS Tester</h2>
<p><a href="http://thewebrocks.com/demos/3D-css-tester/">3D-CSS-Tester</a></p>



<h2> 3D CSS 说明</h2>
<pre><code>rotateX(angel)
rotateY(angel)
rotateZ(angel)


-webkit-transform: matrix3d(0.9993908270190958, 0, -0.03489949670250097, 0, 0, 1, 0, 0, 0.03489949670250097, 0, 0.9993908270190958, 0, 0, 0, 0, 1);
-webkit-transform: matrix3d(0.984807753012208, 0, 0.17364817766693033, 0, 0, 1, 0, 0, -0.17364817766693033, 0, 0.984807753012208, 0, 0, 0, 0, 1);
-webkit-transform: matrix3d(0.984807753012208, 0, 0.17364817766693, 0, 0, 1, 0, 0, -0.17364817766693, 0, 0.984807753012208, 0, 0, 0, 0, 1);  </code></pre>
<h2> JSAPI: RequestAnimationFrame</h2>

<p>最早由Mozilla的Reboert O'Callahan提出，他指出CSS transitions和animation的优势
在于浏览器知道哪些动画将会发生，所以得到正确的间隔来刷新UI。</p>
<p>而javascript动画，浏览器不知道动画正在发生，通过setTimeout或者setInterval定期操作DOM样式，js的这种
操作只是将渲染要求添加到UI渲染队列，并不保证立即渲染，UI渲染线程可能因为其他绘制
或者用户操作，延迟渲染，甚至出现丢帧现象。</p>
<p>他的解决方案是创建一个<code>mozRequestAnimationFrame()</code>方法，接收
一个参数，该参数是一个屏幕重绘前调用的函数，该函数对DOM进行样式改变，这些改变用在下一次重绘中。</p>
<pre><code>window.requestAnimFrame = ( function(){  
    return  window.requestAnimationFrame
        || window.webkitRequestAnimationFrame 
        || window.mozRequestAnimationFrame    
        || window.oRequestAnimationFrame      
        || window.msRequestAnimationFrame     
        || function( callback ){  
            window.setTimeout(callback, 1000/60);  
        };  
})();  

// 调用  
function animationLoop(elem){  
    requestAnimFrame(animationLoop);  
    // logic  
    performStyleUpdate();
}  </code></pre>
<p>只执行一次，再次动画需要自行再调用requestAnimFrame。</p>
<p>这种方式，让浏览器知道Javascript何时尝试动画，利于浏览器做更多的优化处理。</p>
<p>优化在于，这种方式对于一个帧中对DOM的所有操作，只进行一次Layout和Paint，如果发生动画
的元素被隐藏了，那么就不再Paint。</p>





<h2> DOM-Event: transitionend </h2>
<blockquote><p> 该事件在transition完成时触发。如果在完成前，transition被移除，该事件不会被触发。</p></blockquote><p><code>事件特性：</code></p>
<ul><li>bubbles: yes</li>
<li>cancelable: yes</li>
<li>context info: propertyName, elapsedTime, pseudoElement</li></ul>
<p><code>跨浏览器事件名：</code></p>
<ul><li>Android and Safari: <code>webkitTransitionEnd</code></li>
<li>Opera: 10 as <code>oTransitionEnd</code>, 12 as <code>otransitionend</code>, 12.10 as <code>transitionend</code></li></ul>
<p><code>Example:</code></p>
<pre><code>function showMessage() {
    alert('Transition has finished');
}

var element = document.getElementById("slidingMenu");
element.addEventListener("transitionend", showMessage, false);    </code></pre>
<h2> DOM-Event: Animation Events</h2>
<blockquote><p> 关键帧动画开始、结束，以及每次循环结束都会触发DOM事件。</p></blockquote><ol><li><code>animationstart</code><p>属性： animationName, pseudoElement</p>
</li>
<li><code>animationend</code><p>属性： animationName, elapsedTime, pseudoElement</p>
</li>
<li><code>animationiteration</code><p>属性： animationName, elapsedTime, pseudoElement</p>
</li></ol>
<p><code>事件特性：</code></p>
<ul><li>bubbles: yes</li>
<li>cancelable: no</li></ul>
<p><code>跨浏览器事件名：</code></p>
<ol><li><code>webkitAnimationEnd</code></li>
<li><code>oAnimationEnd</code></li>
<li><code>MSAnimationEnd</code></li></ol>
<h2> min-device-pixel-ratio</h2>
<p>移动系统支持情况：</p>
<ul><li>iOS3.2 +</li>
<li>Android 2.1+</li></ul>
<p><code>检测页面：</code> <a href="http://bjango.com/articles/min-device-pixel-ratio/">min-device-pixel-ratio</a></p>
<p>例如，针对3倍设备像素比的设备，使用<code>@3x</code>图片，可使用以下代码：</p>
<pre><code>@media only screen and (-webkit-min-device-pixel-ratio: 3) {
    selector {
        ...
    }
    ...
} </code></pre>
<p><code>js API</code>：</p>
<pre><code>ratio = window.devicePixelRatio;   </code></pre>
<h2> Media Queries</h2>
<ol><li><code>W3C：</code><a href="http://www.w3.org/TR/css3-mediaqueries/"></a></li>
<li><code>参考页面：</code><a href="http://www.cnblogs.com/asqq/archive/2012/04/13/2445912.html">Media Queries详解</a><p><link rel="stylesheet" media="screen and (max-width:600px)" href="small.css" type="text/css" />
<link rel="stylesheet" media="screen and (min-width:900px)" href="big.css" type="text/css"  />
<link rel="stylesheet" media="screen and (max-device-width: 480px)" href="iphone.css" type="text/css" />
<link rel="stylesheet" media="only screen and (-webkit-min-device-pixel-ratio: 2)" type="text/css" href="iphone4.css" />
<link rel="stylesheet" media="all and (orientation:portrait)" href="portrait.css" type="text/css" /> 
<link rel="stylesheet" media="all and (orientation:landscape)" href="landscape.css"  type="text/css" />
<link rel="stylesheet" media="not print and (max-width: 1200px)" href="print.css" type="text/css" />
<link rel="stylesheet" media="only screen and (max-device-width:240px)" href="android240.css" type="text/css" /></p>
</li></ol>

    <script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.js"></script>
</body>
</html>
<script type="text/javascript">
(function(){

document.title = $('h1').html() || '技术文档－258i.com';    

$(document).on('keydown', function(e){
    var BACKSPACE = 8,
        LEFT = 37;

    if(BACKSPACE == e.keyCode
        || BACKSPACE == e.which
        || LEFT == e.keyCode
        || LEFT == e.which){
        e.preventDefault();
        history.back();
    }
});

})();
</script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
