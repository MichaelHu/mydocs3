<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap-theme.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/github-markdown.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/page.css" />
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.min.js"></script>
    <style type="text/css">

    </style>

</head>
<body class="markdown-body">
    <div id="nav" class="row">
<a class="text-info pull-right" href="javascript:history.back()">Back</a>
    </div>

<h1> HTTPS Basics</h1>

<h2> HTTPS和HTTP的区别</h2>
<p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。</p>
<p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL<code>依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密</code>。</p>
<ol><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li>
<li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol>
<h2> HTTPS代理</h2>
<p>普通HTTPs代理只是充当了<code>转发</code>的功能，比如服务器在收到</p>
<pre><code>CONNECT www.xxx.com:443 HTTP/1.0 </code></pre>
<p>请求后返回   </p>
<pre><code>HTTP/1.0 200 Connection established </code></pre>
<p>通知客户端建立了连接，之后只负责把客户端的数据转发到相关端口。
不过<code>goagent</code>那种是属于通过假证书再与两边连接的。 </p>
<p>比如内部网络的主机不能直接连接外网，只能通过HTTP Proxy，例如<code>squid</code>，访问外部网站，而且通常
只允许访问<code>80、443、8080</code>这样的端口。当你通过HTTP代理访问外网服务时，如果你请求的是http协议的数据，
代理会先接收你的请求，然后发送请求到服务器，获得响应后先在本地建立缓存，并将缓存返回给客户端。
这个过程中，你发出的数据会被HTTP代理解析、修改。</p>
<p>但是如果你请求的是<code>https协议</code>的数据，由于https协议本身是加密的，<code>只有在你的请求没有受到任何修改的情况下（HTTP头也不能被修改），客户端才能正确获得响应</code>。
因此，HTTP代理不会修改你的请求，只会在客户端和服务器之间建立一个HTTP的CONNECT连接，
连接建立成功后，客户端可以将此连接当作普通的<code>socks</code>连接，用它传输任何内容，例如用作端口转发。
很多木马都会使用这种技术作<code>内网穿透</code>，效果也非常好。</p>
<p>HTTPS/SSL连接在连接代理服务器时，发送了<code>CONNECT  Address:Port</code> 的请求，你就<code>直接连接Address:Port</code>就好了。连接成功返回个成功消息。随后整个连接直接发送/接收二进制流，不需要关心它里面到底是ssl还是别的什么。</p>




<h2> 握手过程</h2>
<p>为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：</p>
<ol><li>客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</li>
<li>服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</li>
<li>客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</li>
<li>用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</li>
<li>如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。</li>
<li>如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</li>
<li>服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</li>
<li>客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</li>
<li>服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</li>
<li>SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</li></ol>

</body>
</html>
<script type="text/javascript" src="/docs/markdown_res/js/footer.js"></script>
<script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
