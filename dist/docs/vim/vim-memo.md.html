<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/bootstrap/css/bootstrap-theme.min.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/markdown-7.css" />
    <link rel="stylesheet" type="text/css" href="/docs/markdown_res/css/nav.css" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <style type="text/css">
        body {padding: 15px;}
        img {max-width: 100%; border: 1px solid #eee; }
        pre, code {color: #048ebd; }
        li>p {display: block;}
        p>code, li>code {padding:0; font-size: 13px; color: red;}
    </style>
    <script type="text/javascript" src="/docs/markdown_res/js/jquery-1.9.1.js"></script>
</head>
<body>
    <div id="nav" class="row">
<a class="text-info pull-right" href="javascript:history.back()">Back</a>
    </div>

<h1> VIM 备忘</h1>
<p>2014-11-05 hudamin - 转载请注明出处</p>
<blockquote><p> 向编辑神器VIM致敬 </p></blockquote><h2> 拎出来放在前面的内容</h2>
<ol><li>编辑模式搞清楚，记住<code>normal, insert, visual, command-line</code></li>
<li><code>normal</code>模式下，<code>单引号'</code>用于访问mark，<code>双引号"</code>用于设置下一delete，yank或者put操作使用的寄存器</li>
<li><code>normal</code>以及<code>command-line</code>模式下，<code>@</code>用于访问寄存器</li>
<li>带<code>g前缀</code>的命令原来功能这么强大，比如：<code>g0, g^, g$, gm, gp, gP, gJ, ge, gE, 
    ga, g8, g CTRL-G, gk, gj</code>，<p>你知道几个？会用几个？</p>
</li>
<li><code>insert</code>模式下，<code>CTRL-N</code>能用于输入补全提示</li></ol>
<h2> Help</h2>
<p>记住不同模式的help前缀，<code>:helpgrep</code>全文查找功能很赞。</p>
<pre><code>:help

:helpgrep {word}
:helpgrep :if exists

" jump
CTRL-]
" jump back
CTRL-T or CTRL-O 

" normal mode command
:help x

" visual mode command
:help v_x

" insert mode command
:help i_x

" command-line command
:help :x

" command-line editing
:help c_x

" vim command argument
:help -x

" option
:help 'x'   </code></pre>
<h2> Inserting Commands</h2>

<p><code>特殊insert：</code></p>
<pre><code>:r {file}
:r! command </code></pre>
<p>关于<code>++opt</code>：</p>
<blockquote><p> The [++opt] argument can be used to force the value of 'fileformat', 'fileencoding' or 'binary' to a value for one command, and to specify the behavior for bad characters.</p></blockquote><p>格式为：</p>
<pre><code>++{optname}
++{optname}={value} </code></pre>
<p><code>{optname}</code>可以是以下值：</p>
<pre><code>ff     or  fileformat   overrides 'fileformat'
enc    or  encoding     overrides 'fileencoding'                                                              
bin    or  binary       sets 'binary'               
nobin  or  nobinary     resets 'binary'
bad                     specifies behavior for bad characters
edit                    for |:read| only: keep option values as if editing
                        a file </code></pre>
<p>举例如下：</p>
<pre><code>:e ++ff=unix
:w ++enc=latin1 newfile   </code></pre>
<h2> Left-right motions</h2>
<p>常用的：<code>h, l, 0, ^, t{char}, T{char}</code></p>
<p>值得注意的：<code>g0, g^, g$, gm, |, f{char}, F{char}</code></p>

<pre><code>[N]h            left (also: CTRL-H, &lt;BS>, or &lt;Left> key)
[N]l            right (also: &lt;Space> or &lt;Right> key)
0               to first character in the line (also: &lt;Home> key)
^               to first non-blank character in the line
[N]$            to the last character in the line (N-1 lines lower) (also: &lt;End> key)
g0              to first character in screen line (differs from "0" when lines wrap)
g^              to first non-blank character in screen line (differs from "^" when lines wrap)
[N]g$           to last character in screen line (differs from "$" when lines wrap)
gm              to middle of the screen line
[N}|            to column N (default: 1)

[N]f{char}      to the Nth occurrence of {char} to the right
[N]F{char}      to the Nth occurrence of {char} to the left
[N]t{char}      till before the Nth occurrence of {char} to the right
[N]T{char}      till before the Nth occurrence of {char} to the left
[N];            repeat the last "f", "F", "t", or "T" N times
[N],            repeat the last "f", "F", "t", or "T" N times in opposite direction     </code></pre>
<h2> Up-down motions</h2>

<p>常用的：<code>k, j, gg, G, H, M, L, %</code></p>
<p>值得注意的：<code>-, +, _, G, N%, gk, gj</code></p>

<pre><code>[N]k            up N lines (also: CTRL-P and &lt;Up>)
[N]j            down N lines (also: CTRL-J, CTRL-N, &lt;NL>, and &lt;Down>
[N]-            up N lines, on the first non-blank character
[N]+            down N lines, on the first non-blank character (also: CTRL-M and &lt;CR>)

[N}_            down N-1 lines, on the first non-blank character
[N]G            goto line N (default: last line), on the first non-blank character 
[N]gg           goto line N (default: first line), on the first non-blank character
N%              goto line N percentage down in the file; N must be given, otherwise 
                it is the "%" command
[N]gk           up N screen lines (differs from "k" when line wraps) 
[N]gj           down N screen lines (differs from "j" when line wraps)

H               To line [count] from top of window (default: first line
                on the window) on the first non-blank character.
M               to Middle line of window, on the first non-blank character.
L               to line [count] from bottom of window (default: last line
                on the window) on the first non-blank character

%               Find the next item in this line after or under the cursor and
                jump to its match. Items can be: ([{}]), /* */
CTRL-Y                 </code></pre>
<h2> External Commands</h2>
<pre><code>:sh[ell]
:!{command}
K </code></pre>
<h2> Syntax Highlighting </h2>
<pre><code>:syntax on
:syntax off
:syntax clear
:highlight clear
:filetype on  </code></pre>
<h2> Folding</h2>
<pre><code>:{range}fold
zf{motion}

zd
zD

zo
zO
zc
zC

zm
zM
zr
zR

zn
zN
zi </code></pre>
<h2> Visual Mode</h2>
<pre><code>v
CTRL-V
v_o   </code></pre>
<h2> Options</h2>
<pre><code>:se[t]                  
:se[t] all
:se[t] termcap

:se[t] {option}
:se[t] no{option}
:se[t] inv{option}

:se[t] {option}={value}
:se[t] {option}+={value}
:se[t] {option}-={value}

:se[t] {option}?
:se[t] {option}&amp;

:setl[ocal]
:setg[lobal]

:fix[del]
:opt[ions]    </code></pre>
<h2> Maps</h2>
<pre><code>:map &lt;F8> &lt;Esc>:g/^#/&lt;CR>    </code></pre>
<h2> Deleting text</h2>
<p>常用的如：<code>x, X, d, dd, D, J</code></p>
<p>注意，Mac下的<code>&lt;Del> ＝ Fn_&lt;Del></code></p>
<pre><code>[N]x                    delete N characters under and after the cursor
[N]&lt;Del>                same as "[N]x"
[N]X                    delete N characters before the cursor
[N]d{motion}            delete the text that is moved over with {motion}
{visual}                delete the highlighted text
[N]dd                   delete N lines
[N]D                    delete to the end of the line (and N-1 more lines)
[N]J                    join N-1 lines (delete &lt;EOL>s)
{visual}J               join the highlighted lines
[N]gJ                   like "J", but without inserting spaces
{visual}gJ              like "{visual}J", but without inserting spaces
[N]:[range]d [x]        delete [range] lines [into register x] </code></pre>
<ol><li><code>[N]d$</code> 等价于 <code>[N]D</code></li>
<li><code>[N]:[range]d [x]</code>可以将删除文件放入指定寄存器</li></ol>
<h2> Copying and moving text</h2>
<p>有用的如：<code>"{char}, :reg, :reg {arg}, y, p, P</code></p>
<pre><code>"{char}             use register {char} ( {a-zA-Z0-9.%#:-"} ) for the next delete, yank, or put
                    (use uppercase character to append with delete and yank)
                    ({.%#:} only work with put)
:reg                show the contents of all registers
:reg {arg}          show the contents of registers mentioned in {arg}
:di[splay]          same as :registers
:di {arg}           same as :reg {arg}
[N]["x]y{motion}
{visual}["x]y
:[range]y[ank] [x]
[N]["x]yy
[N]["x]Y
[N]["x]p
[N]["x]P
[N]["x]]p
[N]["x][p
[N]["x]gp
[N]["x]gP  </code></pre>
<ol><li>:reg {arg}<pre><code>" 查看寄存器", 0, 1, 2的内容
:reg "012 </code></pre>
</li>
<li>使用好寄存器解决剪切内容丢失问题：<pre><code>" show retisters 
:reg
" use register 3 for the next delete, yank or put 
"3
" put 
p </code></pre>
</li>
<li>将指定行保存到寄存器中：<pre><code>:10,15y a  </code></pre>
</li></ol>
<h2> Text Motions</h2>
<p>常用的如<code>w, W, b, B, ), (, }, {</code></p>
<pre><code>[N]w            N words forward
[N]W            N blank-separated WORDs forward
[N]e            forward to the end of the Nth word
[N]E            forward to the end of the Nth blank-separated WORD

[N]b            N words backward
[N]B            N blank-separated WORDs backward
[N]ge           backward to the end of the Nth word
[N]gE           backward to the end of the Nth blank-separated WORD

[N])            N sentences forward
[N](            N sentences backward
[N]}            N paragraphs forward
[N]{            N paragraphs backward
[N]]]           N sections forward, at start of section
[N][[           N sections backward, at start of section
[N]][           N sections forward, at end of section
[N][]           N sections backward, at end of section
[N][(
[N][{
[N][m
[N][M
[N]])
[N]]}
[N]]m
[N]]M
[N][#
[N]]#
[N][*           N times back to start of comment "/*"
[N]]*           N times forward to end of comment "*/"    </code></pre>
<h2> Recording</h2>
<p>记录操作序列至寄存器，在需要的时候直接输入<code>@{register}</code>，操作序列会执行一遍。</p>
<pre><code>" start recording into register 'a' 
qa
:s/&lt;/+++/g
:s/>/---/g
&lt;CR>
" stop recording
q

" execute register 'a'
[count]@a   </code></pre>
<h2> Quickfix </h2>
<pre><code>:cw     </code></pre>
<h2> Bar</h2>
<p>用来分隔命令，不是管道，如果需要用字面量，使用<code>"\|"</code></p>
<pre><code>:let lines = getline(1, '$') | for i in lines | echo "> " . i | endfor  </code></pre>
<p>但是，以下命令将<code>|</code>作为其参数，所以不能用<code>|</code>作为命令分隔符。</p>
<pre><code>:argdo
:autocmd
:bufdo
:command
:cscope
:debug
:folddoopen
:folddoclosed
:function
:global
:help
:helpfind
:lcscope
:make
:normal
:perl
:perldo
:promptfind
:promptrepl
:pyfile
:python
:registers
:read !
:scscope
:sign
:tcl
:tcldo
:tclfile
:vglobal
:windo
:write !
:[range]!   </code></pre>
<h2> Ranges</h2>
<blockquote><p> 查看输入：<code>help :range</code></p></blockquote><p>常用的如：<code>*, '&lt;, '></code></p>
<pre><code>" from line 4 till match with ":sign" after the cursor line
:4,/:sign/

" from line 4 till match with ":sign" after line 5 
:5;/:sign/

" from current line to end of file
:.,$

" from begin of file to  end of file
:%

" from current line to position of mark t
:.,'t

" from current line to next line match /^##/
:.,/^##/

" from current line to previous line match /^##/
:.,?^##?

" from current line to the next line where the previously used search pattern matches
:.,\/

" from current line to the previous line where the previously used search pattern matches
:.,\?

" from current line to the next line where the previously used substitute pattern matches
:.,\&amp;


" visual area
:*
:'&lt;,'>     </code></pre>
<h2> Args and ArgsDo</h2>
<p>替换整个目录（包含子目录）下的js文件中的<code>&lt;</code>为<code>&amp;lt;</code></p>
<pre><code>:args **/*.js
:args
:argdo %s/&lt;/&amp;lt;/g | up  </code></pre>
<p>更换当前目录下的c文件的文件格式：</p>
<pre><code>:args *.c
:argdo set ff=unix | update     </code></pre>
<h2> Registers</h2>
<p>9种类型的寄存器，共48个：</p>
<ol><li>未命名寄存器<code>""</code></li>
<li>10个数字寄存器<code>"0</code> - <code>"9</code></li>
<li>小删除寄存器<code>"-</code></li>
<li>26个命名寄存器<code>"a</code> - <code>"z</code>或者<code>"A</code> - <code>"Z</code></li>
<li>4个只读寄存器<code>":</code>, <code>".</code>, <code>"%</code>, <code>"#</code></li>
<li>表达式寄存器<code>"=</code></li>
<li>selection and drop 寄存器<code>"*</code>, <code>"+</code>, <code>"~</code></li>
<li>黑洞寄存器<code>"_</code></li>
<li>上一检索模式寄存器<code>"/</code></li></ol>
<p>特殊寄存器举例如下：</p>
<pre><code>" the unnamed register, containing the text of the last delete or yank
:echo @"

" the current file name
:echo @%

" the alternate file name
:echo @#

:echo @*
:echo @+
:echo @/

" the last command-line
:echo @:

:echo @-
:echo @.
:echo @=     </code></pre>
<h2> Marks</h2>
<blockquote><p> <code>a-z</code> for buffer markers, <code>A-Z0-9</code> for file markers</p></blockquote><h3> Normal mode commands</h3>
<p><code>Set marker</code></p>
<pre><code>m{a-zA-Z}
m' or m`    set the previous context mark. this can be jumped to with the "''" or "``"
m[ or m]    set the "'[" or "']" mark  </code></pre>
<p><code>Jump to marker</code></p>
<pre><code>'{a-z} or `{a-z}            jump to the mark {a-z} in the current buffer 
'{A-Z0-9} or `{A-Z0-9}      to the mark {A-Z0-9} in the file where it ws set ( not a motion
                            command when in another file ).   </code></pre>
<p>比如当前在文档某个位置，希望临时去另外一个位置，然后还回来：</p>
<pre><code>m'
123gg
...
'' </code></pre>
<p>用于Visual mode选取，比如：</p>
<pre><code>m'
v
CTRL-D
CTRL-D
CTRL-D
CTRL-D
''  </code></pre>
<h3> command-line mode commands</h3>
<pre><code>:[range]ma[rk] {a-zA-Z'}    set mark {a-zA-Z'} at last line number in [range]
:[range]k{a-zA-Z'}          same as :mark, but the space before the mark name can be omitted 
:marks                      list all the marks
:marks {args}               list all the marks those are mentioned in {args}
:delm[arks] {marks}         delete the specified marks. Marks that can be deleted include A-Z and 0-9
:delm[arks]!                delete all marks for the current buffer, but not marks A-Z or 0-9    </code></pre>
<h2> Scrolling</h2>
<p>滚动屏幕，光标不跟随移动（除非要移出屏幕）：</p>
<pre><code>CTRL-E                      scroll window [count] lines downwards
CTRL-D                      scroll window downwards. the number of lines comes from the 
                            `scroll` option (default: half a screen)
CTRL-Y                      scroll window [count] lines upwards
CTRL-U                      scroll window upwards. the number of lines comes from the 
                            `scroll` option (default: half a screen)     </code></pre>
<h2> VimGrep</h2>
<pre><code>:vimgrep /&lt;script.\+>/ **/*.md
:cw

" % stands for current file?
:vimgrep /^##/ %
:cw </code></pre>
<h2> Files and Buffers</h2>
<p>常用的如：<code>:f, :ls, :ball</code></p>
<pre><code>:f[ile]             
:f[ile]!
{count}CTRL-G
g CTRL-G
:f[ile][!] {name}
:0f[ile][!]

" list all know buffer and file names
:buffers
:files
:ls

" edit all buffers
:ball

" edit all loaded buffers
:unhide

:badd {fname}
:bunload[!] [N]
:bdelete[!] [N]

:bfirst
:blast

:[N]bmod [N]  </code></pre>
<h2> Automatic Commands</h2>
<p>比较有用的比如：<code>:au, :au {event}, :au {event} {pat}</code></p>
<pre><code>:rv[iminfo] [file]
:rv[iminfo]! [file]
:wv[iminfo] [file]
:wv[iminfo]! [file]

" list all autocommands
:au

" list all autocommands for {event}
:au {event}

" list all autocommands for {event} with {pat}
:au {event} {pat}

" enter new autocommands for {event} with {pat}
:au {event} {pat} {cmd}

" do removement
:au!
:au! {event}
:au! * {pat}
:au! {event} {pat}
:au! {event} {pat} {cmd} </code></pre>
<p><code>Examples:</code></p>
<pre><code>:au filetypedetect
:au filetypedetect BufEnter
:au filetypedetect BufNewFile    </code></pre>
<h2> User-defined commands</h2>
<pre><code>:com[mand]
:com[mand] {cmd}
:com[mand][!] [{attr}...] {cmd} {rep}
:delc[ommand] {cmd}
:comc[lear] </code></pre>
<ol><li>:W命令<pre><code>command W w !sudo tee % > /dev/null   </code></pre>
</li></ol>
<h2> Various Commands</h2>
<p>有用的如：<code>CTRL-L, CTRL-G, ga, g8, :ve</code></p>
<pre><code>CTRL-L                      clear and redraw the screen
CTRL-G                      show current file name (with path) and cursor position
ga                          show ascii value of character under cursor in decimal, hex, and octal
g8                          for utf-8 encoding: show byte sequence for character under cursor
g CTRL-G                    show cursor column, line, and character position
CTRL-C                      during searches: Interrupt the search
&lt;Del>                       while entering a count: delete last character
:ve[rsion]                  show version information
:norm[al][!] {commands}     execute Normal mode commands
Q
:redir >{file}              [not in Vi] redirect messages to {file}
:silent[!] {command}
:confirm {command}
:browse {command}
CTRL-Break
:mode N   </code></pre>
<h2> 常见问题</h2>
<ol><li>使用过程中，方向键无法使用，出现<code>E388: couldn't find definition</code>，解决的方法之一，输入<pre><code>:!reset </code></pre>
<p>也可自行查找一下问题，看看键盘映射此时是否有异常，使用以下命令：</p>
<pre><code>:nmap &lt;Left>
:nmap &lt;Up>  </code></pre>
</li></ol>

    <script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.js"></script>
</body>
</html>
<script type="text/javascript" src="/docs/markdown_res/js/footer.js"></script>
<script type="text/javascript" src="/docs/markdown_res/js/scrollspy.js"></script>
<script type="text/javascript" src="/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
